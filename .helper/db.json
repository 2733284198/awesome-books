{"9787111255833":{"rating":{"max":10,"numRaters":1466,"average":"9.0","min":0},"subtitle":"","author":["Joshua Bloch"],"pubdate":"2009-1-1","tags":[{"count":1171,"name":"java","title":"java"},{"count":830,"name":"Java","title":"Java"},{"count":624,"name":"编程","title":"编程"},{"count":396,"name":"effective","title":"effective"},{"count":347,"name":"计算机","title":"计算机"},{"count":320,"name":"程序设计","title":"程序设计"},{"count":269,"name":"经典","title":"经典"},{"count":220,"name":"软件开发","title":"软件开发"}],"origin_title":"Effective Java Second Edition","image":"https://img3.doubanio.com/view/subject/m/public/s3479802.jpg","binding":"平装","translator":["俞黎敏"],"catalog":"译者序\n序\n前言\n致谢\n第1章 引言\n第2章 创建和销毁对象\n第1条：考虑用静态工厂方法代替构造器\n第2条：遇到多个构造器参数时要考虑用构建器\n第3条：用私有构造器或者枚举类型强化Singleton属性\n第4条：通过私有构造器强化不可实例化的能力\n第5条：避免创建不必要的对象\n第6条：消除过期的对象引用\n第7条：避免使用终结方法\n第3章 对于所有对象都通用的方法\n第8条：覆盖equals时请遵守通用约定\n第9条：覆盖equals时总要覆盖hashCode\n第10条：始终要覆盖toString\n第11条：谨慎地覆盖clone\n第12条：考虑实现Comparable接口\n第4章 类和接口\n第13条：使类和成员的可访问性最小化\n第14条：在公有类中使用访问方法而非公有域\n第15条：使可变性最小化\n第16条：复合优先于继承\n第17条：要么为继承而设计，并提供文档说明，要么就禁止继承\n第18条：接口优于抽象类\n第19条：接口只用于定义类型\n第20条：类层次优于标签类\n第21条：用函数对象表示策略\n第22条：优先考虑静态成员类\n第5章 泛型\n第23条：请不要在新代码中使用原生态类型\n第24条：消除非受检警告\n第25条：列表优先于数组\n第26条：优先考虑泛型\n第27条：优先考虑泛型方法\n第28条：利用有限制通配符来提升API的灵活性\n第29条：优先考虑类型安全的异构容器\n第6章 枚举和注解\n第30条：用enum代替int常量\n第31条：用实例域代替序数\n第32条：用EnumSet代替位域\n第33条：用EnumMap代替序数索引\n第34条：用接口模拟可伸缩的枚举\n第35条：注解优先于命名模式\n第36条：坚持使用Override注解\n第37条：用标记接口定义类型\n第7章 方法\n第38条：检查参数的有效性\n第39条：必要时进行保护性拷贝\n第40条：谨慎设计方法签名\n第41条：慎用重载\n第42条：慎用可变参数\n第43条：返回零长度的数组或者集合，而不是：null\n第44条：为所有导出的API元素编写文档注释\n第8章 通用程序设计\n第45条：将局部变量的作用域最小化\n第46条：for-each循环优先于传统的for循环\n第47条：了解和使用类库\n第48条：如果需要精确的答案，请避免使用float和double\n第49条：基本类型优先于装箱基本类型\n第50条：如果其他类型更适合，则尽量避免使用字符串\n第51条：当心字符串连接的性能\n第52条：通过接口引用对象\n第53条：接口优先于反射机制\n第54条：谨慎地使用本地方法\n第55条：谨慎地进行优化\n第56条：遵守普遍接受的命名惯例\n第9章 异常\n第57条：只针对异常的情况才使用异常\n第58条：对可恢复的情况使用受检异常，对编程错误使用运行时异常\n第59条：避免不必要地使用受检的异常\n第60条：优先使用标准的异常\n第61条：抛出与抽象相对应的异常\n第62条：每个方法抛出的异常都要有文档\n第63条：在细节消息中包含能捕获失败的信息\n第64条：努力使失败保持原子性\n第65条：不要忽略异常\n第10章 并发\n第66条：同步访问共享的可变数据\n第67条：避免过度同步\n第68条：executor和task优先干线程\n第69条：并发工具优先于wait和notify\n第70条：线程安全性的文档化\n第71条：慎用延迟初始化\n第72条：不要依赖于线程调度器\n第73条：避免使用线程组\n第11章 序列化\n第74条：谨慎地实现Serializable接口\n第75条：考虑使用自定义的序列化形式\n第76条：保护性地编写readObject方法\n第77条：对于实例控制，枚举类型优先于readResolve\n第78条：考虑用序列化代理代替序列化实例\n附录 第1版与第2版条目对照\n中英文术语对照\n参考文献","pages":"287","images":{"small":"https://img3.doubanio.com/view/subject/s/public/s3479802.jpg","large":"https://img3.doubanio.com/view/subject/l/public/s3479802.jpg","medium":"https://img3.doubanio.com/view/subject/m/public/s3479802.jpg"},"alt":"https://book.douban.com/subject/3360807/","id":"3360807","publisher":"机械工业出版社","isbn10":"7111255836","isbn13":"9787111255833","title":"Effective java 中文版（第2版）","url":"https://api.douban.com/v2/book/3360807","alt_title":"Effective Java Second Edition","author_intro":"Joshua Bloch是Google公司的首席Java架构师。是Jolt大奖的获得者。他曾是Sun公司的杰出工程师，和Transarc公司的高级系统设计师。Bloch曾带领团队设计和实现过无数的Java平台特性，包括JDK 5.0语言增强版和获奖的Java Collections Framework。他的著作还包括：《Java Puzzlers》、《Java Concurrency in Practive》等。","summary":"本书介绍了在Java编程中78条极具实用价值的经验规则，这些经验规则涵盖了大多数开发人员每天所面临的问题的解决方案。通过对Java平台设计专家所使用的技术的全面描述，揭示了应该做什么，不应该做什么才能产生清晰、健壮和高效的代码。\n本书中的每条规则都以简短、独立的小文章形式出现，并通过例子代码加以进一步说明。本书内容全面，结构清晰，讲解详细。可作为技术人员的参考用书。","series":{"id":"28333","title":"Sun公司核心技术丛书"},"price":"52.00元"},"9787508353937":{"rating":{"max":10,"numRaters":2700,"average":"9.2","min":0},"subtitle":"","author":["弗里曼"],"pubdate":"2007-9","tags":[{"count":2800,"name":"设计模式","title":"设计模式"},{"count":822,"name":"计算机","title":"计算机"},{"count":648,"name":"编程","title":"编程"},{"count":563,"name":"软件工程","title":"软件工程"},{"count":499,"name":"Headfirst","title":"Headfirst"},{"count":489,"name":"软件设计","title":"软件设计"},{"count":414,"name":"java","title":"java"},{"count":335,"name":"软件开发","title":"软件开发"}],"origin_title":"","image":"https://img3.doubanio.com/view/subject/m/public/s2686916.jpg","binding":"平装","translator":["O'Reilly Taiwan公司"],"catalog":"引子\n谁适合读这本书?\n我们知道你的大脑在想什么\n元认知\n让你的大脑就范\n技术审校\n致谢\n1　欢迎来到设计模式世界：设计模式入门\n模拟鸭子应用\nJoe想到继承\n利用接口如何？\n软件开发的不变真理\n分开变化和不变部分\n设计鸭子的行为\n测试鸭子的代码\n动态地设置行为\n封装行为的大局观\n“有一个”比“是一个”更好\n策略模式\n共享模式词汇的威力\n我如何使用设计模式？\n设计箱内的工具\n习题解答\n2　让你的对象知悉现况\n气象观测站\n认识观察者模式\n出版者＋订阅者＝观罕者模式\n五分钟短剧：观察主题\n定义观察者模式\n松耦合的威力\n设计气象站\n实现气象站\n使用Java内建的观察者模式\njava.util.Observable的黑暗面\n设计箱内的工具\n习题解答\n……\n3　装饰者模式：装饰对象\n4　工厂模式：烘烤OO的精华\n5　单件模式：独一无二的对象\n6　命令模式：封装调用\n7　适配器模式与外观模式：随遇而安\n8　模板方法模式：封装算法\n9　送代器与组合模式：管理良好的集合\n10　状态模式：事物的状态\n11　代理模式：控制对象访问\n12　复合模式：模式中的模式\n13　与设计模式相处：真实世界中的模式\nA　附录A：剩下的模式","pages":"637","images":{"small":"https://img3.doubanio.com/view/subject/s/public/s2686916.jpg","large":"https://img3.doubanio.com/view/subject/l/public/s2686916.jpg","medium":"https://img3.doubanio.com/view/subject/m/public/s2686916.jpg"},"alt":"https://book.douban.com/subject/2243615/","id":"2243615","publisher":"中国电力出版社","isbn10":"7508353935","isbn13":"9787508353937","title":"Head First 设计模式（中文版）","url":"https://api.douban.com/v2/book/2243615","alt_title":"","author_intro":"","summary":"《Head First设计模式》(中文版)共有14章，每章都介绍了几个设计模式，完整地涵盖了四人组版本全部23个设计模式。前言先介绍这本书的用法；第1章到第11章陆续介绍的设计模式为Strategy、Observer、Decorator、Abstract Factory、Factory Method、Singleton，Command、Adapter、Facade、TemplateMethod、Iterator、Composite、State、Proxy。最后三章比较特别。第12章介绍如何将两个以上的设计模式结合起来成为新的设计模式(例如著名的MVC模式)，作者称其为复合设计模式(这是作者自创的名称，并非四人组的标准名词)，第13章介绍如何进一步学习设计模式，如何发觉新的设计模式等主题，至于第14章则很快地浏览尚未介绍的设计模式，包括Bridge、Builder、Chain of Responsibility、Flyweight、Interpreter、Mediator、Memento、Prototype，Visitor。第1章还介绍了四个○○基本概念(抽象、封装、继承、多态)，而第1章到第9章也陆续介绍了九个○○原则(Principle)。千万不要轻视这些○○原则，因为每个设计模式背后都包含了几个○○原则的概念。很多时候，在设计时有两难的情况，这时候我们必须回归到○○原则，以方便判断取舍。可以这么说：○○原则是我们的目标，而设计模式是我们的做法。","series":{"id":"10044","title":"O'Reilly深入浅出系列"},"price":"98.00元"},"9787115419347":{"rating":{"max":10,"numRaters":252,"average":"9.2","min":0},"subtitle":"","author":["厄马(Raoul-Gabriel Urma)","弗斯科(Mario Fusco)","米克罗夫特(Alan Mycroft)"],"pubdate":"2016-4-1","tags":[{"count":238,"name":"Java","title":"Java"},{"count":143,"name":"java8","title":"java8"},{"count":79,"name":"编程","title":"编程"},{"count":74,"name":"函数式编程","title":"函数式编程"},{"count":62,"name":"java","title":"java"},{"count":59,"name":"计算机","title":"计算机"},{"count":39,"name":"软件开发","title":"软件开发"},{"count":22,"name":"开发","title":"开发"}],"origin_title":"","image":"https://img1.doubanio.com/view/subject/m/public/s29343267.jpg","binding":"平装","translator":["陆明刚","劳佳"],"catalog":"第一部分 基础知识\n第1章　为什么要关心Java 8　　2\n1.1　Java怎么还在变　　4\n1.1.1　Java在编程语言生态系统中的位置　　4\n1.1.2　流处理　　6\n1.1.3　用行为参数化把代码传递给方法　　7\n1.1.4　并行与共享的可变数据　　7\n1.1.5　Java需要演变　　8\n1.2　Java中的函数　　8\n1.2.1　方法和Lambda作为一等公民　　9\n1.2.2　传递代码：一个例子　　11\n1.2.3　从传递方法到Lambda　　12\n1.3　流　　13\n1.4　默认方法　　17\n1.5　来自函数式编程的其他好思想　　18\n1.6　小结　　19\n第2章　通过行为参数化传递代码　　20\n2.1　应对不断变化的需求　　21\n2.1.1　初试牛刀：筛选绿苹果　　21\n2.1.2　再展身手：把颜色作为参数　　21\n2.1.3　第三次尝试：对你能想到的每个属性做筛选　　22\n2.2　行为参数化　　23\n2.3　对付啰嗦　　27\n2.3.1　匿名类　　28\n2.3.2　第五次尝试：使用匿名类　　28\n2.3.3　第六次尝试：使用Lambda表达式　　30\n2.3.4　第七次尝试：将List类型抽象化　　31\n2.4　真实的例子　　31\n2.4.1　用Comparator来排序　　31\n2.4.2　用Runnable执行代码块　　32\n2.4.3　GUI事件处理　　32\n2.5　小结　　33\n第3章　Lambda表达式　　34\n3.1　Lambda管中窥豹　　35\n3.2　在哪里以及如何使用Lambda　　37\n3.2.1　函数式接口　　37\n3.2.2　函数描述符　　39\n3.3　把Lambda付诸实践：环绕执行模式　　41\n3.3.1　第1步记得行为参数化　　41\n3.3.2　第2步：使用函数式接口来传递行为　　42\n3.3.3　第3步：执行一个行为　　42\n3.3.4　第4步：传递Lambda　　42\n3.4　使用函数式接口　　43\n3.4.1　Predicate　　44\n3.4.2　Consumer　　44\n3.4.3　Function　　45\n3.5　类型检查、类型推断以及限制　　49\n3.5.1　类型检查　　49\n3.5.2　同样的Lambda，不同的函数式接口　　50\n3.5.3　类型推断　　51\n3.5.4　使用局部变量　　52\n3.6　方法引用　　53\n3.6.1　管中窥豹　　53\n3.6.2　构造函数引用　　55\n3.7　Lambda和方法引用实战　　57\n3.7.1　第1步：传递代码　　58\n3.7.2　第2步：使用匿名类　　58\n3.7.3　第3步：使用Lambda表达式　　58\n3.7.4　第4步：使用方法引用　　59\n3.8　复合Lambda表达式的有用方法　　59\n3.8.1　比较器复合　　60\n3.8.2　谓词复合　　60\n3.8.3　函数复合　　61\n3.9　数学中的类似思想　　62\n3.9.1　积分　　62\n3.9.2　与Java 8的Lambda联系起来　　63\n3.10　小结　　64\n第二部分 函数式数据处理\n第4章　引入流　　68\n4.1　流是什么　　68\n4.2　流简介　　72\n4.3　流与集合　　74\n4.3.1　只能遍历一次　　75\n4.3.2　外部迭代与内部迭代　　76\n4.4　流操作　　78\n4.4.1　中间操作　　78\n4.4.2　终端操作　　79\n4.4.3　使用流　　80\n4.5　小结　　81\n第5章　使用流　　82\n5.1　筛选和切片　　83\n5.1.1　用谓词筛选　　83\n5.1.2　筛选各异的元素　　83\n5.1.3　截短流　　84\n5.1.4　跳过元素　　85\n5.2　映射　　86\n5.2.1　对流中每一个元素应用函数　　86\n5.2.2　流的扁平化　　87\n5.3　查找和匹配　　90\n5.3.1　检查谓词是否至少匹配一个元素　　90\n5.3.2　检查谓词是否匹配所有元素　　90\n5.3.3　查找元素　　91\n5.3.4　查找第一个元素　　92\n5.4　归约　　92\n5.4.1　元素求和　　93\n5.4.2　最大值和最小值　　94\n5.5　付诸实践　　97\n5.5.1　领域：交易员和交易　　98\n5.5.2　解答　　99\n5.6　数值流　　101\n5.6.1　原始类型流特化　　101\n5.6.2　数值范围　　102\n5.6.3　数值流应用：勾股数　　103\n5.7　构建流　　105\n5.7.1　由值创建流　　106\n5.7.2　由数组创建流　　106\n5.7.3　由文件生成流　　106\n5.7.4　由函数生成流：创建无限流　　107\n5.8　小结　　110\n第6章　用流收集数据　　111\n6.1　收集器简介　　112\n6.1.1　收集器用作高级归约　　112\n6.1.2　预定义收集器　　113\n6.2　归约和汇总　　114\n6.2.1　查找流中的最大值和最小值　　114\n6.2.2　汇总　　115\n6.2.3　连接字符串　　116\n6.2.4　广义的归约汇总　　117\n6.3　分组　　120\n6.3.1　多级分组　　121\n6.3.2　按子组收集数据　　122\n6.4　分区　　126\n6.4.1　分区的优势　　126\n6.4.2　将数字按质数和非质数分区　　128\n6.5　收集器接口　　129\n6.5.1　理解Collector接口声明的方法　　130\n6.5.2　全部融合到一起　　134\n6.6　开发你自己的收集器以获得更好的性能　　135\n6.6.1　仅用质数做除数　　136\n6.6.2　比较收集器的性能　　139\n6.7　小结　　140\n第7章　并行数据处理与性能　　141\n7.1　并行流　　141\n7.1.1　将顺序流转换为并行流　　142\n7.1.2　测量流性能　　144\n7.1.3　正确使用并行流　　147\n7.1.4　高效使用并行流　　148\n7.2　分支/合并框架　　149\n7.2.1　使用RecursiveTask　　149\n7.2.2　使用分支/合并框架的最佳做法　　153\n7.2.3　工作窃取　　154\n7.3　Spliterator　　155\n7.3.1　拆分过程　　155\n7.3.2　实现你自己的Spliterator　　157\n7.4　小结　　162\n第三部分 高效Java 8编程\n第8章　重构、测试和调试　　164\n8.1　为改善可读性和灵活性重构代码　　164\n8.1.1　改善代码的可读性　　165\n8.1.2　从匿名类到Lambda表达式的转换　　165\n8.1.3　从Lambda表达式到方法引用的转换　　166\n8.1.4　从命令式的数据处理切换到Stream　　167\n8.1.5　增加代码的灵活性　　168\n8.2　使用Lambda重构面向对象的设计模式　　170\n8.2.1　策略模式　　171\n8.2.2　模板方法　　172\n8.2.3　观察者模式　　173\n8.2.4　责任链模式　　175\n8.2.5　工厂模式　　177\n8.3　测试Lambda表达式　　178\n8.3.1　测试可见Lambda函数的行为　　179\n8.3.2　测试使用Lambda的方法的行为　　179\n8.3.3　将复杂的Lambda表达式分到不同的方法　　180\n8.3.4　高阶函数的测试　　180\n8.4　调试　　181\n8.4.1　查看栈跟踪　　181\n8.4.2　使用日志调试　　183\n8.5　小结　　184\n第9章　默认方法　　 185\n9.1　不断演进的API　　 187\n9.1.1　初始版本的API　　188\n9.1.2　第二版API　　188\n9.2　概述默认方法　　190\n9.3　默认方法的使用模式　　192\n9.3.1　可选方法　　192\n9.3.2　行为的多继承　　192\n9.4　解决冲突的规则　　196\n9.4.1　解决问题的三条规则　　196\n9.4.2　选择提供了最具体实现的默认方法的接口　　197\n9.4.3　冲突及如何显式地消除歧义　　198\n9.4.4　菱形继承问题　　200\n9.5　小结　　201\n第10章　用Optional取代null　　202\n10.1　如何为缺失的值建模　　 203\n10.1.1　采用防御式检查减少Null-PointerException　　203\n10.1.2　null带来的种种问题　　204\n10.1.3　其他语言中null的替代品　　205\n10.2　Optional类入门　　206\n10.3　应用Optional的几种模式　　 207\n10.3.1　创建Optional对象　　208\n10.3.2　使用map从Optional对象中提取和转换值　　208\n10.3.3　使用flatMap链接Optional对象　　209\n10.3.4　默认行为及解引用Optional对象　　213\n10.3.5　两个Optional对象的组合　　213\n10.3.6　使用filter剔除特定的值　　214\n10.4　使用Optional的实战示例　　 216\n10.4.1　用Optional封装可能为null的值　　216\n10.4.2　异常与Optional的对比　　217\n10.4.3　把所有内容整合起来　　218\n10.5　小结　　219\n第11章　CompletableFuture：组合式异步编程　　220\n11.1　Future接口　　222\n11.1.1　Future接口的局限性　　223\n11.1.2　使用CompletableFuture构建异步应用　　223\n11.2　实现异步API　　 224\n11.2.1　将同步方法转换为异步方法　　225\n11.2.2　错误处理　　227\n11.3　让你的代码免受阻塞之苦　　228\n11.3.1　使用并行流对请求进行并行操作　　229\n11.3.2　使用CompletableFuture发起异步请求　　230\n11.3.3　寻找更好的方案　　232\n11.3.4　使用定制的执行器　　233\n11.4　对多个异步任务进行流水线操作　　234\n11.4.1　实现折扣服务　　235\n11.4.2　使用Discount服务　　236\n11.4.3　构造同步和异步操作　　237\n11.4.4　将两个Completable-Future对象整合起来，无论它们是否存在依赖　　239\n11.4.5　对Future和Completable-Future的回顾　　241\n11.5　响应CompletableFuture的completion事件　　242\n11.5.1　对最佳价格查询器应用的优化　　243\n11.5.2　付诸实践　　244\n11.6　小结　　245\n第12章　新的日期和时间API　　246\n12.1　LocalDate、LocalTime、Instant、Duration以及Period　　247\n12.1.1　使用LocalDate和LocalTime　　247\n12.1.2　合并日期和时间　　248\n12.1.3　机器的日期和时间格式　　249\n12.1.4　定义Duration或Period　　249\n12.2　操纵、解析和格式化日期　　251\n12.2.1　使用TemporalAdjuster　　253\n12.2.2　打印输出及解析日期－时间对象　　255\n12.3　处理不同的时区和历法　　256\n12.3.1　利用和UTC/格林尼治时间的固定偏差计算时区　　257\n12.3.2　使用别的日历系统　　258\n12.4　小结　　259\n第四部分 超越Java 8\n第13章　函数式的思考　　262\n13.1　实现和维护系统　　262\n13.1.1　共享的可变数据　　263\n13.1.2　声明式编程　　264\n13.1.3　为什么要采用函数式编程　　265\n13.2　什么是函数式编程　　265\n13.2.1　函数式Java编程　　266\n13.2.2　引用透明性　　268\n13.2.3　面向对象的编程和函数式编程的对比　　 268\n13.2.4　函数式编程实战　　269\n13.3　递归和迭代　　271\n13.4　小结　　274\n第14章　函数式编程的技巧　　275\n14.1　无处不在的函数　　275\n14.1.1　高阶函数　　275\n14.1.2　科里化　　277\n14.2　持久化数据结构　　278\n14.2.1　破坏式更新和函数式更新的比较　　279\n14.2.2　另一个使用Tree的例子　　281\n14.2.3　采用函数式的方法　　282\n14.3　Stream的延迟计算　　283\n14.3.1　自定义的Stream　　 283\n14.3.2　创建你自己的延迟列表　　286\n14.4　模式匹配　　290\n14.4.1　访问者设计模式　　291\n14.4.2　用模式匹配力挽狂澜　　292\n14.5　杂项　　295\n14.5.1　缓存或记忆表　　295\n14.5.2　“返回同样的对象”意味着什么　　296\n14.5.3　结合器　　296\n14.6　小结　　297\n第15章　面向对象和函数式编程的混合：Java 8和Scala的比较　　 299\n15.1　Scala简介　　300\n15.1.1　你好，啤酒　　300\n15.1.2　基础数据结构：List、Set、Map、Tuple、Stream以及Option　　302\n15.2　函数　　306\n15.2.1　Scala中的一等函数　　307\n15.2.2　匿名函数和闭包　　307\n15.2.3　科里化　　309\n15.3　类和trait　　310\n15.3.1　更加简洁的Scala类　　310\n15.3.2　Scala的trait与Java 8的接口对比　　311\n15.4　小结　　312\n第16章　结论以及Java的未来　　313\n16.1　回顾Java 8的语言特性　　 313\n16.1.1　行为参数化（Lambda 以及方法引用）　　314\n16.1.2　流　　314\n16.1.3　CompletableFuture　　315\n16.1.4　Optional　　315\n16.1.5　默认方法　　316\n16.2　Java 的未来　　316\n16.2.1　集合　　316\n16.2.2　类型系统的改进　　317\n16.2.3　模式匹配　　318\n16.2.4　更加丰富的泛型形式　　319\n16.2.5　对不变性的更深层支持　　321\n16.2.6　值类型　　322\n16.3　写在最后的话　　325\n附录A　其他语言特性的更新　　326\n附录B　类库的更新　　330\n附录C　如何以并发方式在同一个流上执行多种操作　　338\n附录D　Lambda表达式和JVM 字节码　　346","pages":"349","images":{"small":"https://img1.doubanio.com/view/subject/s/public/s29343267.jpg","large":"https://img1.doubanio.com/view/subject/l/public/s29343267.jpg","medium":"https://img1.doubanio.com/view/subject/m/public/s29343267.jpg"},"alt":"https://book.douban.com/subject/26772632/","id":"26772632","publisher":"人民邮电出版社","isbn10":"7115419345","isbn13":"9787115419347","title":"Java 8实战","url":"https://api.douban.com/v2/book/26772632","alt_title":"","author_intro":"作者简介：\nRaoul-Gabriel Urma\n剑桥大学计算机科学博士，软件工程师，演讲者，培训师，Cambridge Coding Academy联合创始人、CEO。曾与谷歌、eBay、甲骨文和高盛集团等大公司合作，并参与过多个创业项目。撰写过十余篇经同行审阅的技术文章，并在国际会议上发表过40多篇演讲。\nMario Fusco\nRed Hat高级软件工程师，负责JBoss规则引擎Drools的核心开发。拥有丰富的Java开发经验，曾领导媒体公司、金融部门等多个行业的企业级项目开发。对函数式编程和领域特定语言等有浓厚兴趣，并创建了开放源码库lambdaj。\nAlan Mycroft\n剑桥大学计算机实验室计算学教授，剑桥大学罗宾逊学院研究员，欧洲编程语言和系统协会联合创始人，树莓派基金会联合创始人和理事。发表过大约100篇研究论文，指导过20多篇博士论文。他的研究主要关注编程语言及其语义、优化和实施。他与业界联系紧密，曾于学术休假期间在AT&T实验室和英特尔工作，还创立了Codemist公司，该公司设计了最初的ARM C编译器Norcroft。\n译者简介：\n陆明刚\n毕业于四川大学，目前在EMC中国卓越研发集团任首席工程师，曾任趋势科技中国软件研发中心技术经理，在信息科学和工程领域有十余年的实践和研究经验，拥有多项中国及美国专利。关注JVM性能调优和大数据及其实践，喜欢挖掘技术背后的内幕并乐此不疲。\n劳佳\n硕士毕业于上海交通大学，现在SAP美国任高级软件支持顾问。业余爱好语言、数学、设计，近年翻译出版了《咨询的奥秘》《卓越程序员密码》等书。","summary":"本书全面介绍了Java 8 这个里程碑版本的新特性，包括Lambdas、流和函数式编程。有了函数式的编程特性，可以让代码更简洁，同时也能自动化地利用多核硬件。全书分四个部分：基础知识、函数式数据处理、高效Java 8 编程和超越Java 8，清晰明了地向读者展现了一幅Java 与时俱进的现代化画卷。","price":"CNY 79.00"},"9787111321545":{"rating":{"max":10,"numRaters":690,"average":"8.2","min":0},"subtitle":"","author":["许晓斌"],"pubdate":"2010年12月","tags":[{"count":559,"name":"Maven","title":"Maven"},{"count":312,"name":"Java","title":"Java"},{"count":246,"name":"系统构建&自动化","title":"系统构建&自动化"},{"count":106,"name":"编程","title":"编程"},{"count":94,"name":"计算机","title":"计算机"},{"count":85,"name":"软件工程","title":"软件工程"},{"count":79,"name":"软件开发","title":"软件开发"},{"count":57,"name":"敏捷开发","title":"敏捷开发"}],"origin_title":"","image":"https://img3.doubanio.com/view/subject/m/public/s4524240.jpg","binding":"平装","translator":[],"catalog":"1. Maven简介\n1.1 何为Maven\n1.2 为什么需要Maven\n1.3 Maven与极限编程\n1.4 被误解的Maven\n2. Maven安装\n2.1 在Windows上安装Maven\n2.2 在基于Unix的系统上安装Maven\n2.3 安装目录分析\n2.4 设置HTTP代理\n2.5 安装m2eclipse\n2.6 安装NetBeans Maven插件\n2.7 Maven安装最佳实践\n3. Hello World\n3.1 编写POM\n3.2 编写主代码\n3.3 编写测试代码\n3.4 打包和运行\n3.5 使用Archetype生成项目骨架\n3.6 m2eclipse简单使用\n3.7 NetBeans Maven插件简单使用\n4. 背景案例\n4.1 简单的账户注册服务\n4.2 需求阐述\n4.3 简要设计\n5. 坐标和依赖\n5.1 何为Maven坐标\n5.2 坐标详解\n5.3 account-email\n5.4 依赖的配置\n5.5 依赖范围\n5.6 传递性依赖\n5.7 依赖调解\n5.8 可选依赖\n5.9 最佳实践\n6. 仓库\n6.1 何为Maven仓库\n6.2 仓库的布局\n6.3 仓库的分类\n6.4 远程仓库的配置\n6.5 快照版本\n6.6 从仓库解析依赖的机制\n6.7 镜像\n6.8 仓库搜索服务\n7. 生命周期和插件\n7.1 何为生命周期\n7.2 生命周期详解\n7.3 插件目标\n7.4 插件绑定\n7.5 插件配置\n7.6 获取插件信息\n7.7 从命令行调用插件\n7.8 插件解析机制\n8. 聚合与继承\n8.1 account-persist\n8.2 聚合\n8.3 继承\n8.4 聚合与继承的关系\n8.5 约定优于配置\n8.6 反应堆\n9. 使用 Nexus 创建私服\n9.1 Nexus简介\n9.2 安装Nexus\n9.3 Nexus的仓库与仓库组\n9.4 Nexus的索引与构件搜索\n9.5 配置Maven从Nexus下载构件\n9.6 部署构件至Nexus\n9.7 Nexus的权限管理\n9.8 Nexus的调度任务\n9.9 其他私服软件\n10. 使用 Maven 进行测试\n10.1 account-captcha\n10.2 maven-surefire-plugin简介\n10.3 跳过测试\n10.4 动态指定要运行的测试用例\n10.5 包含与排除测试用例\n10.6 测试报告\n10.7 运行TestNG测试\n10.8 重用测试代码\n11. 使用 Hudson 进行持续集成\n11.1 持续集成的作用、过程和优势\n11.2 Hudson简介\n11.3 安装Hudson\n11.4 准备Subversion仓库\n11.5 Hudson的基本系统设置\n11.6 创建Hudson任务\n11.7 监视Hudson任务状态\n11.8 Hudson用户管理\n11.9 邮件反馈\n11.10 Hudson工作目录\n12. 构建 Web 应用\n12.1 Web项目的基本结构\n12.2 account-service\n12.3 account-web\n12.4 使用jetty-maven-plugin进行测试\n12.5 使用Cargo实现自动化部署\n13. 版本管理\n13.1 何为版本管理\n13.2 Maven的版本号定义约定\n13.3 主干、标签与分支\n13.4 自动化版本发布\n13.5 自动化创建分支\n13.6 GPG签名\n14. 灵活的构建\n14.1 Maven属性\n14.2 构建环境的差异\n14.3 资源过滤\n14.4 Maven Profile\n14.5 Web资源过滤\n14.6 在Profile中激活集成测试\n15. 生成项目站点\n15.1 最简单的站点\n15.2 丰富项目信息\n15.3 项目报告插件\n15.4 自定义站点外观\n15.5 创建自定义页面\n15.6 国际化\n15.7 部署站点\n16. m2eclipse\n16.1 m2eclipse简介\n16.2 安装m2eclipse\n16.3 新建Maven项目\n16.4 导入Maven项目\n16.5 执行mvn命令\n16.6 访问Maven仓库\n16.7 管理项目依赖\n16.8 其它实用功能\n17. 编写 Maven 插件\n17.1 编写Maven插件的一般步骤\n17.2 代码行统计Maven插件\n17.3 Mojo标注\n17.4 Mojo参数\n17.5 错误处理和日志\n17.6 测试Maven插件\n18. Archetype\n18.1 Archetype使用再叙\n18.2 编写Archetype\n18.3 Archetype Catalog","ebook_url":"https://read.douban.com/ebook/15131794/","pages":"361","images":{"small":"https://img3.doubanio.com/view/subject/s/public/s4524240.jpg","large":"https://img3.doubanio.com/view/subject/l/public/s4524240.jpg","medium":"https://img3.doubanio.com/view/subject/m/public/s4524240.jpg"},"alt":"https://book.douban.com/subject/5345682/","id":"5345682","publisher":"机械工业出版社","isbn10":"7111321545","isbn13":"9787111321545","title":"Maven实战","url":"https://api.douban.com/v2/book/5345682","alt_title":"","author_intro":"许晓斌（Juven Xu），国内社区公认的Maven技术专家、Maven中文用户组创始人、Maven技术的先驱和积极推动者。对Maven有深刻的认识，实战经验丰富，不仅撰写了大量关于Maven的技术文章，而且还翻译了开源书籍《Maven权威指南》，对Maven技术在国内的普及和发展做出了很大的贡献。就职于Maven之父的公司，负责维护Maven中央仓库，是Maven仓库管理器Nexus（著名开源软件）的核心开发者之一，曾多次受邀到淘宝等大型企业开展Maven方面的培训。此外，他还是开源技术的积极倡导者和推动者，擅长Java开发和敏捷开发实践。","summary":"你是否早已厌倦了日复一日的手工构建工作？你是否对各个项目风格迥异的构建系统感到恐惧？Maven——这一Java社区事实标准的项目管理工具，能帮你从琐碎的手工劳动中解脱出来，帮你规范整个组织的构建系统。不仅如此，它还有依赖管理、自动生成项目站点等超酷的特性，已经有无数的开源项目使用它来构建项目并促进团队交流，每天都有数以万计的开发者在访问中央仓库以获取他们需要的依赖。\n本书内容全面而系统，Maven的原理、使用方法和高级应用尽含其中；注重实战是本书的另一个特点，不仅在各个知识点都辅有大量的小案例，而且还有一个综合性的案例贯穿全书。如果你想使用Maven，或正在使用Maven，本书将给你绝佳的指导。\n本书讨论专区：http://www.juvenxu.com/mvn-in-action/","ebook_price":"25.00","series":{"id":"19972","title":"实战系列"},"price":"65.00元"},"9787115453686":{"rating":{"max":10,"numRaters":108,"average":"7.8","min":0},"subtitle":"Netty IN ACTION","author":["诺曼·毛瑞尔（Norman Maurer）","马文·艾伦·沃尔夫泰尔（Marvin Allen Wolfthal）"],"pubdate":"2017-5-1","tags":[{"count":121,"name":"Netty","title":"Netty"},{"count":76,"name":"Java","title":"Java"},{"count":63,"name":"网络编程","title":"网络编程"},{"count":35,"name":"Netty实战","title":"Netty实战"},{"count":21,"name":"网络","title":"网络"},{"count":20,"name":"计算机","title":"计算机"},{"count":14,"name":"分布式","title":"分布式"},{"count":12,"name":"性能优化","title":"性能优化"}],"origin_title":"Netty IN ACTION","image":"https://img3.doubanio.com/view/subject/m/public/s29444565.jpg","binding":"平装","translator":["何品"],"catalog":"第一部分 Netty的概念及体系结构\n第1 章 Netty——异步和事件驱动 3\n1.1 Java 网络编程 4\n1.1.1 Java NIO 5\n1.1.2 选择器 6\n1.2 Netty 简介 6\n1.2.1 谁在使用Netty 7\n1.2.2 异步和事件驱动 8\n1.3 Netty 的核心组件 9\n1.3.1 Channel 9\n1.3.2 回调 9\n1.3.3 Future 10\n1.3.4 事件和ChannelHandler 11\n1.3.5 把它们放在一起 12\n1.4 小结 13\n第2 章 你的第一款Netty应用程序 14\n2.1 设置开发环境 14\n2.1.1 获取并安装Java 开发工具包 14\n2.1.2 下载并安装IDE 15\n2.1.3 下载和安装Apache Maven 15\n2.1.4 配置工具集 16\n2.2 Netty 客户端/服务器概览 16\n2.3 编写Echo 服务器 17\n2.3.1 ChannelHandler 和业务逻辑 17\n2.3.2 引导服务器 18\n2.4 编写Echo 客户端 21\n2.4.1 通过ChannelHandler 实现客户端逻辑 21\n2.4.2 引导客户端 22\n2.5 构建和运行Echo 服务器和客户端 24\n2.5.1 运行构建 24\n2.5.2 运行Echo 服务器和客户端 27\n2.6 小结 29\n第3 章 Netty 的组件和设计 30\n3.1 Channel、EventLoop 和ChannelFuture 30\n3.1.1 Channel 接口 31\n3.1.2 EventLoop 接口 31\n3.1.3 ChannelFuture 接口 32\n3.2 ChannelHandler 和ChannelPipeline 32\n3.2.1 ChannelHandler 接口 32\n3.2.2 ChannelPipeline 接口 33\n3.2.3 更加深入地了解ChannelHandler 34\n3.2.4 编码器和解码器 35\n3.2.5 抽象类SimpleChannelInboundHandler 35\n3.3 引导 36\n3.4 小结 37\n第4 章 传输 38\n4.1 案例研究：传输迁移 38\n4.1.1 不通过Netty 使用OIO和NIO 39\n4.1.2 通过Netty 使用OIO和NIO 41\n4.1.3 非阻塞的Netty 版本 42\n4.2 传输API 43\n4.3 内置的传输 45\n4.3.1 NIO——非阻塞I/O 46\n4.3.2 Epoll——用于Linux的本地非阻塞传输 47\n4.3.3 OIO——旧的阻塞I/O 48\n4.3.4 用于JVM 内部通信的Local 传输 48\n4.3.5 Embedded 传输 49\n4.4 传输的用例 49\n4.5 小结 51\n第5 章 ByteBuf 52\n5.1 ByteBuf 的API 52\n5.2 ByteBuf 类——Netty的数据容器 53\n5.2.1 它是如何工作的 53\n5.2.2 ByteBuf 的使用模式 53\n5.3 字节级操作 57\n5.3.1 随机访问索引 57\n5.3.2 顺序访问索引 57\n5.3.3 可丢弃字节 58\n5.3.4 可读字节 58\n5.3.5 可写字节 59\n5.3.6 索引管理 59\n5.3.7 查找操作 60\n5.3.8 派生缓冲区 60\n5.3.9 读/写操作 62\n5.3.10 更多的操作 64\n5.4 ByteBufHolder 接口 65\n5.5 ByteBuf 分配 65\n5.5.1 按需分配：ByteBufAllocator 接口 65\n5.5.2 Unpooled 缓冲区 67\n5.5.3 ByteBufUtil 类 67\n5.6 引用计数 67\n5.7 小结 68\n第6 章 ChannelHandler 和ChannelPipeline 70\n6.1 ChannelHandler 家族 70\n6.1.1 Channel 的生命周期 70\n6.1.2 ChannelHandler的生命周期 71\n6.1.3 ChannelInboundHandler接口 71\n6.1.4 ChannelOutboundHandler接口 73\n6.1.5 ChannelHandler 适配器 74\n6.1.6 资源管理 74\n6.2 ChannelPipeline 接口 76\n6.2.1 修改ChannelPipeline 78\n6.2.2 触发事件 79\n6.3 ChannelHandlerContext接口 80\n6.3.1 使用ChannelHandlerContext 82\n6.3.2 ChannelHandler 和ChannelHandlerContext 的高级用法 84\n6.4 异常处理 86\n6.4.1 处理入站异常 86\n6.4.2 处理出站异常 87\n6.5 小结 88\n第7 章 EventLoop 和线程模型 89\n7.1 线程模型概述 89\n7.2 EventLoop 接口 90\n7.2.1 Netty 4 中的I/O 和事件处理 92\n7.2.2 Netty 3 中的I/O 操作 92\n7.3 任务调度 93\n7.3.1 JDK 的任务调度API 93\n7.3.2 使用EventLoop调度任务 94\n7.4 实现细节 95\n7.4.1 线程管理 95\n7.4.2 EventLoop/线程的分配 96\n7.5 小结 98\n第8 章 引导 99\n8.1 Bootstrap 类 99\n8.2 引导客户端和无连接协议 101\n8.2.1 引导客户端 102\n8.2.2 Channel 和EventLoopGroup 的兼容性 103\n8.3 引导服务器 104\n8.3.1 ServerBootstrap 类 104\n8.3.2 引导服务器 105\n8.4 从Channel引导客户端 107\n8.5 在引导过程中添加多个ChannelHandler 108\n8.6 使用Netty 的ChannelOption 和属性 110\n8.7 引导DatagramChannel 111\n8.8 关闭 112\n8.9 小结 112\n第9 章 单元测试 113\n9.1 EmbeddedChannel概述 113\n9.2 使用EmbeddedChannel测试ChannelHandler 115\n9.2.1 测试入站消息 115\n9.2.2 测试出站消息 118\n9.3 测试异常处理 119\n9.4 小结 121\n第二部分 编解码器\n第10 章 编解码器框架 125\n10.1 什么是编解码器 125\n10.2 解码器 125\n10.2.1 抽象类ByteToMessageDecoder 126\n10.2.2 抽象类ReplayingDecoder 127\n10.2.3 抽象类MessageToMessageDecoder 128\n10.2.4 TooLongFrameException 类 130\n10.3 编码器 131\n10.3.1 抽象类MessageToByteEncoder 131\n10.3.2 抽象类MessageToMessageEncoder 132\n10.4 抽象的编解码器类 133\n10.4.1 抽象类ByteToMessageCodec 133\n10.4.2 抽象类MessageToMessageCodec 134\n10.4.3 CombinedChannelDuplexHandler 类 137\n10.5 小结 138\n第11 章 预置的ChannelHandler和编解码器 139\n11.1 通过SSL/TLS 保护Netty 应用程序 139\n11.2 构建基于Netty 的HTTP/HTTPS 应用程序 141\n11.2.1 HTTP 解码器、编码器和编解码器 141\n11.2.2 聚合HTTP 消息 143\n11.2.3 HTTP 压缩 144\n11.2.4 使用HTTPS 145\n11.2.5 WebSocket 146\n11.3 空闲的连接和超时 148\n11.4 解码基于分隔符的协议和基于长度的协议 150\n11.4.1 基于分隔符的协议 150\n11.4.2 基于长度的协议 153\n11.5 写大型数据 155\n11.6 序列化数据 1 57\n11.6.1 JDK 序列化 157\n11.6.2 使用JBoss Marshalling进行序列化 157\n11.6.3 通过Protocol Buffers序列化 159\n11.7 小结 160\n第三部分 网络协议\n第12 章 WebSocket 163\n12.1 WebSocket 简介 163\n12.2 我们的WebSocket 示例应用程序 164\n12.3 添加WebSocket支持 165\n12.3.1 处理HTTP 请求 165\n12.3.2 处理WebSocket 帧 168\n12.3.3 初始化ChannelPipeline 169\n12.3.4 引导 171\n12.4 测试该应用程序 173\n12.5 小结 176\n第13章 使用UDP 广播事件 177\n13.1 UDP 的基础知识 177\n13.2 UDP 广播 178\n13.3 UDP 示例应用程序 178\n13.4 消息 POJO:LogEvent 179\n13.5 编写广播者 180\n13.6 编写监视器 185\n13.7 运行LogEventBroadcaster 和LogEventMonitor 187\n13.8 小结 189\n第四部分 案例研究\n第14 章 案例研究，第一部分 193\n14.1 Droplr—构建移动服务 193\n14.1.1 这一切的起因 193\n14.1.2 Droplr 是怎样工作的 194\n14.1.3 创造一个更加快速的上传体验 194\n14.1.4 技术栈 196\n14.1.5 性能 199\n14.1.6 小结——站在巨人的肩膀上 200\n14.2 Firebase—实时的数据同步服务 200\n14.2.1 Firebase 的架构 201\n14.2.2 长轮询 201\n14.2.3 HTTP 1.1 keep-alive和流水线化 204\n14.2.4 控制SslHandler 205\n14.2.5 Firebase 小结 207\n14.3 Urban Airship—构建移动服务 207\n14.3.1 移动消息的基础知识 207\n14.3.2 第三方递交 208\n14.3.3 使用二进制协议的例子 209\n14.3.4 直接面向设备的递交 211\n14.3.5 Netty 擅长管理大量的并发连接 212\n14.3.6 Urban Airship 小结——跨越防火墙边界 213\n14.4 小结 214\n第15 章 案例研究，第二部分 215\n15.1 Netty 在Facebook 的使用：Nifty 和Swift 215\n15.1.1 什么是Thrift 215\n15.1.2 使用Netty 改善Java Thrift 的现状 216\n15.1.3 Nifty 服务器的设计 217\n15.1.4 Nifty 异步客户端的设计 220\n15.1.5 Swift：一种更快的构建Java Thrift 服务的方式 221\n15.1.6 结果 221\n15.1.7 Facebook 小结 224\n15.2 Netty 在Twitter的使用：Finagle 224\n15.2.1 Twitter 成长的烦恼 224\n15.2.2 Finagle 的诞生 224\n15.2.3 Finagle 是如何工作的 225\n15.2.4 Finagle 的抽象 230\n15.2.5 故障管理 231\n15.2.6 组合服务 232\n15.2.7 未来：Netty 232\n15.2.8 Twitter 小结 233\n15.3 小结 233\n附录 Maven 介绍 234","pages":"276","images":{"small":"https://img3.doubanio.com/view/subject/s/public/s29444565.jpg","large":"https://img3.doubanio.com/view/subject/l/public/s29444565.jpg","medium":"https://img3.doubanio.com/view/subject/m/public/s29444565.jpg"},"alt":"https://book.douban.com/subject/27038538/","id":"27038538","publisher":"人民邮电出版社","isbn10":"7115453683","isbn13":"9787115453686","title":"Netty实战","url":"https://api.douban.com/v2/book/27038538","alt_title":"Netty IN ACTION","author_intro":"Norman Maurer，是苹果公司的资深软件工程师，同时也是Netty的核心开发人员。\nMarvin Allen Wolfthal，是Dell Services的顾问，他使用Netty实现了多个任务关键型的企业系统。\n何品，目前是淘宝的一名资深软件工程师，热爱网络、并发、异步相关的主题以及函数式编程，同时也是Netty、Akka等项目的贡献者，活跃于Scala社区，目前也在从事GraphQL相关的开发工作。","summary":"编辑推荐\n\n- Netty之父”Trustin Lee作序推荐\n- 阿里巴巴中间件高级技术专家为本书中文版作序推荐\n- 系统而详细地介绍了Netty的各个方面并附带了即用型的优质示例\n- 附带行业一线公司的案例研究\n- 极实用的Netty技术书\n无论是构建高性能的Web、游戏服务器、推送系统、RPC框架、消息中间件还是分布式大数据处理引擎，都离不开Netty，在整个行业中，Netty广泛而成功的应用，使其成为了Java高性能网络编程的卓绝框架。\nNetty的现Tech Lead Norman在本书中循序渐进地讲解了Netty的各个关键部分，在看完本书后，你不但可以熟练地使用Netty来构建以上系统，并且还可以避免很多常见的陷阱。\n无论是想要学习Spring 5 、Spark、Cassandra等这样的系统，还是通过学习Netty来构建自己的基于Java的高性能网络框架，或者是更加具体的高性能Web或者游戏服务器等，本书都将是你的超强拍档。\n本书中文版基于Netty4.1.9做了修订，希望本书能够给你带来一个接近完美的阅读体验，并能帮到你。\n内容提要\n本书是为想要或者正在使用Java从事高性能网络编程的人而写的，循序渐进地介绍了Netty各个方面的内容。\n本书共分为4个部分：第一部分详细地介绍Netty的相关概念以及核心组件，第二部分介绍自定义协议经常用到的编解码器，第三部分介绍Netty对于应用层高级协议的支持，会覆盖常见的协议及其在实践中的应用，第四部分是几个案例研究。此外，附录部分还会简单地介绍Maven，以及如何通过使用Maven编译和运行本书中的示例。\n阅读本书不需要读者精通Java网络和并发编程。如果想要更加深入地理解本书背后的理念以及Netty源码本身，可以系统地学习一下Java网络编程、NIO、并发和异步编程以及相关的设计模式。\n本文仅用于学习和交流目的，不代表异步社区观点。非商业转载请注明作译者、出处，并保留本文的原始链接。","price":"69.00"},"9787121258015":{"rating":{"max":10,"numRaters":96,"average":"6.7","min":0},"subtitle":"","author":["李林锋"],"pubdate":"2015-4-20","tags":[{"count":105,"name":"netty","title":"netty"},{"count":53,"name":"Java","title":"Java"},{"count":44,"name":"nio","title":"nio"},{"count":34,"name":"网络编程","title":"网络编程"},{"count":19,"name":"java","title":"java"},{"count":12,"name":"编程","title":"编程"},{"count":12,"name":"netty权威指南","title":"netty权威指南"},{"count":10,"name":"网络","title":"网络"}],"origin_title":"李林锋","image":"https://img3.doubanio.com/view/subject/m/public/s28055322.jpg","binding":"平装","translator":[],"catalog":"基础篇走进Java NIO\n第1 章Java 的I/O 演进之路.2\n1.1 I/O 基础入门...............3\n1.1.1 Linux 网络I/O 模型简介.......3\n1.1.2 I/O 多路复用技术.................6\n1.2 Java 的I/O 演进..........8\n1.3 总结............................ 10\n第2 章NIO 入门.................... 11\n2.1 传统的BIO 编程....... 11\n2.1.1 BIO 通信模型图.................. 12\n2.1.2 同步阻塞式I/O 创建的TimeServer 源码分析............. 13\n2.1.3 同步阻塞式I/O 创建的TimeClient 源码分析.......... 16\n2.2 伪异步I/O 编程........ 18\n2.2.1 伪异步I/O 模型图.............. 19\n2.2.2 伪异步I/O 创建的TimeServer 源码分析..... 19\n2.2.3 伪异步I/O 弊端分析........... 21\n2.3 NIO 编程.................... 24\n2.3.1 NIO 类库简介.. 24\n2.3.2 NIO 服务端序列图.............. 28\n2.3.3 NIO 创建的TimeServer 源码分析................ 30\n2.3.4 NIO 客户端序列图.............. 36\n2.3.5 NIO 创建的TimeClient 源码分析................ 39\n2.4 AIO 编程.................... 45\n2.4.1 AIO 创建的TimeServer 源码分析................ 46\n2.4.2 AIO 创建的TimeClient 源码分析................ 51\n2.4.3 AIO 版本时间服务器运行结果.................... 56\n2.5 4 种I/O 的对比......... 58\n2.5.1 概念澄清.......... 58\n2.5.2 不同I/O 模型对比.............. 59\n2.6 选择Netty 的理由..... 60\n2.6.1 不选择Java 原生NIO 编程的原因............... 61\n2.6.2 为什么选择Netty ................ 62\n2.7 总结............................ 63\n入门篇 Netty NIO 开发指南\n第3 章Netty 入门应用.......... 66\n3.1 Netty 开发环境的搭建................ 66\n3.1.1 下载Netty 的软件包........... 67\n3.1.2 搭建Netty 应用工程........... 67\n3.2 Netty 服务端开发...... 68\n3.3 Netty 客户端开发...... 73\n3.4 运行和调试................ 76\n3.4.1 服务端和客户端的运行...... 76\n3.4.2 打包和部署...... 77\n3.5 总结............................ 77\n第4 章TCP 粘包/拆包问题的解决之道...... 79\n4.1 TCP 粘包/拆包.......... 79\n4.1.1 TCP 粘包/拆包问题说明..... 80\n4.1.2 TCP 粘包/拆包发生的原因....... 80\n4.1.3 粘包问题的解决策略.......... 81\n4.2 未考虑TCP 粘包导致功能异常案例................. 82\n4.2.1 TimeServer 的改造.............. 82\n4.2.2 TimeClient 的改造............... 83\n4.2.3 运行结果.......... 84\n4.3 利用LineBasedFrameDecoder 解决TCP 粘包问题................ 85\n4.3.1 支持TCP 粘包的TimeServer ....................... 86\n4.3.2 支持TCP 粘包的TimeClient........................ 88\n4.3.3 运行支持TCP 粘包的时间服务器程序........ 90\n4.3.4 LineBasedFrameDecoder 和StringDecoder 的原理分析........... 91\n4.4 总结............................ 92\n第5 章分隔符和定长解码器的应用...... 93\n5.1 DelimiterBasedFrameDecoder 应用开发............. 94\n5.1.1 DelimiterBasedFrameDecoder 服务端开发.... 94\n5.1.2 DelimiterBasedFrameDecoder 客户端开发.... 97\n5.1.3 运行DelimiterBasedFrameDecoder 服务端和客户端............... 99\n5.2 FixedLengthFrameDecoder 应用开发............... 101\n5.2.1 FixedLengthFrameDecoder 服务端开发...... 101\n5.2.2 利用telnet 命令行测试EchoServer 服务端......103\n5.3 总结.......................... 104\n中级篇 Netty 编解码开发指南\n第6 章编解码技术.............. 106\n6.1 Java 序列化的缺点 ...... 107\n6.1.1 无法跨语言.... 107\n6.1.2 序列化后的码流太大........ 107\n6.1.3 序列化性能太低................ 110\n6.2 业界主流的编解码框架............ 113\n6.2.1 Google 的Protobuf 介绍.... 113\n6.2.2 Facebook 的Thrift 介绍.... 115\n6.2.3 JBoss Marshalling 介绍..... 116\n6.3 总结.......................... 117\n第7 章MessagePack 编解码............... 118\n7.1 MessagePack 介绍... 118\n7.1.1 MessagePack 多语言支持.. 119\n7.1.2 MessagePack Java API 介绍........................ 119\n7.1.3 MessagePack 开发包下载. 120\n7.2 MessagePack 编码器和解码器开发................. 120\n7.2.1 MessagePack 编码器开发....... 120\n7.2.2 MessagePack 解码器开发 ...... 121\n7.2.3 功能测试........ 121\n7.3 粘包/半包支持......... 124\n7.4 总结.......................... 127\n第8 章Google Protobuf 编解码.......... 128\n8.1 Protobuf 的入门....... 129\n8.1.1 Protobuf 开发环境搭建..... 129\n8.1.2 Protobuf 编解码开发......... 131\n8.1.3 运行Protobuf 例程............ 133\n8.2 Netty 的Protobuf 服务端开发.. 133\n8.2.1 Protobuf 版本的图书订购服务端开发........ 134\n8.2.2 Protobuf 版本的图书订购客户端开发........ 136\n8.2.3 Protobuf 版本的图书订购程序功能测试.... 139\n8.3 Protobuf 的使用注意事项......... 140\n8.4 总结.......................... 142\n第9 章JBoss Marshalling 编解码....... 143\n9.1 Marshalling 开发环境准备........ 143\n9.2 Netty 的Marshalling 服务端开发..................... 144\n9.3 Netty 的Marshalling 客户端开发..................... 147\n9.4 运行Marshalling 客户端和服务端例程........... 149\n9.5 总结.......................... 150\n高级篇 Netty 多协议开发和应用\n第10 章HTTP 协议开发应用............... 154\n10.1 HTTP 协议介绍..... 155\n10.1.1 HTTP 协议的URL .......... 155\n10.1.2 HTTP 请求消息（HttpRequest）.............. 155\n10.1.3 HTTP 响应消息（HttpResponse）........... 158\n10.2 Netty HTTP 服务端入门开发....... 159\n10.2.1 HTTP 服务端例程场景描述..................... 160\n10.2.2 HTTP 服务端开发........... 160\n10.2.3 Netty HTTP 文件服务器例程运行结果.... 166\n10.3 Netty HTTP+XML 协议栈开发....................... 170\n10.3.1 开发场景介绍................. 171\n10.3.2 HTTP+XML 协议栈设计.......174\n10.3.3 高效的XML 绑定框架JiBx ..................... 175\n10.3.4 HTTP+XML 编解码框架开发.................. 183\n10.3.5 HTTP+XML 协议栈测试....... 199\n10.3.6 小结............. 201\n10.4 总结........................ 202\n第11 章WebSocket 协议开发............. 203\n11.1 HTTP 协议的弊端....... 204\n11.2 WebSocket 入门..... 204\n11.2.1 WebSocket 背景............... 205\n11.2.2 WebSocket 连接建立....... 206\n11.2.3 WebSocket 生命周期....... 207\n11.2.4 WebSocket 连接关闭....... 208\n11.3 Netty WebSocket 协议开发..... 209\n11.3.1 WebSocket 服务端功能介绍..................... 209\n11.3.2 WebSocket 服务端开发.... 210\n11.3.3 运行WebSocket 服务端... 218\n11.4 总结........................ 219\n第12 章私有协议栈开发.... 221\n12.1 私有协议介绍........ 221\n12.2 Netty 协议栈功能设计............ 223\n12.2.1 网络拓扑图.. 223\n12.2.2 协议栈功能描述.............. 224\n12.2.3 通信模型...... 224\n12.2.4 消息定义...... 225\n12.2.5 Netty 协议支持的字段类型...................... 226\n12.2.6 Netty 协议的编解码规范. 227\n12.2.7 链路的建立.. 229\n12.2.8 链路的关闭.. 230\n12.2.9 可靠性设计.. 230\n12.2.10 安全性设计 232\n12.2.11 可扩展性设计................ 232\n12.3 Netty 协议栈开发.. 233\n12.3.1 数据结构定义................. 233\n12.3.2 消息编解码.. 237\n12.3.3 握手和安全认证.............. 241\n12.3.4 心跳检测机制................. 245\n12.3.5 断连重连...... 248\n12.3.6 客户端代码.. 249\n12.3.7 服务端代码.. 251\n12.4 运行协议栈............ 252\n12.4.1 正常场景...... 252\n12.4.2 异常场景：服务端宕机重启.................... 253\n12.4.3 异常场景：客户端宕机重启.................... 256\n12.5 总结........................ 256\n第13 章服务端创建............ 258\n13.1 原生NIO 类库的复杂性......... 259\n13.2 Netty 服务端创建源码分析.... 259\n13.2.1 Netty 服务端创建时序图. 260\n13.2.2 Netty 服务端创建源码分析...................... 263\n13.3 客户端接入源码分析.............. 272\n13.4 总结........................ 275\n第14 章客户端创建............ 276\n14.1 Netty 客户端创建流程分析.... 276\n14.2.1 Netty 客户端创建时序图. 276\n14.2.2 Netty 客户端创建流程分析...................... 277\n14.2 Netty 客户端创建源码分析.... 278\n14.2.1 客户端连接辅助类Bootstrap.................... 278\n14.2.2 客户端连接操作.............. 281\n14.2.3 异步连接结果通知.......... 283\n14.2.4 客户端连接超时机制...... 284\n14.3 总结........................ 286\n源码分析篇 Netty 功能介绍和源码分析\n第15 章ByteBuf 和相关辅助类........... 288\n15.1 ByteBuf 功能说明. 288\n15.1.1 ByteBuf 的工作原理........ 289\n15.1.2 ByteBuf 的功能介绍........ 294\n15.2 ByteBuf 源码分析. 308\n15.2.1 ByteBuf 的主要类继承关系..................... 309\n15.2.2 AbstractByteBuf 源码分析........................ 310\n15.2.3 AbstractReferenceCountedByteBuf 源码分析.................. 319\n15.2.4 UnpooledHeapByteBuf 源码分析.............. 321\n15.2.5 PooledByteBuf 内存池原理分析............... 326\n15.2.6 PooledDirectByteBuf 源码分析................. 329\n15.3 ByteBuf 相关的辅助类功能介绍.................... 332\n15.3.1 ByteBufHolder................. 332\n15.3.2 ByteBufAllocator ............. 333\n15.3.3 CompositeByteBuf ........... 334\n15.3.4 ByteBufUtil .. 336\n15.4 总结........................ 337\n第16 章Channel 和Unsafe ................. 338\n16.1 Channel 功能说明. 338\n16.1.1 Channel 的工作原理........ 339\n16.1.2 Channel 的功能介绍........ 340\n16.2 Channel 源码分析. 343\n16.2.1 Channel 的主要继承关系类图.................. 343\n16.2.2 AbstractChannel 源码分析........................ 344\n16.2.3 AbstractNioChannel 源码分析.................. 347\n16.2.4 AbstractNioByteChannel 源码分析........... 350\n16.2.5 AbstractNioMessageChannel 源码分析..... 353\n16.2.6 AbstractNioMessageServerChannel 源码分析.............. 354\n16.2.7 NioServerSocketChannel 源码分析........... 355\n16.2.8 NioSocketChannel 源码分析..................... 358\n16.3 Unsafe 功能说明... 364\n16.4 Unsafe 源码分析... 365\n16.4.1 Unsafe 继承关系类图...... 365\n16.4.2 AbstractUnsafe 源码分析. 366\n16.4.3 AbstractNioUnsafe 源码分析.................... 375\n16.4.4 NioByteUnsafe 源码分析. 379\n16.5 总结........................ 387\n第17 章ChannelPipeline 和ChannelHandler........... 388\n17.1 ChannelPipeline 功能说明....... 389\n17.1.1 ChannelPipeline 的事件处理.................... 389\n17.1.2 自定义拦截器................. 391\n17.1.3 构建pipeline 392\n17.1.4 ChannelPipeline 的主要特性.................... 393\n17.2 ChannelPipeline 源码分析....... 393\n17.2.1 ChannelPipeline 的类继承关系图............. 393\n17.2.2 ChannelPipeline 对ChannelHandler 的管理........... 393\n17.2.3 ChannelPipeline 的inbound 事件.............. 396\n17.2.4 ChannelPipeline 的outbound 事件............ 397\n17.3 ChannelHandler 功能说明....... 398\n17.3.1 ChannelHandlerAdapter 功能说明............ 399\n17.3.2 ByteToMessageDecoder 功能说明............ 399\n17.3.3 MessageToMessageDecoder 功能说明...... 400\n17.3.4 LengthFieldBasedFrameDecoder 功能说明............... 400\n17.3.5 MessageToByteEncoder 功能说明............. 404\n17.3.6 MessageToMessageEncoder 功能说明....... 404\n17.3.7 LengthFieldPrepender 功能说明............... 405\n17.4 ChannelHandler 源码分析....... 406\n17.4.1 ChannelHandler 的类继承关系图............. 406\n17.4.2 ByteToMessageDecoder 源码分析............ 407\n17.4.3 MessageToMessageDecoder 源码分析...... 410\n17.4.4 LengthFieldBasedFrameDecoder 源码分析............ 411\n17.4.5 MessageToByteEncoder 源码分析............. 415\n17.4.6 MessageToMessageEncoder 源码分析....... 416\n17.4.7 LengthFieldPrepender 源码分析............... 417\n17.5 总结........................ 418\n第18 章EventLoop 和EventLoopGroup.................... 419\n18.1 Netty 的线程模型.. 419\n18.1.1 Reactor 单线程模型......... 420\n18.1.2 Reactor 多线程模型......... 421\n18.1.3 主从Reactor 多线程模型 422\n18.1.4 Netty 的线程模型............ 423\n18.1.5 最佳实践...... 424\n18.2 NioEventLoop 源码分析......... 425\n18.2.1 NioEventLoop 设计原理.. 425\n18.2.2 NioEventLoop 继承关系类图................... 426\n18.2.3 NioEventLoop.................. 427\n18.3 总结........................ 436\n第19 章Future 和Promise .................. 438\n19.1 Future 功能............ 438\n19.2 ChannelFuture 源码分析......... 443\n19.3 Promise 功能介绍. 445\n19.4 Promise 源码分析. 447\n19.4.1 Promise 继承关系图........ 447\n19.4.2 DefaultPromise ................ 447\n19.5 总结........................ 449\n架构和行业应用篇 Netty 高级特性\n第20 章Netty 架构剖析..... 452\n20.1 Netty 逻辑架构...... 452\n20.1.1 Reactor 通信调度层......... 453\n20.1.2 职责链ChannelPipeline ... 453\n20.1.3 业务逻辑编排层（Service ChannelHandler）........... 454\n20.2 关键架构质量属性.................. 454\n20.2.1 高性能.......... 454\n20.2.2 可靠性.......... 457\n20.2.3 可定制性...... 460\n20.2.4 可扩展性...... 460\n20.3 总结........................ 460\n第21 章Java 多线程编程在Netty 中的应用............. 461\n21.1 Java 内存模型与多线程编程.. 461\n21.1.1 硬件的发展和多任务处理........................ 461\n21.1.2 Java 内存模型................. 462\n21.2 Netty 的并发编程实践............ 464\n21.2.1 对共享的可变数据进行正确的同步......... 464\n21.2.2 正确使用锁.. 465\n21.2.3 volatile 的正确使用......... 467\n21.2.4 CAS 指令和原子类......... 470\n21.2.5 线程安全类的应用.......... 472\n21.2.6 读写锁的应用................. 476\n21.2.7 线程安全性文档说明...... 477\n21.2.8 不要依赖线程优先级...... 478\n21.3 总结........................ 479\n第22 章高性能之道............ 480\n22.1 RPC 调用性能模型分析.......... 480\n22.1.1 传统RPC 调用性能差的三宗罪............... 480\n22.1.2 I/O 通信性能三原则........ 481\n22.2 Netty 高性能之道.. 482\n22.2.1 异步非阻塞通信.............. 482\n22.2.2 高效的Reactor 线程模型 482\n22.2.3 无锁化的串行设计.......... 485\n22.2.4 高效的并发编程.............. 486\n22.2.5 高性能的序列化框架...... 486\n22.2.6 零拷贝.......... 487\n22.2.7 内存池.......... 491\n22.2.8 灵活的TCP 参数配置能力....................... 494\n22.3 主流NIO 框架性能对比......... 495\n22.4 总结........................ 497\n第23 章可靠性.................... 498\n23.1 可靠性需求............ 498\n23.1.1 宕机的代价.. 498\n23.1.2 Netty 可靠性需求............ 499\n23.2 Netty 高可靠性设计................ 500\n23.2.1 网络通信类故障.............. 500\n23.2.2 链路的有效性检测.......... 507\n23.2.3 Reactor 线程的保护......... 510\n23.2.4 内存保护...... 513\n23.2.5 流量整形...... 516\n23.2.6 优雅停机接口................. 519\n23.3 优化建议................ 520\n23.3.1 发送队列容量上限控制... 520\n23.3.2 回推发送失败的消息...... 521\n23.4 总结........................ 521\n第24 章安全性.................... 522\n24.1 严峻的安全形势.... 522\n24.1.1 OpenSSL Heart bleed 漏洞.......... 522\n24.1.2 安全漏洞的代价.............. 523\n24.1.3 Netty 面临的安全风险..... 523\n24.2 Netty SSL 安全特性................. 525\n24.2.1 SSL 单向认证.................. 525\n24.2.2 SSL 双向认证.................. 532\n24.2.3 第三方CA 认证.............. 536\n24.3 Netty SSL 源码分析................. 538\n24.3.1 客户端.......... 538\n24.3.2 服务端.......... 541\n24.3.3 消息读取...... 544\n24.3.4 消息发送...... 545\n24.4 Netty 扩展的安全特性............ 546\n24.4.1 IP 地址黑名单机制.......... 547\n24.4.2 接入认证...... 548\n24.4 总结........................ 550\n第25 章Netty 未来展望..... 551\n25.1 应用范围................ 551\n25.2 技术演进................ 552\n25.3 社区活跃度............ 552\n25.4 Road Map ............... 552\n25.5 总结........................ 553\n附录A Netty 参数配置表.... 554","pages":"572","images":{"small":"https://img3.doubanio.com/view/subject/s/public/s28055322.jpg","large":"https://img3.doubanio.com/view/subject/l/public/s28055322.jpg","medium":"https://img3.doubanio.com/view/subject/m/public/s28055322.jpg"},"alt":"https://book.douban.com/subject/26373138/","id":"26373138","publisher":"电子工业出版社","isbn10":"7121258013","isbn13":"9787121258015","title":"Netty权威指南（第2版）","url":"https://api.douban.com/v2/book/26373138","alt_title":"李林锋","author_intro":"李林锋：Netty中国推广者，现华为技术有限公司平台中间件架构与设计部设计师，公司总裁技术创新奖获得者。长期从事高性能通信软件的架构设计和开发工作，有多年在NIO领域的设计、开发和运维经验，精通NIO编程和Netty、Mina等主流NIO框架。目前负责华为软件公司下一代SOA中间件和PaaS平台的架构设计工作。","summary":"《Netty 权威指南（第2 版）》是异步非阻塞通信领域的经典之作，基于最新版本的Netty 5.0 编写，是国内首本深入介绍Netty 原理和架构的书籍，也是作者多年实战经验的总结和浓缩。内容不仅包含Java NIO入门知识、Netty 的基础功能开发指导、编解码框架定制等，还包括私有协议栈定制和开发、Netty 核心类库源码分析，以及Netty 的架构剖析。\n\n《Netty 权威指南（第2 版）》适合架构师、设计师、软件开发工程师、测试人员以及其他对Java NIO 框架、Netty 感兴趣的相关人士阅读，通过《Netty 权威指南（第2 版）》的学习，读者不仅能够掌握Netty 基础功能的使用和开发，更能够掌握Netty 核心类库的原理和使用约束，从而在实际工作中更好地使用Netty。","price":"89"},"9787115433145":{"rating":{"max":10,"numRaters":194,"average":"7.3","min":0},"subtitle":"","author":["[美]克雷格·沃斯"],"pubdate":"2016-9","tags":[{"count":118,"name":"SpringBoot","title":"SpringBoot"},{"count":116,"name":"Spring","title":"Spring"},{"count":108,"name":"Java","title":"Java"},{"count":37,"name":"计算机","title":"计算机"},{"count":36,"name":"编程","title":"编程"},{"count":29,"name":"微服务","title":"微服务"},{"count":22,"name":"软件开发","title":"软件开发"},{"count":22,"name":"技术","title":"技术"}],"origin_title":"Spring Boot in Action","image":"https://img3.doubanio.com/view/subject/m/public/s28983685.jpg","binding":"平装","translator":["丁雪丰"],"catalog":"第1章　入门　　1\n1.1　Spring风云再起　　1\n1.1.1　重新认识Spring　　2\n1.1.2　Spring Boot精要　　3\n1.1.3　Spring Boot不是什么　　6\n1.2　Spring Boot入门　　6\n1.2.1　安装Spring Boot CLI　　7\n1.2.2　使用Spring Initializr初始化Spring Boot项目　　10\n1.3　小结　　18\n第2章　开发第一个应用程序　　19\n2.1　运用Spring Boot　　19\n2.1.1　查看初始化的Spring Boot新项目　　21\n2.1.2　Spring Boot项目构建过程解析　　24\n2.2　使用起步依赖　　27\n2.2.1　指定基于功能的依赖　　28\n2.2.2　覆盖起步依赖引入的传递依赖　　29\n2.3　使用自动配置　　30\n2.3.1　专注于应用程序功能　　31\n2.3.2　运行应用程序　　36\n2.3.3　刚刚发生了什么　　38\n2.4　小结　　41\n第3章　自定义配置　　42\n3.1　覆盖Spring Boot自动配置　　42\n3.1.1　保护应用程序　　43\n3.1.2　创建自定义的安全配置　　44\n3.1.3　掀开自动配置的神秘面纱　　48\n3.2　通过属性文件外置配置　　49\n3.2.1　自动配置微调　　50\n3.2.2　应用程序Bean的配置外置　　55\n3.2.3　使用Profile进行配置　　59\n3.3　定制应用程序错误页面　　62\n3.4　小结　　64\n第4章　测试　　66\n4.1　集成测试自动配置　　66\n4.2　测试Web应用程序　　68\n4.2.1　模拟Spring MVC　　69\n4.2.2　测试Web安全　　72\n4.3　测试运行中的应用程序　　74\n4.3.1　用随机端口启动服务器　　75\n4.3.2　使用Selenium测试HTML页面　　76\n4.4　小结　　78\n第5章　Groovy与Spring Boot CLI　　80\n5.1　开发Spring Boot CLI应用程序　　80\n5.1.1　设置CLI项目　　81\n5.1.2　通过Groovy消除代码噪声　　81\n5.1.3　发生了什么　　85\n5.2　获取依赖　　86\n5.2.1　覆盖默认依赖版本　　87\n5.2.2　添加依赖仓库　　88\n5.3　用CLI运行测试　　89\n5.4　创建可部署的产物　　91\n5.5　小结　　91\n第6章　在Spring Boot中使用Grails　　93\n6.1　使用GORM进行数据持久化　　93\n6.2　使用Groovy Server Pages定义视图　　98\n6.3　结合Spring Boot与Grails 3　　100\n6.3.1　创建新的Grails项目　　100\n6.3.2　定义领域模型　　103\n6.3.3　开发Grails控制器　　104\n6.3.4　创建视图　　105\n6.4　小结　　107\n第7章　深入Actuator　　108\n7.1　揭秘Actuator的端点　　108\n7.1.1　查看配置明细　　109\n7.1.2　运行时度量　　115\n7.1.3　关闭应用程序　　121\n7.1.4　获取应用信息　　121\n7.2　连接Actuator的远程shell　　122\n7.2.1　查看autoconfig报告　　123\n7.2.2　列出应用程序的Bean　　124\n7.2.3　查看应用程序的度量信息　　124\n7.2.4　调用Actuator端点　　125\n7.3　通过JMX监控应用程序　　126\n7.4　定制Actuator　　128\n7.4.1　修改端点ID　　128\n7.4.2　启用和禁用端点　　129\n7.4.3　添加自定义度量信息　　129\n7.4.4　创建自定义跟踪仓库　　132\n7.4.5　插入自定义健康指示器　　134\n7.5　保护Actuator端点　　136\n7.6　小结　　138\n第8章　部署Spring Boot应用程序　　139\n8.1　衡量多种部署方式　　139\n8.2　部署到应用服务器　　140\n8.2.1　构建WAR文件　　141\n8.2.2　创建生产Profile　　142\n8.2.3　开启数据库迁移　　145\n8.3　推上云端　　150\n8.3.1　部署到Cloud Foundry　　150\n8.3.2　部署到Heroku　　153\n8.4　小结　　155\n附录A　Spring Boot开发者工具　　157\n附录B　Spring Boot起步依赖　　163\n附录C　配置属性　　169\n附录D　Spring Boot依赖　　202","pages":"209","images":{"small":"https://img3.doubanio.com/view/subject/s/public/s28983685.jpg","large":"https://img3.doubanio.com/view/subject/l/public/s28983685.jpg","medium":"https://img3.doubanio.com/view/subject/m/public/s28983685.jpg"},"alt":"https://book.douban.com/subject/26857423/","id":"26857423","publisher":"人民邮电出版社","isbn10":"7115433143","isbn13":"9787115433145","title":"Spring Boot实战","url":"https://api.douban.com/v2/book/26857423","alt_title":"Spring Boot in Action","author_intro":"Craig Walls\nPivotal高级工程师，Spring Social及Spring Sync项目领导者，著名技术博主，畅销书《Spring实战》作者。他致力于推广Spring框架，笔耕不辍，亦时常作为演讲嘉宾出席各类相关会议。\n译者简介：\n丁雪丰　 资深开发及运维工程师，活跃的技术图书译者，致力于推动优秀技术在国内的发展，出版了《Spring攻略》《MongoDB实战》《RESTful Web Service Cookbook中文版》等6部译著。","summary":"本书以Spring应用程序开发为中心，全面讲解如何运用Spring Boot提高效率，使应用程序的开发和管理更加轻松有趣。作者行文亲切流畅，以大量示例讲解了Spring Boot在各类情境中的应用，内容涵盖起步依赖、Spring Boot CLI、Groovy、Grails、Actuator。对于Spring Boot开发应用中较为繁琐的内容，附录奉上整理完毕的表格，一目了然，方便读者查阅。","price":"59.00元"},"9787121313011":{"rating":{"max":10,"numRaters":130,"average":"7.9","min":0},"subtitle":"","author":["翟永超"],"pubdate":"2017-5","tags":[{"count":117,"name":"微服务","title":"微服务"},{"count":90,"name":"SpringCloud","title":"SpringCloud"},{"count":81,"name":"Spring","title":"Spring"},{"count":61,"name":"Java","title":"Java"},{"count":41,"name":"架构","title":"架构"},{"count":37,"name":"计算机","title":"计算机"},{"count":32,"name":"Cloud","title":"Cloud"},{"count":23,"name":"编程","title":"编程"}],"origin_title":"","image":"https://img3.doubanio.com/view/subject/m/public/s29434190.jpg","binding":"平装","translator":[],"catalog":"第1章　基础知识\t1\n什么是微服务架构\t1\n-- 与单体系统的区别\t1\n-- 如何实施微服务\t2\n为什么选择Spring Cloud\t6\nSpring Cloud简介\t7\n版本说明\t8\n第2章　微服务构建：Spring Boot\t11\n框架简介\t12\n快速入门\t13\n-- 项目构建与解析\t13\n-- 实现RESTful API\t17\n配置详解\t20\n-- 配置文件\t20\n-- 自定义参数\t22\n-- 参数引用\t22\n-- 使用随机数\t23\n-- 命令行参数\t23\n-- 多环境配置\t24\n-- 加载顺序\t25\n监控与管理\t26\n-- 初识actuator\t27\n-- 原生端点\t28\n小结\t38\n第3章　服务治理：Spring Cloud Eureka\t39\n服务治理\t39\n-- Netflix Eureka\t40\n--搭建服务注册中心\t41\n--注册服务提供者\t43\n--高可用注册中心\t46\n--服务发现与消费\t48\nEureka详解\t51\n--基础架构\t52\n--服务治理机制\t52\n--源码分析\t56\n配置详解\t65\n--服务注册类配置\t65\n--服务实例类配置\t67\n跨平台支持\t71\n第4章　客户端负载均衡：Spring Cloud Ribbon\t73\n客户端负载均衡\t73\nRestTemplate详解\t75\n-- GET请求\t75\n-- POST请求\t77\n-- PUT请求\t79\n-- DELETE请求\t79\n源码分析\t80\n-- 负载均衡器\t91\n-- 负载均衡策略\t109\n配置详解\t123\n--自动化配置\t124\n-- Camden版本对RibbonClient配置的优化\t125\n-- 参数配置\t127\n-- 与Eureka结合\t127\n重试机制\t128\n第5章　服务容错保护：Spring Cloud Hystrix\t130\n快速入门\t131\n原理分析\t135\n-- 工作流程\t135\n-- 断路器原理\t144\n-- 依赖隔离\t148\n使用详解\t151\n-- 创建请求命令\t151\n-- 定义服务降级\t154\n-- 异常处理\t157\n-- 命令名称、分组以及线程池划分\t158\n-- 请求缓存\t159\n-- 请求合并\t166\n属性详解\t172\n-- Command属性\t174\n-- collapser属性\t184\n-- threadPool属性\t185\nHystrix仪表盘\t187\nTurbine集群监控\t192\n-- 构建监控聚合服务\t192\n-- 与消息代理结合\t196\n第6章　声明式服务调用：Spring Cloud Feign\t199\n快速入门\t200\n参数绑定\t202\n继承特性\t205\nRibbon配置\t209\n全局配置\t209\n指定服务配置\t209\n重试机制\t210\nHystrix配置\t211\n全局配置\t211\n禁用Hystrix\t211\n指定命令配置\t212\n服务降级配置\t212\n其他配置\t214\n第7章　API网关服务：Spring Cloud Zuul\t217\n快速入门\t219\n-- 构建网关\t220\n-- 请求路由\t221\n-- 请求过滤\t223\n路由详解\t226\n-- 传统路由配置\t226\n-- 服务路由配置\t228\n-- 服务路由的默认规则\t229\n-- 自定义路由映射规则\t229\n-- 路径匹配\t230\n-- 路由前缀\t233\n-- 本地跳转\t234\n--  Cookie与头信息\t235\n-- Hystrix和Ribbon支持\t236\n过滤器详解\t238\n-- 过滤器\t238\n-- 请求生命周期\t239\n-- 核心过滤器\t240\n-- 异常处理\t244\n-- 禁用过滤器\t256\n动态加载\t257\n-- 动态路由\t257\n-- 动态过滤器\t261\n第8章　分布式配置中心：Spring Cloud Config\t267\n快速入门\t267\n-- 构建配置中心\t268\n-- 配置规则详解\t269\n-- 客户端配置映射\t272\n服务端详解\t274\n-- 基础架构\t274\n-- Git配置仓库\t276\n-- SVN配置仓库\t279\n-- 本地仓库\t279\n-- 本地文件系统\t279\n-- 健康监测\t280\n-- 属性覆盖\t281\n-- 安全保护\t281\n-- 加密解密\t282\n-- 高可用配置\t286\n客户端详解\t286\n--  URI指定配置中心\t287\n-- 服务化配置中心\t287\n-- 失败快速响应与重试\t290\n-- 获取远程配置\t292\n-- 动态刷新配置\t293\n第9章　消息总线：Spring Cloud Bus\t295\n消息代理\t295\nRabbitMQ实现消息总线\t296\n-- 基本概念\t297\n-- 安装与使用\t298\n-- 快速入门\t302\n-- 整合Spring Cloud Bus\t306\n-- 原理分析\t307\n-- 指定刷新范围\t308\n-- 架构优化\t309\n-- RabbitMQ配置\t310\nKafka实现消息总线\t312\n-- Kafka简介\t312\n-- 快速入门\t313\n--整合Spring Cloud Bus\t315\n-- Kafka配置\t318\n深入理解\t318\n-- 源码分析\t320\n-- 其他消息代理的支持\t342\n第10章　消息驱动的微服务：Spring Cloud Stream\t344\n快速入门\t344\n核心概念\t349\n-- 绑定器\t350\n-- 发布-订阅模式\t351\n-- 消费组\t353\n-- 消息分区\t354\n使用详解\t355\n-- 开启绑定功能\t355\n-- 绑定消息通道\t356\n-- 消息生产与消费\t360\n-- 响应式编程\t366\n-- 消费组与消息分区\t368\n-- 消息类型\t370\n绑定器详解\t373\n-- 绑定器SPI\t373\n-- 自动化配置\t374\n-- 多绑定器配置\t374\n--  RabbitMQ与Kafka绑定器\t376\n配置详解\t376\n-- 基础配置\t377\n-- 绑定通道配置\t377\n-- 绑定器配置\t379\n第11章　分布式服务跟踪：Spring Cloud Sleuth\t386\n快速入门\t386\n-- 准备工作\t386\n-- 实现跟踪\t389\n跟踪原理\t390\n抽样收集\t392\n与Logstash整合\t394\n与Zipkin整合\t397\n--  HTTP收集\t398\n-- 消息中间件收集\t402\n-- 收集原理\t404\n-- 数据存储\t414\n--  API接口\t417\n附录A　Starter POMs\t419\n后记\t421","pages":"440","images":{"small":"https://img3.doubanio.com/view/subject/s/public/s29434190.jpg","large":"https://img3.doubanio.com/view/subject/l/public/s29434190.jpg","medium":"https://img3.doubanio.com/view/subject/m/public/s29434190.jpg"},"alt":"https://book.douban.com/subject/27025912/","id":"27025912","publisher":"电子工业出版社","isbn10":"7121313014","isbn13":"9787121313011","title":"Spring Cloud微服务实战","url":"https://api.douban.com/v2/book/27025912","alt_title":"","author_intro":"","summary":"《Spring Cloud微服务实战》从时下流行的微服务架构概念出发，详细介绍了Spring Cloud针对微服务架构中几大核心要素的解决方案和基础组件。对于各个组件的介绍，《Spring Cloud微服务实战》主要以示例与源码结合的方式来帮助读者更好地理解这些组件的使用方法以及运行原理。同时，在介绍的过程中，还包含了作者在实践中所遇到的一些问题和解决思路，可供读者在实践中作为参考。\n《Spring Cloud微服务实战》适合所有Java开发人员，尤其适合正在做微服务架构技术选型或正在实施微服务架构的团队查阅和参考。","price":"89"},"9787115209429":{"rating":{"max":10,"numRaters":234,"average":"9.1","min":0},"subtitle":"","author":["王福强"],"pubdate":"2009.8","tags":[{"count":491,"name":"Spring","title":"Spring"},{"count":297,"name":"Java","title":"Java"},{"count":166,"name":"框架","title":"框架"},{"count":100,"name":"Web开发","title":"Web开发"},{"count":88,"name":"J2EE","title":"J2EE"},{"count":80,"name":"编程","title":"编程"},{"count":76,"name":"计算机","title":"计算机"},{"count":60,"name":"Framework","title":"Framework"}],"origin_title":"","image":"https://img1.doubanio.com/view/subject/m/public/s3949449.jpg","binding":"平装","translator":[],"catalog":"第一部分 掀起Spring的盖头来\n第1章 Spring框架的由来 2\n1.1 Spring之崛起 2\n1.2 Spring框架概述 3\n1.3 Spring大观园 5\n1.4 小结 8\n第二部分 Spring的IoC容器\n第2章 IoC的基本概念 10\n2.1 我们的理念是：让别人为你服务 10\n2.2 手语，呼喊，还是心有灵犀 13\n2.2.1 构造方法注入 13\n2.2.2 setter方法注入 13\n2.2.3 接口注入 14\n2.2.4 三种注入方式的比较 15\n2.3 IoC的附加值 15\n2.4 小结 17\n第3章 掌管大局的IoC Service Provider 18\n3.1 IoC Service Provider的职责 18\n3.2 运筹帷幄的秘密——IoC Service Provider如何管理对象间的依赖关系 19\n3.2.1 直接编码方式 19\n3.2.2 配置文件方式 20\n3.2.3 元数据方式 21\n3.3 小结 21\n第4章 Spring的IoC容器之BeanFactory 22\n4.1 拥有BeanFactory之后的生活 24\n4.2 BeanFactory的对象注册与依赖绑定方式 26\n4.2.1 直接编码方式 26\n4.2.2 外部配置文件方式 28\n4.2.3 注解方式 31\n4.3 BeanFactory的XML之旅 33\n4.3.1 beans和bean 33\n4.3.2 孤孤单单一个人 35\n4.3.3 Help Me， Help You 36\n4.3.4 继承？我也会！ 50\n4.3.5 bean的scope 51\n4.3.6 工厂方法与FactoryBean 56\n4.3.7 偷梁换柱之术 61\n4.4 容器背后的秘密 66\n4.4.1 “战略性观望” 66\n4.4.2 插手“容器的启动” 67\n4.4.3 了解bean的一生 74\n4.5 小结 85\n第5章 Spring IoC容器ApplicationContext 86\n5.1 统一资源加载策略 86\n5.1.1 Spring中的Resource 87\n5.1.2 ResourceLoader，“更广义的URL” 88\n5.1.3 ApplicationContext与ResourceLoader 91\n5.2 国际化信息支持(I18n MessageSource) 97\n5.2.1 Java SE提供的国际化支持 97\n5.2.2 MessageSource与ApplicationContext 98\n5.3 容器内部事件发布 102\n5.3.1 自定义事件发布 102\n5.3.2 Spring的容器内事件发布类结构分析 105\n5.3.3 Spring容器内事件发布的应用 107\n5.4 多配置模块加载的简化 109\n5.5 小结 110\n第6章 Spring IoC容器之扩展篇 111\n6.1 Spring 2.5的基于注解的依赖注入 111\n6.1.1 注解版的自动绑定(@Autowired) 111\n6.1.2 @Autowired之外的选择——使用JSR250标注依赖注入关系 115\n6.1.3 将革命进行得更彻底一些(class-path-scanning功能介绍) 116\n6.2 Spring 3.0展望 119\n6.3 小结 120\n第三部分 Spring AOP框架\n第7章 一起来看AOP 122\n7.1 AOP的尴尬 124\n7.2 AOP走向现实 125\n7.2.1 静态AOP时代 125\n7.2.2 动态AOP时代 126\n7.3 Java平台上的AOP实现机制 126\n7.3.1 动态代理 126\n7.3.2 动态字节码增强 126\n7.3.3 Java代码生成 127\n7.3.4 自定义类加载器 127\n7.3.5 AOL扩展 127\n7.4 AOP国家的公民 128\n7.4.1 Joinpoint 128\n7.4.2 Pointcut 130\n7.4.3 Advice 131\n7.4.4 Aspect 133\n7.4.5 织入和织入器 133\n7.4.6 目标对象 133\n7.5 小结 134\n第8章 Spring AOP概述及其实现机制 135\n8.1 Spring AOP概述 135\n8.2 Spring AOP的实现机制 136\n8.2.1 设计模式之代理模式 136\n8.2.2 动态代理 139\n8.2.3 动态字节码生成 141\n8.3 小结 142\n第9章 Spring AOP一世 143\n9.1 Spring AOP中的Joinpoint 143\n9.2 Spring AOP中的Pointcut 144\n9.2.1 常见的Pointcut 146\n9.2.2 扩展Pointcut(Customize Pointcut) 151\n9.2.3 IoC容器中的Pointcut 152\n9.3 Spring AOP中的Advice 153\n9.3.1 per-class类型的Advice 153\n9.3.2 per-instance类型的Advice 159\n9.4 Spring AOP中的Aspect 163\n9.4.1 PointcutAdvisor家族 164\n9.4.2 IntroductionAdvisor分支 167\n9.4.3 Ordered的作用 168\n9.5 Spring AOP的织入 170\n9.5.1 如何与ProxyFactory打交道 170\n9.5.2 看清ProxyFactory的本质 175\n9.5.3 容器中的织入器——ProxyFactoryBean 179\n9.5.4 加快织入的自动化进程 185\n9.6 TargetSource 190\n9.6.1 可用的TargetSource实现类 191\n9.6.2 自定义TargetSource 195\n9.7 小结 197\n第10章 Spring AOP二世 198\n10.1 @AspectJ形式的Spring AOP 198\n10.1.1 @AspectJ形式AOP使用之先睹为快 199\n10.1.2 @AspectJ形式的Pointcut 201\n10.1.3 @AspectJ形式的Advice 211\n10.1.4 @AspectJ中的Aspect更多话题 220\n10.2 基于Schema的AOP 223\n10.2.1 基于Schema的AOP配置概览 223\n10.2.2 向基于Schema的AOP迁移 225\n10.2.3 @AspectJ到“基于Schema的AOP”迁移 227\n10.3 小结 235\n第11章 AOP应用案例 237\n11.1 异常处理 237\n11.1.1 Java异常处理 237\n11.1.2 Fault Barrier 238\n11.2 安全检查 239\n11.3 缓存 240\n11.4 小结 240\n第12章 Spring AOP之扩展篇 241\n12.1 有关公开当前调用的代理对象的探讨 241\n12.1.1 问题的现象 241\n12.1.2 原因的分析 242\n12.1.3 解决方案 243\n12.2 小结 245\n第四部分 使用Spring访问数据\n第13章 统一的数据访问异常层次体系 249\n13.1 DAO模式的背景 249\n13.2 梦想照进现实 251\n13.3 发现问题，解决问题 252\n13.4 不重新发明轮子 254\n13.5 小结 257\n第14章 JDBC API的最佳实践 258\n14.1 基于Template的JDBC使用方式 258\n14.1.1 JDBC的尴尬 258\n14.1.2 JdbcTemplate的诞生 261\n14.1.3 JdbcTemplate和它的兄弟们 274\n14.1.4 Spring中的DataSource 296\n14.1.5 JdbcDaoSupport 301\n14.2 基于操作对象的JDBC使用方式 302\n14.2.1 基于操作对象的查询 303\n14.2.2 基于操作对象的更新 310\n14.2.3 基于操作对象的存储过程调用 313\n14.3 小结 316\n第15章 Spring对各种ORM的集成 317\n15.1 Spring对Hibernate的集成 318\n15.1.1 旧日“冬眠”时光 318\n15.1.2 “春天”里的“冬眠” 321\n15.2 Spring对iBATIS的集成 329\n15.2.1 iBATIS实践之“前生”篇 329\n15.2.2 iBATIS实践之“今世”篇 331\n15.3 Spring中对其他ORM方案的集成概述 337\n15.3.1 Spring对JDO的集成 337\n15.3.2 Spring对TopLink的集成 340\n15.3.3 Spring对JPA的集成 341\n15.4 小结 344\n第16章 Spring数据访问之扩展篇 345\n16.1 活用模板方法模式及Callback 345\n16.1.1 FTPClientTemplate 345\n16.1.2 HttpClientTemplate 349\n16.2 数据访问中的多数据源 350\n16.2.1 “主权独立”的多数据源 350\n16.2.2 “合纵连横”的多数据源 352\n16.2.3 结束语 354\n16.3 Spring 3.0展望 356\n16.4 小结 356\n第五部分 事务管理\n第17章 有关事务的楔子 358\n17.1 认识事务本身 358\n17.2 初识事务家族成员 360\n17.3 小结 362\n第18章 群雄逐鹿下的Java事务管理 363\n18.1 Java平台的局部事务支持 363\n18.2 Java平台的分布式事务支持 365\n18.2.1 基于JTA的分布式事务管理 366\n18.2.2 基于JCA的分布式事务管理 367\n18.3 继续前行之前的反思 367\n18.4 小结 369\n第19章 Spring事务王国的架构 370\n19.1 统一中原的过程 371\n19.2 和平年代 376\n19.2.1 TransactionDefinition 376\n19.2.2 TransactionStatus 382\n19.2.3 PlatformTransac-tionManager 382\n19.3 小结 392\n第20章 使用Spring进行事务管理 393\n20.1 编程式事务管理 393\n20.1.1 直接使用PlatformTran-sactionManager进行编程式事务管理 393\n20.1.2 使用TransactionTemp-late进行编程式事务管理 394\n20.1.3 编程创建基于Savepoint的嵌套事务 396\n20.2 声明式事务管理 397\n20.2.1 引子 397\n20.2.2 XML元数据驱动的声明式事务 399\n20.2.3 注解元数据驱动的声明式事务 410\n20.3 小结 413\n第21章 Spring事务管理之扩展篇 414\n21.1 理解并活用ThreadLocal 414\n21.1.1 理解ThreadLocal的存在背景 414\n21.1.2 理解ThreadLocal的实现 415\n21.1.3 ThreadLocal的应用场景 416\n21.1.4 使用ThreadLocal管理多数据源切换的条件 417\n21.2 谈Strategy模式在开发过程中的应用 420\n21.3 Spring与JTA背后的奥秘 423\n21.4 小结 427\n第六部分 Spring的Web MVC框架\n第22章 迈向Spring MVC的旅程 430\n22.1 Servlet独行天下的时代 430\n22.2 繁盛一时的JSP时代 433\n22.3 Servlet与JSP的联盟 436\n22.4 数英雄人物，还看今朝 438\n22.5 小结 440\n第23章 Spring MVC初体验 441\n23.1 鸟瞰Spring MVC 442\n23.2 实践出真知 446\n23.2.1 Spring MVC应用的物理结构 447\n23.2.2 按部就班地开始工作 451\n23.3 小结 459\n第24章 近距离接触Spring MVC主要角色 460\n24.1 忙碌的协调人HandlerMapping 460\n24.1.1 可用的HandlerMapping 461\n24.1.2 HandlerMapping执行序列(Chain Of HandlerMapping) 463\n24.2 我们的亲密伙伴Controller 464\n24.2.1 AbstractController 465\n24.2.2 MultiActionController 468\n24.2.3 SimpleFormController 476\n24.2.4 AbstractWizard-FormController 496\n24.2.5 其他可用的Controller实现 503\n24.3 ModelAndView 505\n24.3.1 ModelAndView中的视图信息 505\n24.3.2 ModelAndView中的模型数据 506\n24.4 视图定位器ViewResolver 506\n24.4.1 可用的ViewResolver实现类 507\n24.4.2 ViewResolver查找序列(Chain Of ViewResolver) 511\n24.5 各司其职的View 511\n24.5.1 View实现原理回顾 512\n24.5.2 可用的View实现类 515\n24.5.3 自定义View实现 521\n24.6 小结 523\n第25章 认识更多Spring MVC家族成员 524\n25.1 文件上传与MultipartResolver 525\n25.1.1 使用MultipartResolver进行文件上传的简单分析 526\n25.1.2 文件上传实践 527\n25.2 Handler与HandlerAdaptor 530\n25.2.1 问题的起源 530\n25.2.2 深入了解Handler 531\n25.2.3 近看HandlerAdaptor的奥秘 533\n25.2.4 告知Handler与Handler-Adaptor的存在 535\n25.3 框架内处理流程拦截与Handler-Interceptor 536\n25.3.1 可用的Handler-Interceptor实现 537\n25.3.2 自定义实现Handler-Interceptor 538\n25.3.3 HandlerInterceptor寻根 540\n25.3.4 HandlerInterceptor之外的选择 541\n25.4 框架内的异常处理与Handler-ExceptionResolver 544\n25.5 国际化视图与LocalResolver 548\n25.5.1 可用的LocaleResolver 549\n25.5.2 LocaleResolver的足迹 550\n25.5.3 Locale的变更与LocaleChangeHandler 551\n25.6 主题(Theme)与ThemeResolver 552\n25.6.1 提供主题资源的ThemeSource 552\n25.6.2 管理主题的ThemeResolver 554\n25.6.3 切换主题的ThemeChange-Interceptor 555\n25.7 小结 556\n第26章 Spring MVC中基于注解的Controller 557\n26.1 初识基于注解的Controller 557\n26.2 基于注解的Controller原型分析 558\n26.2.1 自定义用于基于注解的Contro-ller的HandlerMapping 558\n26.2.2 自定义用于基于注解的Contro-ller的HandlerAdaptor 560\n26.3 近看基于注解的Controller 563\n26.3.1 声明基于注解的Controller 563\n26.3.2 请求参数到方法参数的绑定 569\n26.3.3 使用@ModelAttribute访问模型数据 572\n26.3.4 通过@SessionAttribute管理Session数据 574\n26.4 小结 576\n第27章 Spring MVC之扩展篇 577\n27.1 Spring MVC也Convention Over Configuration 577\n27.1.1 Convention Over Configuration简介 577\n27.1.2 Spring MVC中的Convention Over Configuration 578\n27.2 Spring 3.0展望 581\n27.3 小结 582\n第七部分 Spring框架对J2EE服务的集成和支持\n第28章 Spring框架内的JNDI支持 584\n28.1 JNDI简单回顾 584\n28.2 Spring框架内JNDI访问的基石——JndiTemplate 585\n28.3 JNDI对象的依赖注入——JndiObjectFactoryBean 587\n28.4 小结 588\n第29章 Spring框架对JMS的集成 589\n29.1 说说JMS的身世 589\n29.2 使用JMS API进行应用开发的传统套路 590\n29.3 Spring改进后的JMS实战格斗术 592\n29.3.1 消息发送和同步接收 592\n29.3.2 异步消息接收 601\n29.3.3 JMS相关异常处理 607\n29.3.4 框架内的事务管理支持 608\n29.4 小结 609\n第30章 使用Spring发送E-mail 610\n30.1 思甜前，先忆苦 610\n30.2 Spring的E-mail抽象层分析 612\n30.2.1 直接创建邮件消息并发送 614\n30.2.2 使用MimeMessage-Preparator发送邮件 615\n30.3 Spring的E-mail支持在实际开发中的应用 616\n30.4 小结 622\n第31章 Spring中的任务调度和线程池支持 623\n31.1 Spring与Quartz 623\n31.1.1 初识Quartz 623\n31.1.2 融入Spring大家庭的Quartz 626\n31.2 Spring对JDK Timer的集成 631\n31.2.1 JDK Timer小记 631\n31.2.2 Spring集成后的JDK Timer 632\n31.3 Executor的孪生兄弟TaskExecutor 634\n31.3.1 可用的TaskExecutor 635\n31.3.2 TaskExecutor使用实例 637\n31.4 小结 639\n第32章 Spring框架对J2EE服务的集成之扩展篇 640\n32.1 MailMonitor的延伸 640\n32.2 Spring 3.0展望 642\n32.3 小结 642\n第33章 Spring远程方案 643\n33.1 从“对面交谈”到“千里传声” 643\n33.2 Spring Remoting架构分析 645\n33.2.1 Spring Remoting之远程访问异常体系 645\n33.2.2 统一风格的远程服务公开与访问方式 646\n33.3 Spring Remoting提供的远程服务支持 648\n33.3.1 基于RMI的Remoting方案 648\n33.3.2 基于HTTP的轻量级Remoting方案 651\n33.3.3 基于Web服务的远程方案 655\n33.3.4 基于JMS的远程方案 658\n33.4 扩展Spring Remoting 660\n33.5 Spring Remoting之扩展篇 663\n33.5.1 拉开JMX演出的序幕 663\n33.5.2 Spring 3.0展望 664\n参考文献 665","pages":"680","images":{"small":"https://img1.doubanio.com/view/subject/s/public/s3949449.jpg","large":"https://img1.doubanio.com/view/subject/l/public/s3949449.jpg","medium":"https://img1.doubanio.com/view/subject/m/public/s3949449.jpg"},"alt":"https://book.douban.com/subject/3897837/","id":"3897837","publisher":"人民邮电出版社","isbn10":"7115209421","isbn13":"9787115209429","title":"Spring揭秘","url":"https://api.douban.com/v2/book/3897837","alt_title":"","author_intro":"王福强，资深软件开发专家和系统架构师，原任花旗软件（大连）资深软件工程师，现任阿里巴巴B2B平台技术部架构师。多年来一直专注于Java平台的技术发展，以及一线产品的技术选型和框架设计。拥有多年金融行业软件开发经历，负责过信贷、外汇交易、固定收益等金融系统的分析、设计、开发、维护、集成、扩展和性能调优等，对各种大型金融机构体系的技术架构和实现有丰富经验和独到的见解。作为国内最早使用Spring的开发者之一,他对Spring的使用、设计和实现原理有着非常深入的了解。在本书中，他与读者分享了多年的Spring开发经验和探索企业级解决方案的心得。","summary":"没有教程似的训导，更多的是说故事般的娓娓道来，本书是作者在多年的工作中积累的第一手Spring框架使用经验的总结，深入剖析了Spring框架各个模块的功能、出现的背景、设计理念和设计原理，揭开了Spring框架的神秘面纱，使你“知其然，更知其所以然”。每部分的扩展篇帮助读者活学活用Spring框架的方方面面，同时可以触类旁通，衍生出新的思路和解决方案。\n本书内容全面，论述深刻入理，必将成为每个Java专业开发人员必备的Spring图书。","price":"99.00元"},"9787121273049":{"rating":{"max":10,"numRaters":157,"average":"8.3","min":0},"subtitle":"","author":["葛一鸣","郭超"],"pubdate":"2015-10-1","tags":[{"count":207,"name":"Java","title":"Java"},{"count":175,"name":"并发编程","title":"并发编程"},{"count":105,"name":"并发","title":"并发"},{"count":52,"name":"java","title":"java"},{"count":45,"name":"编程","title":"编程"},{"count":33,"name":"计算机","title":"计算机"},{"count":24,"name":"软件开发","title":"软件开发"},{"count":22,"name":"Java并发实战","title":"Java并发实战"}],"origin_title":"","image":"https://img1.doubanio.com/view/subject/m/public/s29405037.jpg","binding":"平装","translator":[],"catalog":"第1章　走入并行世界\t1\n1.1　何去何从的并行计算 \t1\n1.1.1　忘掉那该死的并行\t2\n1.1.2　可怕的现实：摩尔定律的失效\t4\n1.1.3　柳暗花明：不断地前进\t5\n1.1.4　光明或是黑暗\t6\n1.2　你必须知道的几个概念\t6\n1.2.1　同步（Synchronous）和异步（Asynchronous）\t7\n1.2.2　并发（Concurrency）和并行（Parallelism）\t8\n1.2.3　临界区\t9\n1.2.4　阻塞（Blocking）和非阻塞（Non-Blocking）\t9\n1.2.5　死锁（Deadlock）、饥饿（Starvation）和活锁（Livelock）\t9\n1.3　并发级别\t11\n1.3.1　阻塞（Blocking）\t11\n1.3.2　无饥饿（Starvation-Free）\t11\n1.3.3　无障碍（Obstruction-Free）\t12\n1.3.4　无锁（Lock-Free）\t12\n1.3.5　无等待（Wait-Free）\t13\n1.4　有关并行的两个重要定律\t13\n1.4.1　Amdahl定律\t13\n1.4.2　Gustafson定律\t16\n1.4.3　Amdahl定律和Gustafson定律是否相互矛盾\t16\n1.5　回到Java：JMM\t17\n1.5.1　原子性（Atomicity）\t18\n1.5.2　可见性（Visibility）\t20\n1.5.3　有序性（Ordering）\t22\n1.5.4　哪些指令不能重排：Happen-Before规则\t27\n1.6　参考文献\t27\n第2章　Java并行程序基础\t29\n2.1　有关线程你必须知道的事\t29\n2.2　初始线程：线程的基本操作\t32\n2.2.1　新建线程\t32\n2.2.2　终止线程\t34\n2.2.3　线程中断\t38\n2.2.4　等待（wait）和通知（notify）\t41\n2.2.5　挂起（suspend）和继续执行（resume）线程\t44\n2.2.6　等待线程结束（join）和谦让（yield）\t48\n2.3　volatile与Java内存模型（JMM）\t50\n2.4　分门别类的管理：线程组\t52\n2.5　驻守后台：守护线程（Daemon）\t54\n2.6　先干重要的事：线程优先级\t55\n2.7　线程安全的概念与synchronized\t57\n2.8　程序中的幽灵：隐蔽的错误\t61\n2.8.1　无提示的错误案例\t61\n2.8.2　并发下的ArrayList\t62\n2.8.3　并发下诡异的HashMap\t63\n2.8.4　初学者常见问题：错误的加锁\t66\n2.9　参考文献\t68\n第3章　JDK并发包\t70\n3.1　多线程的团队协作：同步控制\t70\n3.1.1　synchronized的功能扩展：重入锁\t71\n3.1.2　重入锁的好搭档：Condition条件\t80\n3.1.3　允许多个线程同时访问：信号量（Semaphore）\t83\n3.1.4　ReadWriteLock读写锁\t85\n3.1.5　倒计时器：CountDownLatch\t87\n3.1.6　循环栅栏：CyclicBarrier\t89\n3.1.7　线程阻塞工具类：LockSupport\t92\n3.2　线程复用：线程池\t95\n3.2.1　什么是线程池\t96\n3.2.2　不要重复发明轮子：JDK对线程池的支持\t97\n3.2.3　刨根究底：核心线程池的内部实现\t102\n3.2.4　超负载了怎么办：拒绝策略\t106\n3.2.5　自定义线程创建：ThreadFactory\t109\n3.2.6　我的应用我做主：扩展线程池\t110\n3.2.7　合理的选择：优化线程池线程数量\t112\n3.2.8　堆栈去哪里了：在线程池中寻找堆栈\t113\n3.2.9　分而治之：Fork/Join框架\t117\n3.3　不要重复发明轮子：JDK的并发容器\t121\n3.3.1　超好用的工具类：并发集合简介\t121\n3.3.2　线程安全的HashMap\t122\n3.3.3　有关List的线程安全\t123\n3.3.4　高效读写的队列：深度剖析ConcurrentLinkedQueue\t123\n3.3.5　高效读取：不变模式下的CopyOnWriteArrayList\t129\n3.3.6　数据共享通道：BlockingQueue\t130\n3.3.7　随机数据结构：跳表（SkipList）\t134\n3.4　参考资料\t136\n第4章　锁的优化及注意事项\t138\n4.1　有助于提高“锁”性能的几点建议\t139\n4.1.1　减小锁持有时间\t139\n4.1.2　减小锁粒度\t140\n4.1.3　读写分离锁来替换独占锁\t142\n4.1.4　锁分离\t142\n4.1.5　锁粗化\t144\n4.2　Java虚拟机对锁优化所做的努力\t146\n4.2.1　锁偏向\t146\n4.2.2　轻量级锁\t146\n4.2.3　自旋锁\t146\n4.2.4　锁消除\t146\n4.3　人手一支笔：ThreadLocal\t147\n4.3.1　ThreadLocal的简单使用\t148\n4.3.2　ThreadLocal的实现原理\t149\n4.3.3　对性能有何帮助\t155\n4.4　无锁\t157\n4.4.1　与众不同的并发策略：比较交换（CAS）\t158\n4.4.2　无锁的线程安全整数：AtomicInteger\t159\n4.4.3　Java中的指针：Unsafe类\t161\n4.4.4　无锁的对象引用：AtomicReference\t162\n4.4.5　带有时间戳的对象引用：AtomicStampedReference\t165\n4.4.6　数组也能无锁：AtomicIntegerArray\t168\n4.4.7　让普通变量也享受原子操作：AtomicIntegerFieldUpdater\t169\n4.4.8　挑战无锁算法：无锁的Vector实现\t171\n4.4.9　让线程之间互相帮助：细看SynchronousQueue的实现\t176\n4.5　有关死锁的问题\t179\n4.6　参考文献\t183\n第5章　并行模式与算法\t184\n5.1　探讨单例模式\t184\n5.2　不变模式\t187\n5.3　生产者-消费者模式\t190\n5.4　高性能的生产者-消费者：无锁的实现\t194\n5.4.1　无锁的缓存框架：Disruptor\t195\n5.4.2　用Disruptor实现生产者-消费者案例\t196\n5.4.3　提高消费者的响应时间：选择合适的策略\t199\n5.4.4　CPU Cache的优化：解决伪共享问题\t200\n5.5　Future模式\t204\n5.5.1　Future模式的主要角色\t206\n5.5.2　Future模式的简单实现\t207\n5.5.3　JDK中的Future模式\t210\n5.6　并行流水线\t212\n5.7　并行搜索\t216\n5.8　并行排序\t218\n5.8.1　分离数据相关性：奇偶交换排序\t218\n5.8.2　改进的插入排序：希尔排序\t221\n5.9　并行算法：矩阵乘法\t226\n5.10　准备好了再通知我：网络NIO\t230\n5.10.1　基于Socket的服务端的多线程模式\t230\n5.10.2　使用NIO进行网络编程\t235\n5.10.3　使用NIO来实现客户端\t243\n5.11　读完了再通知我：AIO\t245\n5.11.1　AIO EchoServer的实现\t245\n5.11.2　AIO Echo客户端实现\t248\n5.12　参考文献\t249\n第6章　Java 8与并发\t251\n6.1　Java 8的函数式编程简介\t251\n6.1.1　函数作为一等公民\t252\n6.1.2　无副作用\t252\n6.1.3　申明式的（Declarative）\t253\n6.1.4　不变的对象\t254\n6.1.5　易于并行\t254\n6.1.6　更少的代码\t254\n6.2　函数式编程基础\t255\n6.2.1　FunctionalInterface注释\t255\n6.2.2　接口默认方法\t256\n6.2.3　lambda表达式\t259\n6.2.4　方法引用\t260\n6.3　一步一步走入函数式编程\t263\n6.4　并行流与并行排序\t267\n6.4.1　使用并行流过滤数据\t267\n6.4.2　从集合得到并行流\t268\n6.4.3　并行排序\t268\n6.5　增强的Future：CompletableFuture\t269\n6.5.1　完成了就通知我\t269\n6.5.2　异步执行任务\t270\n6.5.3　流式调用\t272\n6.5.4　CompletableFuture中的异常处理\t272\n6.5.5　组合多个CompletableFuture\t273\n6.6　读写锁的改进：StampedLock\t274\n6.6.1　StampedLock使用示例\t275\n6.6.2　StampedLock的小陷阱\t276\n6.6.3　有关StampedLock的实现思想\t278\n6.7　原子类的增强\t281\n6.7.1　更快的原子类：LongAdder\t281\n6.7.2　LongAdder的功能增强版：LongAccumulator\t287\n6.8　参考文献\t288\n第7章　使用Akka构建高并发程序\t289\n7.1　新并发模型：Actor\t290\n7.2　Akka之Hello World\t290\n7.3　有关消息投递的一些说明\t293\n7.4　Actor的生命周期\t295\n7.5　监督策略\t298\n7.6　选择Actor\t303\n7.7　消息收件箱（Inbox）\t303\n7.8　消息路由\t305\n7.9　Actor的内置状态转换\t308\n7.10　询问模式：Actor中的Future\t311\n7.11　多个Actor同时修改数据：Agent\t313\n7.12　像数据库一样操作内存数据：软件事务内存\t316\n7.13　一个有趣的例子：并发粒子群的实现\t319\n7.13.1　什么是粒子群算法\t320\n7.13.2　粒子群算法的计算过程\t320\n7.13.3　粒子群算法能做什么\t322\n7.13.4　使用Akka实现粒子群\t323\n7.14　参考文献\t330\n第8章　并行程序调试\t331\n8.1　准备实验样本\t331\n8.2　正式起航\t332\n8.3　挂起整个虚拟机\t334\n8.4　调试进入ArrayList内部\t336","pages":"339","images":{"small":"https://img1.doubanio.com/view/subject/s/public/s29405037.jpg","large":"https://img1.doubanio.com/view/subject/l/public/s29405037.jpg","medium":"https://img1.doubanio.com/view/subject/m/public/s29405037.jpg"},"alt":"https://book.douban.com/subject/26663605/","id":"26663605","publisher":"电子工业出版社","isbn10":"7121273047","isbn13":"9787121273049","title":"实战Java高并发程序设计","url":"https://api.douban.com/v2/book/26663605","alt_title":"","author_intro":"葛一鸣，51CTO特约讲师，国家认证系统分析师，获得OracleOCP认证。长期从事Java软件开发工作，对Java程序设计、JVM有深入的研究，对设计模式、人工智能、神经网络、数据挖掘等技术有浓厚兴趣，著有《自己动手写神经网路》电子书和《实战Java虚拟机》一书。\n郭超，就职于杭州市道路运输管理局信息中心，主要从事大型交通管理系统的分布式管理和并发模型设计，对Java的研究比较深入，专注于分布式应用和并发应用。","summary":"在过去单核CPU时代，单任务在一个时间点只能执行单一程序，随着多核CPU的发展，并行程序开发就显得尤为重要。\n《实战Java高并发程序设计》主要介绍基于Java的并行程序设计基础、思路、方法和实战。第一，立足于并发程序基础，详细介绍Java中进行并行程序设计的基本方法。第二，进一步详细介绍JDK中对并行程序的强大支持，帮助读者快速、稳健地进行并行程序开发。第三，详细讨论有关“锁”的优化和提高并行程序性能级别的方法和思路。第四，介绍并行的基本设计模式及Java 8对并行程序的支持和改进。第五，介绍高并发框架Akka的使用方法。最后，详细介绍并行程序的调试方法。\n《实战Java高并发程序设计》内容丰富，实例典型，实用性强，适合有一定Java基础的技术开发人员阅读。","price":"CNY 69.00"},"9787111421900":{"rating":{"max":10,"numRaters":1136,"average":"8.9","min":0},"subtitle":"JVM高级特性与最佳实践","author":["周志明"],"pubdate":"2013-9-1","tags":[{"count":981,"name":"JVM","title":"JVM"},{"count":865,"name":"Java","title":"Java"},{"count":636,"name":"虚拟机","title":"虚拟机"},{"count":265,"name":"计算机","title":"计算机"},{"count":263,"name":"java","title":"java"},{"count":218,"name":"编程","title":"编程"},{"count":117,"name":"软件开发","title":"软件开发"},{"count":92,"name":"程序设计","title":"程序设计"}],"origin_title":"","image":"https://img3.doubanio.com/view/subject/m/public/s27458236.jpg","binding":"平装","translator":[],"catalog":"前言\n第一部分走近Java\n第1章走近Java2\n1.1概述2\n1.2Java技术体系3\n1.3Java发展史5\n1.4Java虚拟机发展史9\n1.4.1SunClassicExactVM9\n1.4.2SunHotSpotVM11\n1.4.3SunMobile—EmbeddedVMMeta—CircularVM12\n1.4.4BEAJRockitIBMJ9VM13\n1.4.5AzulVMBEALiquidVM14\n1.4.6ApacheHarmonyGoogleAndroidDalvikVM14\n1.4.7MicrosoftJVM及其他15\n1.5展望Java技术的未来16\n1.5.1模块化17\n1.5.2混合语言17\n1.5.3多核并行19\n1.5.4进一步丰富语法20\n1.5.564位虚拟机21\n1.6实战：自己编译JDK22\n1.6.1获取JDK源码22\n1.6.2系统需求24\n1.6.3构建编译环境25\n1.6.4进行编译26\n1.6.5在IDE工具中进行源码调试31\n1.7本章小结35\n第二部分自动内存管理机制\n第2章Java内存区域与内存溢出异常38\n2.1概述38\n2.2运行时数据区域38\n2.2.1程序计数器39\n2.2.2Java虚拟机栈39\n2.2.3本地方法栈40\n2.2.4Java堆41\n2.2.5方法区41\n2.2.6运行时常量池42\n2.2.7直接内存43\n2.3HotSpot虚拟机对象探秘43\n2.3.1对象的创建44\n2.3.2对象的内存布局47\n2.3.3对象的访问定位48\n2.4实战：OutOfMemoryError异常50\n2.4.1Java堆溢出51\n2.4.2虚拟机栈和本地方法栈溢出53\n2.4.3方法区和运行时常量池溢出56\n2.4.4本机直接内存溢出59\n2.5本章小结60\n第3章垃圾收集器与内存分配策略61\n3.1概述61\n3.2对象已死吗62\n3.2.1引用计数算法62\n3.2.2可达性分析算法64\n3.2.3再谈引用65\n3.2.4生存还是死亡66\n3.2.5回收方法区68\n3.3垃圾收集算法69\n3.3.1标记—清除算法69\n3.3.2复制算法70\n3.3.3标记—整理算法71\n3.3.4分代收集算法72\n3.4HotSpot的算法实现72\n3.4.1枚举根节点72\n3.4.2安全点73\n3.4.3安全区域74\n3.5垃圾收集器75\n3.5.1Serial收集器76\n3.5.2ParNew收集器77\n3.5.3ParallelScavenge收集器79\n3.5.4SerialOld收集器80\n3.5.5ParallelOld收集器80\n3.5.6CMS收集器81\n3.5.7G1收集器84\n3.5.8理解GC日志89\n3.5.9垃圾收集器参数总结90\n3.6内存分配与回收策略91\n3.6.1对象优先在Eden分配91\n3.6.2大对象直接进入老年代93\n3.6.3长期存活的对象将进入老年代95\n3.6.4动态对象年龄判定97\n3.6.5空间分配担保98\n3.7本章小结100\n第4章虚拟机性能监控与故障处理工具101\n4.1概述101\n4.2JDK的命令行工具101\n4.2.1jps：虚拟机进程状况工具104\n4.2.2jstat：虚拟机统计信息监视工具105\n4.2.3jinfo：Java配置信息工具106\n4.2.4jmap：Java内存映像工具107\n4.2.5jhat：虚拟机堆转储快照分析工具108\n4.2.6jstack：Java堆栈跟踪工具109\n4.2.7HSDIS：JIT生成代码反汇编111\n4.3JDK的可视化工具114\n4.3.1JConsole：Java监视与管理控制台115\n4.3.2VisualVM：多合一故障处理工具122\n4.4本章小结131\n第5章调优案例分析与实战132\n5.1概述132\n5.2案例分析132\n5.2.1高性能硬件上的程序部署策略132\n5.2.2集群间同步导致的内存溢出135\n5.2.3堆外内存导致的溢出错误136\n5.2.4外部命令导致系统缓慢137\n5.2.5服务器JVM进程崩溃138\n5.2.6不恰当数据结构导致内存占用过大139\n5.2.7由Windows虚拟内存导致的长时间停顿141\n5.3实战：Eclipse运行速度调优142\n5.3.1调优前的程序运行状态142\n5.3.2升级JDK1.6的性能变化及兼容问题145\n5.3.3编译时间和类加载时间的优化150\n5.3.4调整内存设置控制垃圾收集频率153\n5.3.5选择收集器降低延迟157\n5.4本章小结160\n第三部分虚拟机执行子系统\n第6章类文件结构162\n6.1概述162\n6.2无关性的基石162\n6.3Class类文件的结构164\n6.3.1魔数与Class文件的版本166\n6.3.2常量池167\n6.3.3访问标志173\n6.3.4类索引、父类索引与接口索引集合174\n6.3.5字段表集合175\n6.3.6方法表集合178\n6.3.7属性表集合180\n6.4字节码指令简介196\n6.4.1字节码与数据类型197\n6.4.2加载和存储指令199\n6.4.3运算指令200\n6.4.4类型转换指令202\n6.4.5对象创建与访问指令203\n6.4.6操作数栈管理指令203\n6.4.7控制转移指令204\n6.4.8方法调用和返回指令204\n6.4.9异常处理指令205\n6.4.10同步指令205\n6.5公有设计和私有实现206\n6.6Class文件结构的发展207\n6.7本章小结208\n第7章虚拟机类加载机制209\n7.1概述209\n7.2类加载的时机210\n7.3类加载的过程214\n7.3.1加载214\n7.3.2验证216\n7.3.3准备219\n7.3.4解析220\n7.3.5初始化225\n7.4类加载器227\n7.4.1类与类加载器228\n7.4.2双亲委派模型229\n7.4.3破坏双亲委派模型233\n7.5本章小结235\n第8章虚拟机字节码执行引擎236\n8.1概述236\n8.2运行时栈帧结构236\n8.2.1局部变量表238\n8.2.2操作数栈242\n8.2.3动态连接243\n8.2.4方法返回地址243\n8.2.5附加信息244\n8.3方法调用244\n8.3.1解析244\n8.3.2分派246\n8.3.3动态类型语言支持258\n8.4基于栈的字节码解释执行引擎269\n8.4.1解释执行269\n8.4.2基于栈的指令集与基于寄存器的指令集270\n8.4.3基于栈的解释器执行过程272\n8.5本章小结275\n第9章类加载及执行子系统的案例与实战276\n9.1概述276\n9.2案例分析276\n9.2.1Tomcat：正统的类加载器架构276\n9.2.2OSGi：灵活的类加载器架构279\n9.2.3字节码生成技术与动态代理的实现282\n9.2.4Retrotranslator：跨越JDK版本286\n9.3实战：自己动手实现远程执行功能289\n9.3.1目标290\n9.3.2思路290\n9.3.3实现291\n9.3.4验证298\n9.4本章小结299\n第四部分程序编译与代码优化\n第10章早期（编译期）优化302\n10.1概述302\n10.2Javac编译器303\n10.2.1Javac的源码与调试303\n10.2.2解析与填充符号表305\n10.2.3注解处理器307\n10.2.4语义分析与字节码生成307\n10.3Java语法糖的味道311\n10.3.1泛型与类型擦除311\n10.3.2自动装箱、拆箱与遍历循环315\n10.3.3条件编译317\n10.4实战：插入式注解处理器318\n10.4.1实战目标318\n10.4.2代码实现319\n10.4.3运行与测试326\n10.4.4其他应用案例327\n10.5本章小结328\n第11章晚期（运行期）优化329\n11.1概述329\n11.2HotSpot虚拟机内的即时编译器329\n11.2.1解释器与编译器330\n11.2.2编译对象与触发条件332\n11.2.3编译过程337\n11.2.4查看及分析即时编译结果339\n11.3编译优化技术345\n11.3.1优化技术概览346\n11.3.2公共子表达式消除350\n11.3.3数组边界检查消除351\n11.3.4方法内联352\n11.3.5逃逸分析354\n11.4Java与C/C++的编译器对比356\n11.5本章小结358\n第五部分高效并发\n第12章Java内存模型与线程360\n12.1概述360\n12.2硬件的效率与一致性361\n12.3Java内存模型362\n12.3.1主内存与工作内存363\n12.3.2内存间交互操作364\n12.3.3对于volatile型变量的特殊规则366\n12.3.4对于long和double型变量的特殊规则372\n12.3.5原子性、可见性与有序性373\n12.3.6先行发生原则375\n12.4Java与线程378\n12.4.1线程的实现378\n12.4.2Java线程调度381\n12.4.3状态转换383\n12.5本章小结384\n第13章线程安全与锁优化385\n13.1概述385\n13.2线程安全385\n13.2.1Java语言中的线程安全386\n13.2.2线程安全的实现方法390\n13.3锁优化397\n13.3.1自旋锁与自适应自旋398\n13.3.2锁消除398\n13.3.3锁粗化400\n13.3.4轻量级锁400\n13.3.5偏向锁402\n13.4本章小结403\n附录\n附录A编译Windows版的OpenJDK406\n附录B虚拟机字节码指令表414\n附录CHotSpot虚拟机主要参数表420\n附录D对象查询语言（OQL）简介424\n附录EJDK历史版本轨迹430","ebook_url":"https://read.douban.com/ebook/15233695/","pages":"433","images":{"small":"https://img3.doubanio.com/view/subject/s/public/s27458236.jpg","large":"https://img3.doubanio.com/view/subject/l/public/s27458236.jpg","medium":"https://img3.doubanio.com/view/subject/m/public/s27458236.jpg"},"alt":"https://book.douban.com/subject/24722612/","id":"24722612","publisher":"机械工业出版社","isbn10":"7111421906","isbn13":"9787111421900","title":"深入理解Java虚拟机（第2版）","url":"https://api.douban.com/v2/book/24722612","alt_title":"","author_intro":"周志明，资深Java技术专家，对JavaEE企业级应用开发、OSGi、Java虚拟机和工作流等都有深入的研究，并在大量的实践中积累了丰富的经验。尤其精通Java虚拟机，撰写了大量与JVM相关的经典文章，被各大技术社区争相转载，是ITeye等技术社区公认的Java虚拟机方面的领袖人物之一。除本书外，还著有经典著作《深入理解OSGi：Equinox原理、应用与最佳实践》，广获读者好评。现任远光软件股份有限公司开发部总经理兼架构师，先后参与过国家电网、南方电网等多个国家级大型ERP项目的平台架构工作，对软件系统架构也有深刻的认识和体会。","summary":"《深入理解Java虚拟机:JVM高级特性与最佳实践(第2版)》内容简介：第1版两年内印刷近10次，4家网上书店的评论近4?000条，98%以上的评论全部为5星级的好评，是整个Java图书领域公认的经典著作和超级畅销书，繁体版在台湾也十分受欢迎。第2版在第1版的基础上做了很大的改进：根据最新的JDK 1.7对全书内容进行了全面的升级和补充；增加了大量处理各种常见JVM问题的技巧和最佳实践；增加了若干与生产环境相结合的实战案例；对第1版中的错误和不足之处的修正；等等。第2版不仅技术更新、内容更丰富，而且实战性更强。\n《深入理解Java虚拟机:JVM高级特性与最佳实践(第2版)》共分为五大部分，围绕内存管理、执行子系统、程序编译与优化、高效并发等核心主题对JVM进行了全面而深入的分析，深刻揭示了JVM的工作原理。\n第一部分从宏观的角度介绍了整个Java技术体系、Java和JVM的发展历程、模块化，以及JDK的编译，这对理解书中后面内容有重要帮助。\n第二部分讲解了JVM的自动内存管理，包括虚拟机内存区域的划分原理以及各种内存溢出异常产生的原因；常见的垃圾收集算法以及垃圾收集器的特点和工作原理；常见虚拟机监控与故障处理工具的原理和使用方法。\n第三部分分析了虚拟机的执行子系统，包括类文件结构、虚拟机类加载机制、虚拟机字节码执行引擎。\n第四部分讲解了程序的编译与代码的优化，阐述了泛型、自动装箱拆箱、条件编译等语法糖的原理；讲解了虚拟机的热点探测方法、HotSpot的即时编译器、编译触发条件，以及如何从虚拟机外部观察和分析JIT编译的数据和结果；\n第五部分探讨了Java实现高效并发的原理，包括JVM内存模型的结构和操作；原子性、可见性和有序性在Java内存模型中的体现；先行发生原则的规则和使用；线程在Java语言中的实现原理；虚拟机实现高效并发所做的一系列锁优化措施。","ebook_price":"25.00","price":"79.00元"},"9787121022982":{"rating":{"max":10,"numRaters":3578,"average":"9.3","min":0},"subtitle":"","author":["[美] 史蒂夫·迈克康奈尔"],"pubdate":"2006-3","tags":[{"count":3183,"name":"编程","title":"编程"},{"count":2899,"name":"代码大全","title":"代码大全"},{"count":1649,"name":"软件开发","title":"软件开发"},{"count":1502,"name":"计算机","title":"计算机"},{"count":1444,"name":"软件工程","title":"软件工程"},{"count":1199,"name":"程序设计","title":"程序设计"},{"count":837,"name":"programming","title":"programming"},{"count":785,"name":"代码","title":"代码"}],"origin_title":"Code Complete","image":"https://img1.doubanio.com/view/subject/m/public/s1495029.jpg","binding":"平装","translator":["金戈","汤凌","陈硕","张菲 译","裘宗燕 审校"],"catalog":"第 1 章    欢迎进入软件构建的世界　　3\n第 2 章    用隐喻来更充分地理解软件开发　　9\n第 3 章    三思而后行：前期准备　　23\n第 4 章    关键的“构建”决策　　61\n第 5 章    软件构建中的设计　　73\n第 6 章    可以工作的类　　125\n第 7 章    高质量的子程序　　161\n第 8 章    防御式编程　　187\n第 9 章    伪代码编程过程　　215\n第 10 章    使用变量的一般事项　　237\n第 11 章    变量名的力量　　259\n第 12 章    基本数据类型　　291\n第 13 章    不常见的数据类型　　319\n第 14 章    组织直线型代码　　347\n第 15 章    使用条件语句　　355\n第 16 章    控制循环　　367\n第 17 章    不常见的控制结构　　391\n第 18 章    表驱动法　　411\n第 19 章    一般控制问题　　431\n第 20 章    软件质量概述　　463\n第 21 章    协同构建　　479\n第 22 章    开发者测试　　499\n第 23 章    调试　　535\n第 24 章    重构　　563\n第 25 章    代码调整策略　　587\n第 26 章    代码调整技术　　609\n第 27 章    程序规模对构建的影响　　649\n第 28 章    管理构建　　661\n第 29 章    集成　　689\n第 30 章    编程工具　　709\n第 31 章    布局与风格　　729\n第 32 章    自说明代码　　777\n第 33 章    个人性格　　819\n第 34 章    软件工艺的话题　　837\n第 35 章    何处有更多信息　　855\n参考文献  　　863\n索引  883","pages":"944","images":{"small":"https://img1.doubanio.com/view/subject/s/public/s1495029.jpg","large":"https://img1.doubanio.com/view/subject/l/public/s1495029.jpg","medium":"https://img1.doubanio.com/view/subject/m/public/s1495029.jpg"},"alt":"https://book.douban.com/subject/1477390/","id":"1477390","publisher":"电子工业出版社","isbn10":"7121022982","isbn13":"9787121022982","title":"代码大全（第2版）","url":"https://api.douban.com/v2/book/1477390","alt_title":"Code Complete","author_intro":"史蒂夫·迈克康奈尔（Steve McConnell）被公认为软件开发社区中的首要作者和发言人之一。他是Construx Software公司的首席软件工程师。他所编著的图书包括曾被《软件开发》杂志授予优异产品震撼大奖的《代码大全》和《快速软件开发》，以及《软件项目生存指南》和《专业软件开发》等等。","summary":"第2版的《代码大全》是著名IT畅销书作者史蒂夫·迈克康奈尔11年前的经典著作的全新演绎：第2版不是第一版的简单修订增补，而是完全进行了重写；增加了很多与时俱进的内容。这也是一本完整的软件构建手册，涵盖了软件构建过程中的所有细节。它从软件质量和编程思想等方面论述了软件构建的各个问题，并详细论述了紧跟潮流的新技术、高屋建瓴的观点、通用的概念，还含有丰富而典型的程序示例。这本书中所论述的技术不仅填补了初级与高级编程技术之间的空白，而且也为程序员们提供了一个有关编程技巧的信息来源。这本书对经验丰富的程序员、技术带头人、自学的程序员及几乎不懂太多编程技巧的学生们都是大有裨益的。可以说，无论是什么背景的读者，阅读这本书都有助于在更短的时间内、更容易地写出更好的程序。","series":{"id":"6628","title":"传世经典书丛"},"price":"128.00元"},"9787115470669":{"rating":{"max":10,"numRaters":122,"average":"7.8","min":0},"subtitle":"","author":["张鑫旭"],"pubdate":"2017-12","tags":[{"count":108,"name":"CSS","title":"CSS"},{"count":82,"name":"前端","title":"前端"},{"count":24,"name":"前端开发","title":"前端开发"},{"count":15,"name":"css","title":"css"},{"count":14,"name":"编程","title":"编程"},{"count":14,"name":"Web前端开发","title":"Web前端开发"},{"count":9,"name":"计算机","title":"计算机"},{"count":8,"name":"入门好书","title":"入门好书"}],"origin_title":"","image":"https://img1.doubanio.com/view/subject/m/public/s29651678.jpg","binding":"平装","translator":[],"catalog":"第 1章　概述 1\n1．1 CSS世界的“世界观” 1\n1．2 世界都是创造出来的 3\n1．3 CSS完胜SVG的武器—流 4\n1．3．1 何为“流” 5\n1．3．2　流是如何影响整个CSS世界的 6\n1．3．3 什么是流体布局 6\n1．4 CSS世界的开启从IE8开始 6\n1．5 table自己的世界 7\n1．6 CSS新世界—CSS3 7\n第 2章　需提前了解的术语和概念 8\n2．1 务必了解的CSS世界的专业术语 8\n2．2 了解CSS世界中的“未定义行为” 11\n第3章　流、元素与基本尺寸 13\n3．1 块级元素 13\n3．1．1 为什么list-item元素会出现项目符号 15\n3．1．2 display：inline-table的盒子是怎样组成的 16\n3．1．3 width/height作用在哪个盒子上 16\n3．2 width/height作用的具体细节 16\n3．2．1 深藏不露的width：auto 17\n3．2．2 width值作用的细节 24\n3．2．3 CSS流体布局下的宽度分离原则 27\n3．2．4 改变width/height作用细节的box-sizing 29\n3．2．5 相对简单而单纯的height：auto 33\n3．2．6 关于height：100% 33\n3．3 CSS min-width/max-width和min-height/max-height二三事 37\n3．3．1 为流体而生的min-width/max-width 38\n3．3．2 与众不同的初始值 38\n3．3．3 超越!important 39\n3．3．4 任意高度元素的展开收起动画技术 40\n3．4 内联元素 42\n3．4．1 哪些元素是内联元素 42\n3．4．2 内联世界深入的基础—内联盒模型 42\n3．4．3 幽灵空白节点 44\n第4章　盒尺寸四大家族 45\n4．1 深入理解content 45\n4．1．1 content与替换元素 45\n4．1．2 content内容生成技术 57\n4．2 温和的padding属性 73\n4．2．1 padding与元素的尺寸 73\n4．2．2 padding的百分比值 77\n4．2．3 标签元素内置的padding 79\n4．2．4 padding与图形绘制 80\n4．3 激进的margin属性 81\n4．3．1 margin与元素尺寸以及相关布局 82\n4．3．2 margin的百分比值 87\n4．3．3 正确看待CSS世界里的margin合并 87\n4．3．4 深入理解CSS中的margin：auto 94\n4．3．5 margin无效情形解析 97\n4．4 border属性 100\n4．4．1 为什么border-width不支持百分比值 100\n4．4．2 了解各种border-style类型 101\n4．4．3 border-color和color 105\n4．4．4 border与透明边框技巧 106\n4．4．5 border与图形构建 108\n4．4．6 border等高布局技术 109\n第5章　内联元素与流 111\n5．1 字母x—CSS世界中隐匿的举足轻重的角色 111\n5．1．1 字母x与CSS世界的基线 111\n5．1．2 字母x与CSS中的x-height 112\n5．1．3 字母x与CSS中的ex 113\n5．2 内联元素的基石line-height 114\n5．2．1 内联元素的高度之本—line-height 114\n5．2．2 为什么line-height可以让内联元素“垂直居中” 119\n5．2．3 深入line-height的各类属性值 121\n5．2．4 内联元素line-height的“大值特性” 124\n5．3 line-height的好朋友vertical-align 126\n5．3．1 vertical-align家族基本认识 127\n5．3．2 vertical-align作用的前提 129\n5．3．3 vertical-align和line-height之间的关系 131\n5．3．4 深入理解vertical-align线性类属性值 135\n5．3．5 深入理解vertical-align文本类属性值 141\n5．3．6 简单了解vertical-align上标下标类属性值 142\n5．3．7 无处不在的vertical-align 143\n5．3．8 基于vertical-align属性的水平垂直居中弹框 144\n第6章　流的破坏与保护 147\n6．1 魔鬼属性float 147\n6．1．1 float的本质与特性 147\n6．1．2 float的作用机制 151\n6．1．3 float更深入的作用机制 154\n6．1．4 float与流体布局 155\n6．2 float的天然克星clear 157\n6．2．1 什么是clear属性 157\n6．2．2 成事不足败事有余的clear 158\n6．3 CSS世界的结界—BFC 160\n6．3．1 BFC的定义 160\n6．3．2 BFC与流体布局 160\n6．4 结界overflow 164\n6．4．1 overflow剪裁界线border box 165\n6．4．2 了解overflow-x和overflow-y 166\n6．4．3 overflow与滚动条 166\n6．4．4 依赖overflow的样式表现 169\n6．4．5 overflow与锚点定位 170\n6．5 float的兄弟position：absolute 177\n6．5．1 absolute的包含块 178\n6．5．2 具有相对特性的无依赖absolute定位 184\n6．5．3 absolute与text-align 191\n6．6 absolute与overflow 193\n6．7 absolute与clip 195\n6．7．1 重新认识的clip属性 196\n6．7．2 深入了解clip的渲染 198\n6．8 absolute的流体特性 199\n6．8．1 当absolute遇到left/top/right/bottom属性 199\n6．8．2 absolute的流体特性 200\n6．8．3 absolute的margin：auto居中 202\n6．9 position：relative才是大哥 202\n6．9．1 relative对absolute的限制 203\n6．9．2 relative与定位 203\n6．9．3 relative的zui小化影响原则 206\n6．10 强悍的position：fixed固定定位 207\n6．10．1 position：fixed不一样的“包含块” 207\n6．10．2 position：fixed的absolute模拟 208\n6．10．3 position：fixed与背景锁定 209\n第7章　CSS世界的层叠规则 211\n7．1 z-index只是CSS层叠规则中的一叶小舟 211\n7．2 理解CSS世界的层叠上下文和层叠水平 212\n7．2．1 什么是层叠上下文 212\n7．2．2 什么是层叠水平 212\n7．3 理解元素的层叠顺序 212\n7．4 务必牢记的层叠准则 214\n7．5 深入了解层叠上下文 214\n7．5．1 层叠上下文的特性 214\n7．5．2 层叠上下文的创建 214\n7．5．3 层叠上下文与层叠顺序 217\n7．6 z-index负值深入理解 219\n7．7 z-index“不犯二”准则 223\n第8章　强大的文本处理能力 225\n8．1 line-height的另外一个朋友font-size 225\n8．1．1 font-size和vertical-align的隐秘故事 225\n8．1．2 理解font-size与ex、em和rem的关系 227\n8．1．3 理解font-size的关键字属性值 229\n8．1．4 font-size：0与文本的隐藏 231\n8．2 字体属性家族的大家长font-family 232\n8．2．1 了解衬线字体和无衬线字体 233\n8．2．2 等宽字体的实践价值 234\n8．2．3 中文字体和英文名称 236\n8．2．4 一些补充说明 237\n8．3 字体家族其他成员 238\n8．3．1 貌似粗犷、实则精细无比的font-weight 238\n8．3．2 具有近似姐妹花属性值的font-style 241\n8．3．3 不适合国情的font-variant 242\n8．4 font属性 242\n8．4．1 作为缩写的font属性 242\n8．4．2 使用关键字值的font属性 243\n8．4．3 font关键字属性值的应用价值 246\n8．5 真正了解@font face规则 247\n8．5．1 @font face的本质是变量 247\n8．5．2 @font face与字体图标技术 255\n8．6 文本的控制 258\n8．6．1 text-indent与内联元素缩进 258\n8．6．2 letter-spacing与字符间距 261\n8．6．3 word-spacing与单词间距 263\n8．6．4 了解word-break和word-wrap的区别 264\n8．6．5 white-space与换行和空格的控制 265\n8．6．6 text-align与元素对齐 267\n8．6．7 如何解决text-decoration下划线和文本重叠的问题 271\n8．6．8 一本万利的text-transform字符大小写 273\n8．7 了解：first-letter/：first-line伪元素 274\n8．7．1 深入：first-letter伪元素及其实例 274\n8．7．2 故事相对较少的：first-line伪元素 277\n第9章　元素的装饰与美化 280\n9．1 CSS世界的color很单调 280\n9．1．1 少得可怜的颜色关键字 280\n9．1．2 不支持的transparent关键字 282\n9．1．3 不支持的currentColor变量 282\n9．1．4 不支持的rgba颜色和hsla颜色 282\n9．1．5 支持却鸡肋的系统颜色 283\n9．2 CSS世界的background很单调 285\n9．2．1 隐藏元素的background-image到底加不加载 285\n9．2．2 与众不同的background-position百分比计算方式 286\n9．2．3 background-repeat与渲染性能 287\n9．2．4 外强中干的background-attachment：fixed 288\n9．2．5 background-color背景色永远是很低的 289\n9．2．6 利用多背景的属性hack小技巧 290\n9．2．7 渐变背景和rgba背景色的兼容处理 290\n第 10章　元素的显示与隐藏 292\n10．1 display与元素的显隐 294\n10．2 visibility与元素的显隐 296\n10．2．1 不仅仅是保留空间这么简单 296\n10．2．2 了解visibility：collapse 301\n第 11章　用户界面样式 302\n11．1 和border形似的outline属性 302\n11．1．1 万万不可在全局设置outline：0 none 302\n11．1．2 真正的不占据空间的outline及其应用 304\n11．2 光标属性cursor 307\n11．2．1 琳琅满目的cursor属性值 307\n11．2．2 自定义光标 314\n第 12章　流向的改变 315\n12．1 改变水平流向的direction 315\n12．1．1 direction简介 315\n12．1．2 direction的黄金搭档unicode-bidi 318\n12．2 改变CSS世界纵横规则的writing-mode 320\n12．2．1 writing-mode原本的作用 321\n12．2．2 writing-mode不经意改变了哪些规则 324\n12．2．3 writing-mode和direction的关系 328","pages":"328","images":{"small":"https://img1.doubanio.com/view/subject/s/public/s29651678.jpg","large":"https://img1.doubanio.com/view/subject/l/public/s29651678.jpg","medium":"https://img1.doubanio.com/view/subject/m/public/s29651678.jpg"},"alt":"https://book.douban.com/subject/27615777/","id":"27615777","publisher":"人民邮电出版社","isbn10":"7115470669","isbn13":"9787115470669","title":"CSS世界","url":"https://api.douban.com/v2/book/27615777","alt_title":"","author_intro":"张鑫旭，前端开发工程师，国内知名前端博客“鑫空间-鑫生活”博主，目前就职于阅文集团用户体验设计部（YUX），担任技术经理。2007年开始接触前端，10年来一直工作在前端开发一线，在HTML/CSS等与交互体验关系密切的领域花了大量的时间学习和研究，有比较多的心得体会。","summary":"本书从前端开发人员的需求出发，以“流”为线索，从结构、内容到美化装饰等方面，全面且深入地讲解前端开发人员必须了解和掌握的大量的CSS知识点。同时，作者结合多年的从业经验，通过大量的实战案例，详尽解析CSS的相关知识与常见问题。作者还为本书开发了专门的配套网站，进行实例展示、问题答疑。\n作为一本CSS深度学习的书，书中介绍大量许多前端开发人员都不知道的CSS知识点。通过阅读本书，读者会对CSS世界的深度和广度有一个全新的认识。","price":"CNY 69.00"},"9787115416940":{"rating":{"max":10,"numRaters":255,"average":"9.4","min":0},"subtitle":"","author":["[希] Lea Verou"],"pubdate":"2016-4","tags":[{"count":385,"name":"CSS","title":"CSS"},{"count":197,"name":"前端开发","title":"前端开发"},{"count":122,"name":"前端","title":"前端"},{"count":67,"name":"网页设计","title":"网页设计"},{"count":53,"name":"Web前端开发","title":"Web前端开发"},{"count":51,"name":"CSS秘笈","title":"CSS秘笈"},{"count":47,"name":"编程","title":"编程"},{"count":37,"name":"计算机","title":"计算机"}],"origin_title":"CSS Secrets: Better Solutions to Everyday Web Design Problems","image":"https://img1.doubanio.com/view/subject/m/public/s28659699.jpg","binding":"平装","translator":["CSS魔法"],"catalog":"译者序\n序\n前言\n第1章 引言\n第2章 背景与边框\n第3章 形状\n第4章 视觉效果\n第5章 字体排印\n第6章 用户体验\n第7章 结构与布局\n第8章 过渡与动画\n按规范分类","pages":"260","images":{"small":"https://img1.doubanio.com/view/subject/s/public/s28659699.jpg","large":"https://img1.doubanio.com/view/subject/l/public/s28659699.jpg","medium":"https://img1.doubanio.com/view/subject/m/public/s28659699.jpg"},"alt":"https://book.douban.com/subject/26745943/","id":"26745943","publisher":"人民邮电出版社","isbn10":"711541694X","isbn13":"9787115416940","title":"CSS揭秘","url":"https://api.douban.com/v2/book/26745943","alt_title":"CSS Secrets: Better Solutions to Everyday Web Design Problems","author_intro":"Lea Verou\nW3C CSS工作组特邀专家，设计CSS语言的委员之一，此前曾在W3C担任开发者代言人。目前，她在麻省理工学院从事人机交互领域的研究。她还是一位博客作家，并经常在国际性的技术会议上担任讲师；她创建的多个开源项目广受开发者欢迎。\nCSS魔法\n原名张鹏，国内知名的CSS技术专家，百姓网前端架构师。拥有近十年的网站开发经验，在移动前端领域积累颇深，自称“披着工程师外衣的设计师”。他是CMUI、Action、GHX等开源项目的作者，曾为GitHub、Gulp、Stylus等网站和项目翻译过大量文档；其生动活泼、循序渐进的博客写作风格深受读者喜爱；在CSS Conf等技术会议上所作的演讲广受好评。","summary":"本书是一本注重实践的教程，作者为我们揭示了 47 个鲜为人知的 CSS 技巧，主要内容包括背景与边框、形状、 视觉效果、字体排印、用户体验、结构与布局、过渡与动画等。本书将带领读者循序渐进地探寻更优雅的解决方案，攻克每天都会遇到的各种网页样式难题。\n本书的读者对象为前端工程师、网页开发人员。","price":"99.00元"},"9787121238369":{"rating":{"max":10,"numRaters":176,"average":"8.2","min":0},"subtitle":"","author":["阮一峰"],"pubdate":"2014-8","tags":[{"count":97,"name":"JavaScript","title":"JavaScript"},{"count":66,"name":"ECMAScript6","title":"ECMAScript6"},{"count":49,"name":"前端","title":"前端"},{"count":18,"name":"Web前端开发","title":"Web前端开发"},{"count":17,"name":"编程","title":"编程"},{"count":15,"name":"Javascript","title":"Javascript"},{"count":12,"name":"计算机","title":"计算机"},{"count":9,"name":"Web","title":"Web"}],"origin_title":"","image":"https://img3.doubanio.com/view/subject/m/public/s28315395.jpg","binding":"平装","translator":[],"catalog":"第一章ECMAScript6简介............................  1\nECMAScript和JavaScript的关系    3\nECMAScript的历史    4\n部署进度    5Traceur编译器    7\nECMAScript7    11\n第二章let和const命令..............................13\nlet命令    15\n块级作用域    17\nconst命令    19\n第三章 变量的解构赋值..............................21\n数组的解构赋值    23\n对象的解构赋值    25\n用途    27\n第四章 字符串的扩展 ................................31\ncodePointAt方法    33\nString.fromCodePoint方法    34\n字符的Unicode表示法    35\n正则表达式的u修饰符    36\ncontains(),startsWith(),endsWith()    36\nrepeat()    37\n正则表达式的y修饰符    38\n模板字符串    39\n第五章 数值的扩展 ..................................41\n二进制和八进制数值表示法    43\nNumber.isFinite(),Number.isNaN()    43\nNumber.parseInt(),Number.parseFloat()    44\nNumber.isInteger()和安全整数    44\nMath对象的扩展    45\nMath.trunc()    45\n数学方法    45\n第六章 数组的扩展 ..................................47\nArray.from()    49\nArray.of()    50\n数组实例的fnd()和fndIndex()    50\n数组实例的fll()    51\n数组实例的entries()，keys()和values()    52\n数组推导    53\nArray.observe()，Array.unobserve()    55\n第七章 对象的扩展 ..................................57\nObject.is()    59\nObject.assign()    59\n__proto__属性，Object.setPrototypeOf()，\nObject.getPrototypeOf()    60\n__proto__属性    60\nObject.setPrototypeOf()    61\nObject.getPrototypeOf()    61\n增强的对象写法    62\n属性名表达式    63Symbol    64\nProxy    66Object.observe()，Object.unobserve()    68\n第八章 函数的扩展 ..................................71\n函数参数的默认值    73rest参数    74\n扩展运算符    75箭头函数    77\n第九章 Set和Map数据结构..........................81Set    83Map    86\n基本用法    86\n属性和方法    88\n遍历    89WeakMap    91\n第十章Iterator和for...of循环.......................93\nIterator（遍历器）    95for...of循环    97\n第十一章Generator函数..............................103\n含义    105\nnext方法的参数    108\n异步操作的应用    109\nfor...of循环    112\nyield*语句    112\n第十二章Promise对象 ...............................115\n基本用法    117\n链式操作    120\ncatch方法：捕捉错误    121\nPromise.all方法    121\nPromise.resolve方法    122\nasync函数    123\n第13章  Class和Module.............................125\nClass    127\nModule的基本用法    129\nexport和import    129\n模块的整体加载    130\nexportdefault语句    131\n模块的继承    132\n参考链接.............................................135\n索引.................................................143","pages":"145","images":{"small":"https://img3.doubanio.com/view/subject/s/public/s28315395.jpg","large":"https://img3.doubanio.com/view/subject/l/public/s28315395.jpg","medium":"https://img3.doubanio.com/view/subject/m/public/s28315395.jpg"},"alt":"https://book.douban.com/subject/25966265/","id":"25966265","publisher":"电子工业出版社","isbn10":"7121238365","isbn13":"9787121238369","title":"ECMAScript6入门","url":"https://api.douban.com/v2/book/25966265","alt_title":"","author_intro":"阮一峰：著名技术博客作者，JavaScript专家。专注于网站开发技术，超过十年。畅销书《黑客与画家》《软件随想录》的译者。","summary":"《ECMAScript6入门》全面介绍了ECMAScript6新引入的语法特性，覆盖了ECMAScript6与ECMAScript5的所有不同之处，对涉及的语法知识给予了详细介绍，并给出了大量简洁易懂的示例代码。\n《ECMAScript6入门》为中级难度，适合已有一定JavaScript语言基础的读者，用来了解这门语言的最新发展；也可当作参考手册，查寻新增的语法点。","price":"49.00元"},"9787115388889":{"rating":{"max":10,"numRaters":293,"average":"9.1","min":0},"subtitle":"","author":["曾探"],"pubdate":"2015-5","tags":[{"count":439,"name":"JavaScript","title":"JavaScript"},{"count":286,"name":"设计模式","title":"设计模式"},{"count":184,"name":"前端开发","title":"前端开发"},{"count":94,"name":"前端","title":"前端"},{"count":82,"name":"Web前端","title":"Web前端"},{"count":69,"name":"编程","title":"编程"},{"count":65,"name":"javascript","title":"javascript"},{"count":59,"name":"计算机","title":"计算机"}],"origin_title":"","image":"https://img3.doubanio.com/view/subject/m/public/s28065006.jpg","binding":"平装","translator":[],"catalog":"第一部分　基础知识\n第1章　面向对象的JavaScript\n1.1 动态类型语言和鸭子类型　　2\n1.2 多态　　4\n1.3 封装　　12\n1.4 原型模式和基于原型继承的JavaScript对象系统　　14\n第2章　this、call和apply\n2.1 this　　24\n2.2 call和apply　　29\n第3章　闭包和高阶函数\n3.1 闭包 35\n3.2 高阶函数　　44\n3.3 小结　　58\n第二部分 设计模式\n第4章　单例模式\n4.1 实现单例模式　　60\n4.2 透明的单例模式　　61\n4.3 用代理实现单例模式　　62\n4.4 JavaScript中的单例模式　　63\n4.5 惰性单例　　65\n4.6 通用的惰性单例　　68\n4.7 小结　　70\n第5章　策略模式\n5.1 使用策略模式计算奖金　　72\n5.2 JavaScript 版本的策略模式　　75\n5.3 多态在策略模式中的体现　　76\n5.4 使用策略模式实现缓动动画　　76\n5.5 更广义的“算法”　　80\n5.6 表单校验　　80\n5.7 策略模式的优缺点　　86\n5.8 一等函数对象与策略模式　　86\n5.9 小结　　87\n第6章　代理模式\n6.1 第一个例子——小明追MM的故事　　88\n6.2 保护代理和虚拟代理　　91\n6.3 虚拟代理实现图片预加载　　91\n6.4 代理的意义　　93\n6.5 代理和本体接口的一致性　　94\n6.6 虚拟代理合并HTTP 请求　　95\n6.7 虚拟代理在惰性加载中的应用　　97\n6.8 缓存代理　　99\n6.9 用高阶函数动态创建代理　　100\n6.10 其他代理模式　　101\n6.11 小结　　102\n第7章　迭代器模式\n7.1 jQuery 中的迭代器　　103\n7.2 实现自己的迭代器　　104\n7.3 内部迭代器和外部迭代器　　104\n7.4 迭代类数组对象和字面量对象　　106\n7.5 倒序迭代器　　106\n7.6 中止迭代器　　107\n7.7 迭代器模式的应用举例　　107\n7.8 小结　　109\n第8章　发布—订阅模式\n8.1 现实中的发布—订阅模式　　110\n8.2 发布—订阅模式的作用　　110\n8.3 DOM 事件　　111\n8.4 自定义事件　　112\n8.5 发布—订阅模式的通用实现　　113\n8.6 取消订阅的事件　　115\n8.7 真实的例子——网站登录　　115\n8.8 全局的发布—订阅对象　　117\n8.9 模块间通信　　119\n8.10 必须先订阅再发布吗　　120\n8.11 全局事件的命名冲突　　121\n8.12 JavaScript实现发布—订阅模式的便利性　　124\n8.13 小结　　124\n第9章　命令模式\n9.1 命令模式的用途　　125\n9.2 命令模式的例子——菜单程序　　126\n9.3 JavaScript中的命令模式　　128\n9.4 撤销命令　　130\n9.5 撤消和重做　　132\n9.6 命令队列　　134\n9.7 宏命令　　134\n9.8 智能命令与傻瓜命令　　135\n9.9 小结　　136\n第10章　组合模式\n10.1 回顾宏命令　　138\n10.2 组合模式的用途　　139\n10.3 请求在树中传递的过程　　139\n10.4 更强大的宏命令　　140\n10.5 抽象类在组合模式中的作用　　143\n10.6 透明性带来的安全问题　　144\n10.7 组合模式的例子——扫描文件夹　　145\n10.8 一些值得注意的地方　　147\n10.9 引用父对象　　148\n10.10 何时使用组合模式　　150\n10.11 小结　　150\n第11章　模板方法模式\n11.1 模板方法模式的定义和组成　　151\n11.2 第一个例子——Coffee or Tea　　151\n11.3 抽象类　　156\n11.4 模板方法模式的使用场景　　159\n11.5 钩子方法　　160\n11.6 好莱坞原则　　162\n11.7 真的需要“继承”吗　　162\n11.8 小结　　164\n第12章　享元模式\n12.1 初识享元模式　　165\n12.2 内部状态与外部状态　　166\n12.3 享元模式的通用结构　　167\n12.4 文件上传的例子　　167\n12.5 享元模式的适用性　　173\n12.6 再谈内部状态和外部状态　　173\n12.7 对象池　　175\n12.8 小结　　178\n第13章　职责链模式\n13.1 现实中的职责链模式　　179\n13.2 实际开发中的职责链模式　　180\n13.3 用职责链模式重构代码　　181\n13.4 灵活可拆分的职责链节点　　183\n13.5 异步的职责链　　184\n13.6 职责链模式的优缺点　　185\n13.7 用AOP 实现职责链　　186\n13.8 用职责链模式获取文件上传对象　　187\n13.9 小结　　188\n第14章　中介者模式\n14.1 现实中的中介者　　190\n14.2 中介者模式的例子——泡泡堂游戏　　191\n14.3 中介者模式的例子——购买商品　　199\n14.4 小结　　207\n第15章　装饰者模式\n15.1 模拟传统面向对象语言的装饰者模式　　210\n15.2 装饰者也是包装器　　211\n15.3 回到JavaScript 的装饰者　　212\n15.4 装饰函数　　212\n15.5 用AOP 装饰函数　　214\n15.6 AOP 的应用实例　　216\n15.7 装饰者模式和代理模式　　222\n15.8 小结　　223\n第16章　状态模式\n16.1 初识状态模式　　224\n16.2 状态模式的定义　　230\n16.3 状态模式的通用结构　　230\n16.4 缺少抽象类的变通方式　　　231\n16.5 另一个状态模式示例——文件上传　　232\n16.6 状态模式的优缺点　　241\n16.7 状态模式中的性能优化点　　241\n16.8 状态模式和策略模式的关系　　241\n16.9 JavaScript版本的状态机　　242\n16.10 表驱动的有限状态机　　244\n16.11 实际项目中的其他状态机　　245\n16.12 小结　　245\n第17章　适配器模式\n17.1 现实中的适配器　　246\n17.2 适配器模式的应用　　247\n17.3 小结　　250\n第三部分 设计原则和编程技巧\n第18章　单一职责原则\n18.1 设计模式中的SRP原则　　252\n18.2 何时应该分离职责　　256\n18.3 违反SRP原则　　256\n18.4 SRP 原则的优缺点　　257\n第19章　最少知识原则\n19.1 减少对象之间的联系　　258\n19.2 设计模式中的LKP原则　　259\n19.3 封装在LKP 原则中的体现　　261\n第20章　开放-封闭原则\n20.1 扩展window.onload函数　　263\n20.2 开放和封闭　　264\n20.3 用对象的多态性消除条件分支　　265\n20.4 找出变化的地方　　266\n20.5 设计模式中的开放—封闭原则　　268\n20.6 开放—封闭原则的相对性　　270\n20.7 接受第一次愚弄　　270\n第21章　接口和面向接口编程\n21.1 回到Java的抽象类　　271\n21.2 interface　　276\n21.3 JavaScript 语言是否需要抽象类和interface　　275\n21.4 用鸭子类型进行接口检查　　277\n21.5 用TypeScript 编写基于interface的命令模式　　278\n第22章　代码重构\n22.1 提炼函数　　282\n22.2 合并重复的条件片段　　283\n22.3 把条件分支语句提炼成函数　　284\n22.4 合理使用循环　　285\n22.5 提前让函数退出代替嵌套条件分支　　285\n22.6 传递对象参数代替过长的参数列表　　286\n22.7 尽量减少参数数量　　287\n22.8 少用三目运算符　　288\n22.9 合理使用链式调用　　288\n22.10 分解大型类　　289\n22.11 用return退出多重循环　　290\n参考文献　　293","pages":"294","images":{"small":"https://img3.doubanio.com/view/subject/s/public/s28065006.jpg","large":"https://img3.doubanio.com/view/subject/l/public/s28065006.jpg","medium":"https://img3.doubanio.com/view/subject/m/public/s28065006.jpg"},"alt":"https://book.douban.com/subject/26382780/","id":"26382780","publisher":"人民邮电出版社","isbn10":"7115388881","isbn13":"9787115388889","title":"JavaScript设计模式与开发实践","url":"https://api.douban.com/v2/book/26382780","alt_title":"","author_intro":"曾探\n2007年毕业于吉林大学软件学院。就职于国内知名前端团队腾讯AlloyTeam，高级工程师。\n曾参与Web QQ、QQ群、Q+开发者网站、微云、QQ兴趣部落等大型前端项目的开发。有过Java、Python和JavaScript的开发经验，业余作品有HTML5版街头霸王等。\n平时喜欢电影和音乐，业务时间也是一名健身教练。","summary":"本书在尊重《设计模式》原意的同时，针对JavaScript语言特性全面介绍了更适合JavaScript程序员的了16个常用的设计模式，讲解了JavaScript面向对象和函数式编程方面的基础知识，介绍了面向对象的设计原则及其在设计模式中的体现，还分享了面向对象编程技巧和日常开发中的代码重构。本书将教会你如何把经典的设计模式应用到JavaScript语言中，编写出优美高效、结构化和可维护的代码。","series":{"id":"13000","title":"图灵原创"},"price":"59.00元"},"9787115275790":{"rating":{"max":10,"numRaters":1926,"average":"9.3","min":0},"subtitle":"","author":["[美] Nicholas C. Zakas"],"pubdate":"2012-3-29","tags":[{"count":2302,"name":"JavaScript","title":"JavaScript"},{"count":1064,"name":"Web前端开发","title":"Web前端开发"},{"count":667,"name":"前端开发","title":"前端开发"},{"count":511,"name":"前端","title":"前端"},{"count":498,"name":"javascript","title":"javascript"},{"count":452,"name":"编程","title":"编程"},{"count":409,"name":"计算机","title":"计算机"},{"count":404,"name":"Web开发","title":"Web开发"}],"origin_title":"Professional JavaScript for Web","image":"https://img3.doubanio.com/view/subject/m/public/s8958650.jpg","binding":"平装","translator":["李松峰","曹力"],"catalog":"目　　录\n第1章　JavaScript简介　　1\n1.1　JavaScript简史　　1\n1.2　JavaScript实现　　2\n1.2.1　ECMAScript　　3\n1.2.2　文档对象模型（DOM）　　5\n1.2.3　浏览器对象模型（BOM）　　8\n1.3　JavaScript版本　　8\n1.4　小结　　9\n第2章　在HTML中使用JavaScript　　10\n2.1　<script>元素　　10\n2.1.1　标签的位置　　12\n2.1.2　延迟脚本　　13\n2.1.3　异步脚本　　13\n2.1.4　在XHTML中的用法　　14\n2.1.5　不推荐使用的语法　　16\n2.2　嵌入代码与外部文件　　16\n2.3　文档模式　　16\n2.4　<noscript>元素　　18\n2.5　小结　　18\n第3章　基本概念　　19\n3.1　语法　　19\n3.1.1　区分大小写　　19\n3.1.2　标识符　　19\n3.1.3　注释　　20\n3.1.4　严格模式　　20\n3.1.5　语句　　20\n3.2　关键字和保留字　　21\n3.3　变量　　22\n3.4　数据类型　　23\n3.4.1　typeof操作符　　23\n3.4.2　Undefined类型　　24\n3.4.3　Null类型　　25\n3.4.4　Boolean类型　　26\n3.4.5　Number类型　　27\n3.4.6　String类型　　32\n3.4.7　Object类型　　35\n3.5　操作符　　36\n3.5.1　一元操作符　　36\n3.5.2　位操作符　　39\n3.5.3　布尔操作符　　44\n3.5.4　乘性操作符　　47\n3.5.5　加性操作符　　48\n3.5.6　关系操作符　　50\n3.5.7　相等操作符　　51\n3.5.8　条件操作符　　53\n3.5.9　赋值操作符　　53\n3.5.10　逗号操作符　　54\n3.6　语句　　54\n3.6.1　if语句　　54\n3.6.2　do-while语句　　55\n3.6.3　while语句　　55\n3.6.4　for语句　　56\n3.6.5　for-in语句　　57\n3.6.6　label语句　　58\n3.6.7　break和continue语句　　58\n3.6.8　with语句　　60\n3.6.9　switch语句　　60\n3.7　函数　　62\n3.7.1　理解参数　　64\n3.7.2　没有重载　　66\n3.8　小结　　67\n第4章　变量、作用域和内存问题　　68\n4.1　基本类型和引用类型的值　　68\n4.1.1　动态的属性　　68\n4.1.2　复制变量值　　69\n4.1.3　传递参数　　70\n4.1.4　检测类型　　72\n4.2　执行环境及作用域　　73\n4.2.1　延长作用域链　　75\n4.2.2　没有块级作用域　　76\n4.3　垃圾收集　　78\n4.3.1　标记清除　　78\n4.3.2　引用计数　　79\n4.3.3　性能问题　　80\n4.3.4　管理内存　　81\n4.4　小结　　81\n第5章　引用类型　　83\n5.1　Object类型　　83\n5.2　Array类型　　86\n5.2.1　检测数组　　88\n5.2.2　转换方法　　89\n5.2.3　栈方法　　90\n5.2.4　队列方法　　91\n5.2.5　重排序方法　　92\n5.2.6　操作方法　　94\n5.2.7　位置方法　　95\n5.2.8　迭代方法　　96\n5.2.9　缩小方法　　97\n5.3　Date类型　　98\n5.3.1　继承的方法　　100\n5.3.2　日期格式化方法　　101\n5.3.3　日期/时间组件方法　　102\n5.4　RegExp类型　　103\n5.4.1　RegExp实例属性　　105\n5.4.2　RegExp实例方法　　106\n5.4.3　RegExp构造函数属性　　107\n5.4.4　模式的局限性　　109\n5.5　Function类型　　110\n5.5.1　没有重载（深入理解）　　111\n5.5.2　函数声明与函数表达式　　111\n5.5.3　作为值的函数　　112\n5.5.4　函数内部属性　　113\n5.5.5　函数属性和方法　　116\n5.6　基本包装类型　　118\n5.6.1　Boolean类型　　120\n5.6.2　Number类型　　120\n5.6.3　String类型　　122\n5.7　单体内置对象　　130\n5.7.1　Global对象　　131\n5.7.2　Math对象　　134\n5.8　小结　　137\n第6章　面向对象的程序设计　　138\n6.1　理解对象　　138\n6.1.1　属性类型　　139\n6.1.2　定义多个属性　　142\n6.1.3　读取属性的特性　　143\n6.2　创建对象　　144\n6.2.1　工厂模式　　144\n6.2.2　构造函数模式　　144\n6.2.3　原型模式　　147\n6.2.4　组合使用构造函数模式和原型模式　　159\n6.2.5　动态原型模式　　159\n6.2.6　寄生构造函数模式　　160\n6.2.7　稳妥构造函数模式　　161\n6.3　继承　　162\n6.3.1　原型链　　162\n6.3.2　借用构造函数　　167\n6.3.3　组合继承　　168\n6.3.4　原型式继承　　169\n6.3.5　寄生式继承　　171\n6.3.6　寄生组合式继承　　172\n6.4　小结　　174\n第7章　函数表达式　　175\n7.1　递归　　177\n7.2　闭包　　178\n7.2.1　闭包与变量　　181\n7.2.2　关于this对象　　182\n7.2.3　内存泄漏　　183\n7.3　模仿块级作用域　　184\n7.4　私有变量　　186\n7.4.1　静态私有变量　　188\n7.4.2　模块模式　　189\n7.4.3　增强的模块模式　　191\n7.5　小结　　192\n第8章　BOM　　193\n8.1　window对象　　193\n8.1.1　全局作用域　　193\n8.1.2　窗口关系及框架　　194\n8.1.3　窗口位置　　197\n8.1.4　窗口大小　　198\n8.1.5　导航和打开窗口　　199\n8.1.6　间歇调用和超时调用　　203\n8.1.7　系统对话框　　205\n8.2　location对象　　207\n8.2.1　查询字符串参数　　207\n8.2.2　位置操作　　208\n8.3　navigator对象　　210\n8.3.1　检测插件　　211\n8.3.2　注册处理程序　　213\n8.4　screen对象　　214\n8.5　history对象　　215\n8.6　小结　　216\n第9章　客户端检测　　217\n9.1　能力检测　　217\n9.1.1　更可靠的能力检测　　218\n9.1.2　能力检测，不是浏览器检测　　220\n9.2　怪癖检测　　220\n9.3　用户代理检测　　221\n9.3.1　用户代理字符串的历史　　222\n9.3.2　用户代理字符串检测技术　　228\n9.3.3　完整的代码　　242\n9.3.4　使用方法　　245\n9.4　小结　　246\n第10章　DOM　　247\n10.1　节点层次　　247\n10.1.1　Node类型　　248\n10.1.2　Document类型　　253\n10.1.3　Element类型　　261\n10.1.4　Text类型　　270\n10.1.5　Comment类型　　273\n10.1.6　CDATASection类型　　274\n10.1.7　DocumentType类型　　274\n10.1.8　DocumentFragment类型　　275\n10.1.9　Attr类型　　276\n10.2　DOM操作技术　　277\n10.2.1　动态脚本　　277\n10.2.2　动态样式　　279\n10.2.3　操作表格　　281\n10.2.4　使用NodeList　　283\n10.3　小结　　284\n第11章　DOM扩展　　286\n11.1　选择符API　　286\n11.1.1　querySelector()方法　　286\n11.1.2　querySelectorAll()\n方法　　287\n11.1.3　matchesSelector()\n方法　　288\n11.2　元素遍历　　288\n11.3　HTML5　　289\n11.3.1　与类相关的扩充　　289\n11.3.2　焦点管理　　291\n11.3.3　HTMLDocument的变化　　292\n11.3.4　字符集属性　　293\n11.3.5　自定义数据属性　　293\n11.3.6　插入标记　　294\n11.3.7　scrollIntoView()方法　　298\n11.4　专有扩展　　298\n11.4.1　文档模式　　298\n11.4.2　children属性　　299\n11.4.3　contains()方法　　300\n11.4.4　插入文本　　301\n11.4.5　滚动　　303\n11.5　小结　　304\n第12章　DOM2和DOM3　　305\n12.1　DOM变化　　305\n12.1.1　针对XML命名空间的变化　　306\n12.1.2　其他方面的变化　　309\n12.2　样式　　312\n12.2.1　访问元素的样式　　313\n12.2.2　操作样式表　　317\n12.2.3　元素大小　　320\n12.3　遍历　　326\n12.3.1　NodeIterator　　328\n12.3.2　TreeWalker　　330\n12.4　范围　　332\n12.4.1　DOM中的范围　　332\n12.4.2　IE8及更早版本中的范围　　340\n12.5　小结　　343\n第13章　事件　　345\n13.1　事件流　　345\n13.1.1　事件冒泡　　346\n13.1.2　事件捕获　　346\n13.1.3　DOM事件流　　347\n13.2　事件处理程序　　348\n13.2.1　HTML事件处理程序　　348\n13.2.2　DOM0级事件处理程序　　350\n13.2.3　DOM2级事件处理程序　　351\n13.2.4　IE事件处理程序　　352\n13.2.5　跨浏览器的事件处理程序　　353\n13.3　事件对象　　355\n13.3.1　DOM中的事件对象　　355\n13.3.2　IE中的事件对象　　358\n13.3.3　跨浏览器的事件对象　　360\n13.4　事件类型　　362\n13.4.1　UI事件　　362\n13.4.2　焦点事件　　367\n13.4.3　鼠标与滚轮事件　　368\n13.4.4　键盘与文本事件　　379\n13.4.5　复合事件　　384\n13.4.6　变动事件　　385\n13.4.7　HTML5事件　　388\n13.4.8　设备事件　　395\n13.4.9　触摸与手势事件　　399\n13.5　内存和性能　　402\n13.5.1　事件委托　　402\n13.5.2　移除事件处理程序　　404\n13.6　模拟事件　　405\n13.6.1　DOM中的事件模拟　　405\n13.6.2　IE中的事件模拟　　410\n13.7　小结　　411\n第14章　表单脚本　　412\n14.1　表单的基础知识　　412\n14.1.1　提交表单　　413\n14.1.2　重置表单　　414\n14.1.3　表单字段　　414\n14.2　文本框脚本　　419\n14.2.1　选择文本　　420\n14.2.2　过滤输入　　423\n14.2.3　自动切换焦点　　426\n14.2.4　HTML5约束验证API　　427\n14.3　选择框脚本　　431\n14.3.1　选择选项　　432\n14.3.2　添加选项　　434\n14.3.3　移除选项　　435\n14.3.4　移动和重排选项　　435\n14.4　表单序列化　　436\n14.5　富文本编辑　　438\n14.5.1　使用contenteditable\n属性　　438\n14.5.2　操作富文本　　439\n14.5.3　富文本选区　　441\n14.5.4　表单与富文本　　443\n14.6　小结　　443\n第15章　使用Canvas绘图　　445\n15.1　基本用法　　445\n15.2　2D上下文　　446\n15.2.1　填充和描边　　446\n15.2.2　绘制矩形　　447\n15.2.3　绘制路径　　449\n15.2.4　绘制文本　　451\n15.2.5　变换　　453\n15.2.6　绘制图像　　456\n15.2.7　阴影　　457\n15.2.8　渐变　　458\n15.2.9　模式　　460\n15.2.10　使用图像数据　　460\n15.2.11　合成　　462\n15.3　WebGL　　463\n15.3.1　类型化数组　　463\n15.3.2　WebGL上下文　　468\n15.3.3　支持　　478\n15.4　小结　　478\n第16章　HTML5脚本编程　　480\n16.1　跨文档消息传递　　480\n16.2　原生拖放　　481\n16.2.1　拖放事件　　482\n16.2.2　自定义放置目标　　482\n16.2.3　dataTransfer对象　　483\n16.2.4　dropEffect与effectAllowed　　484\n16.2.5　可拖动　　485\n16.2.6　其他成员　　485\n16.3　媒体元素　　486\n16.3.1　属性　　487\n16.3.2　事件　　488\n16.3.3　自定义媒体播放器　　488\n16.3.4　检测编解码器的支持情况　　489\n16.3.5　Audio类型　　490\n16.4　历史状态管理　　491\n16.5　小结　　492\n第17章　错误处理与调试　　493\n17.1　浏览器报告的错误　　493\n17.1.1　IE　　493\n17.1.2　Firefox　　494\n17.1.3　Safari　　496\n17.1.4　Opera　　497\n17.1.5　Chrome　　498\n17.2　错误处理　　499\n17.2.1　try-catch语句　　500\n17.2.2　抛出错误　　503\n17.2.3　错误（error）事件　　505\n17.2.4　处理错误的策略　　506\n17.2.5　常见的错误类型　　507\n17.2.6　区分致命错误和非致命\n错误　　510\n17.2.7　把错误记录到服务器　　511\n17.3　调试技术　　512\n17.3.1　将消息记录到控制台　　512\n17.3.2　将消息记录到当前页面　　515\n17.3.3　抛出错误　　515\n17.4　常见的IE错误　　516\n17.4.1　操作终止　　516\n17.4.2　无效字符　　518\n17.4.3　未找到成员　　518\n17.4.4　未知运行时错误　　519\n17.4.5　语法错误　　519\n17.4.6　系统无法找到指定资源　　519\n17.5　小结　　520\n第18章　JavaScript与XML　　521\n18.1　浏览器对XML DOM的支持　　521\n18.1.1　DOM2级核心　　521\n18.1.2　DOMParser类型　　522\n18.1.3　XMLSerializer类型　　523\n18.1.4　IE8及之前版本中的XML　　523\n18.1.5　跨浏览器处理XML　　527\n18.2　浏览器对XPath的支持　　529\n18.2.1　DOM3级XPath　　529\n18.2.2　IE中的XPath　　534\n18.2.3　跨浏览器使用XPath　　535\n18.3　浏览器对XSLT的支持　　537\n18.3.1　IE中的XSLT　　537\n18.3.2　XSLTProcessor类型　　541\n18.3.3　跨浏览器使用XSLT　　543\n18.4　小结　　544\n第19章　E4X　　546\n19.1　E4X的类型　　546\n19.1.1　XML类型　　546\n19.1.2　XMLList类型　　547\n19.1.3　Namespace类型　　548\n19.1.4　QName类型　　549\n19.2　一般用法　　550\n19.2.1　访问特性　　551\n19.2.2　其他节点类型　　552\n19.2.3　查询　　553\n19.2.4　构建和操作XML　　555\n19.2.5　解析和序列化　　557\n19.2.6　命名空间　　558\n19.3　其他变化　　559\n19.4　全面启用E4X　　560\n19.5　小结　　561\n第20章　JSON　　562\n20.1　语法　　562\n20.1.1　简单值　　562\n20.1.2　对象　　563\n20.1.3　数组　　564\n20.2　解析与序列化　　565\n20.2.1　JSON对象　　565\n20.2.2　序列化选项　　566\n20.2.3　解析选项　　569\n20.3　小结　　570\n第21章　Ajax与Comet　　571\n21.1　XMLHttpRequest对象　　571\n21.1.1　XHR的用法　　573\n21.1.2　HTTP头部信息　　575\n21.1.3　GET请求　　576\n21.1.4　POST请求　　577\n21.2　XMLHttpRequest 2级　　578\n21.2.1　FormData　　578\n21.2.2　超时设定　　579\n21.2.3　overrideMimeType()\n方法　　580\n21.3　进度事件　　580\n21.3.1　load事件　　580\n21.3.2　progress事件　　581\n21.4　跨源资源共享　　582\n21.4.1　IE对CORS的实现　　582\n21.4.2　其他浏览器对CORS的\n实现　　584\n21.4.3　Preflighted Reqeusts　　584\n21.4.4　带凭据的请求　　585\n21.4.5　跨浏览器的CORS　　585\n21.5　其他跨域技术　　586\n21.5.1　图像Ping　　586\n21.5.2　JSONP　　587\n21.5.3　Comet　　588\n21.5.4　服务器发送事件　　590\n21.5.5　Web Sockets　　591\n21.5.6　SSE与Web Sockets　　593\n21.6　安全　　593\n21.7　小结　　594\n第22章　高级技巧　　596\n22.1　高级函数　　596\n22.1.1　安全的类型检测　　596\n22.1.2　作用域安全的构造函数　　597\n22.1.3　惰性载入函数　　600\n22.1.4　函数绑定　　602\n22.1.5　函数柯里化　　604\n22.2　防篡改对象　　606\n22.2.1　不可扩展对象　　606\n22.2.2　密封的对象　　607\n22.2.3　冻结的对象　　608\n22.3　高级定时器　　609\n22.3.1　重复的定时器　　610\n22.3.2　Yielding Processes　　612\n22.3.3　函数节流　　614\n22.4　自定义事件　　616\n22.5　拖放　　618\n22.5.1　修缮拖动功能　　620\n22.5.2　添加自定义事件　　622\n22.6　小结　　624\n第23章　离线应用与客户端存储　　626\n23.1　离线检测　　626\n23.2　应用缓存　　627\n23.3　数据存储　　628\n23.3.1　Cookie　　629\n23.3.2　IE用户数据　　637\n23.3.3　Web存储机制　　638\n23.3.4　IndexedDB　　643\n23.4　小结　　654\n第24章　最佳实践　　656\n24.1　可维护性　　656\n24.1.1　什么是可维护的代码　　656\n24.1.2　代码约定　　657\n24.1.3　松散耦合　　659\n24.1.4　编程实践　　662\n24.2　性能　　666\n24.2.1　注意作用域　　666\n24.2.2　选择正确方法　　667\n24.2.3　最小化语句数　　672\n24.2.4　优化DOM交互　　673\n24.3　部署　　676\n24.3.1　构建过程　　676\n24.3.2　验证　　677\n24.3.3　压缩　　679\n24.4　小结　　681\n第25章　新兴的API　　682\n25.1　requestAnimationFrame()　　682\n25.1.1　早期动画循环　　682\n25.1.2　循环间隔的问题　　683\n25.1.3　mozRequestAnimation-Frame　　683\n25.1.4　webkitRequestAnima-tionFrame与msRequest-AnimationFrame　　685\n25.2　Page Visibility API　　686\n25.3　Geolocation API　　687\n25.4　File API　　689\n25.4.1　FileReader类型　　690\n25.4.2　读取部分内容　　692\n25.4.3　对象URL　　693\n25.4.4　读取拖放的文件　　694\n25.4.5　使用XHR上传文件　　695\n25.5　Web计时　　696\n25.6　Web Workers　　697\n25.6.1　使用Worker　　697\n25.6.2　Worker全局作用域　　698\n25.6.3　包含其他脚本　　699\n25.6.4　Web Workers的未来　　700\n25.7　小结　　700\n附录A　ECMAScript Harmony　　701\n附录B　严格模式　　717\n附录C　JavaScript库　　723\n附录D　JavaScript工具　　727\n","pages":"748","images":{"small":"https://img3.doubanio.com/view/subject/s/public/s8958650.jpg","large":"https://img3.doubanio.com/view/subject/l/public/s8958650.jpg","medium":"https://img3.doubanio.com/view/subject/m/public/s8958650.jpg"},"alt":"https://book.douban.com/subject/10546125/","id":"10546125","publisher":"人民邮电出版社","isbn10":"7115275793","isbn13":"9787115275790","title":"JavaScript高级程序设计（第3版）","url":"https://api.douban.com/v2/book/10546125","alt_title":"Professional JavaScript for Web","author_intro":"作者简介：\nNicholas C. Zakas（尼古拉斯•泽卡斯）世界顶级Web技术专家，现为雅虎公司界面呈现架构师，负责My Yahoo!和雅虎首页等大访问量站点的设计。尼古拉斯拥有丰富的Web开发和界面设计经验，曾经参与许多世界级大公司的Web解决方案开发。他还是High Performance JavaScript一书的作者，并与他人合作撰写了Professional Ajax和Even Faster Web Sites。尼古拉斯拥有梅里马克学院计算机科学学士学位和埃迪柯特学院的MBA学位。他的个人网站是www.nczonline.net，他的Twitter别名是@slicknet。","summary":"本书是JavaScript 超级畅销书的最新版。ECMAScript 5 和HTML5 在标准之争中双双胜出，使大量专有实现和客户端扩展正式进入规范，同时也为JavaScript 增添了很多适应未来发展的新特性。本书这一版除增加5 章全新内容外，其他章节也有较大幅度的增补和修订，新内容篇幅约占三分之一。全书从JavaScript 语言实现的各个组成部分——语言核心、DOM、BOM、事件模型讲起，深入浅出地探讨了面向对象编程、Ajax 与Comet 服务器端通信，HTML5 表单、媒体、Canvas（包括WebGL）及Web Workers、地理定位、跨文档传递消息、客户端存储（包括IndexedDB）等新API，还介绍了离线应用和与维护、性能、部署相关的最佳开发实践。本书附录展望了未来的API 和ECMAScript Harmony 规范。\n本书适合有一定编程经验的Web 应用开发人员阅读，也可作为高校及社会实用技术培训相关专业课程的教材。","series":{"id":"660","title":"图灵程序设计丛书"},"price":"99.00元"},"9787115352460":{"rating":{"max":10,"numRaters":128,"average":"8.2","min":0},"subtitle":"","author":["[美] Mike Cantelon","[美] TJ Holowaychuk","[美] Nathan Rajlich"],"pubdate":"2014-5","tags":[{"count":137,"name":"Node.js","title":"Node.js"},{"count":71,"name":"JavaScript","title":"JavaScript"},{"count":53,"name":"nodejs","title":"nodejs"},{"count":42,"name":"node.js","title":"node.js"},{"count":41,"name":"web开发","title":"web开发"},{"count":37,"name":"前端开发","title":"前端开发"},{"count":34,"name":"编程","title":"编程"},{"count":22,"name":"node","title":"node"}],"origin_title":"Node.js in Action","image":"https://img3.doubanio.com/view/subject/m/public/s27264241.jpg","binding":"平装","translator":["吴海星"],"catalog":"第一部分　Node基础\n第1章　欢迎进入Node.js世界　　2\n1.1　构建于JavaScript之上　　3\n1.2　异步和事件触发：浏览器　　4\n1.3　异步和事件触发：服务器　　5\n1.4　DIRT程序　　6\n1.5　默认DIRT　　8\n1.5.1　简单的异步程序　　9\n1.5.2　Hello World HTTP服务器　　10\n1.5.3　流数据　　10\n1.6　小结　　11\n第2章　构建有多个房间的聊天室程序　　12\n2.1　程序概览　　12\n2.2　程序需求及初始设置　　15\n2.2.1　提供HTTP和WebSocket服务　　15\n2.2.2　创建程序的文件结构　　16\n2.2.3　指明依赖项　　16\n2.2.4　安装依赖项　　17\n2.3　提供HTML、CSS和客户端JavaScript的服务　　18\n2.3.1　创建静态文件服务器　　19\n2.3.2　添加HTML和CSS文件　　21\n2.4　用Socket.IO处理与聊天相关的消息　　23\n2.4.1　设置Socket.IO服务器　　24\n2.4.2　处理程序场景及事件　　25\n2.5　在程序的用户界面上使用客户端JavaScript　　29\n2.5.1　将消息和昵称/房间变更请求传给服务器　　29\n2.5.2　在用户界面中显示消息及可用房间　　30\n2.6　小结　　34\n第3章　Node编程基础　　35\n3.1　Node功能的组织及重用　　36\n3.1.1　创建模块　　37\n3.1.2　用module.exports微调模块的创建　　39\n3.1.3　用node_modules重用模块　　40\n3.1.4　注意事项　　41\n3.2　异步编程技术　　42\n3.2.1　用回调处理一次性事件　　43\n3.2.2　用事件发射器处理重复性事件　　46\n3.2.3　异步开发的难题　　53\n3.3　异步逻辑的顺序化　　54\n3.3.1　什么时候使用串行流程控制　　55\n3.3.2　实现串行化流程控制　　56\n3.3.3　实现并行化流程控制　　58\n3.3.4　利用社区里的工具　　60\n3.4　小结　　61\n第二部分　用Node开发Web程序\n第4章　构建Node Web程序　　64\n4.1　HTTP服务器的基础知识　　64\n4.1.1　Node如何向开发者呈现HTTP请求　　65\n4.1.2　一个用“Hello World”做响应的HTTP服务器　　67\n4.1.3　读取请求头及设定响应头　　67\n4.1.4　设定HTTP响应的状态码　　67\n4.2　构建RESTful Web服务　　68\n4.2.1　用POST请求创建资源　　69\n4.2.2　用GET请求获取资源　　71\n4.2.3　用DELETE请求移除资源　　72\n4.3　提供静态文件服务　　73\n4.3.1　创建一个静态文件服务器　　73\n4.3.2　处理服务器错误　　77\n4.3.3　用fs.stat()实现先发制人的错误处理　　77\n4.4　从表单中接受用户输入　　78\n4.4.1　处理提交的表单域　　78\n4.4.2　用formidable处理上传的文件　　81\n4.4.3　计算上传进度　　84\n4.5　用HTTPS加强程序的安全性　　85\n4.6　小结　　86\n第5章　存储Node程序中的数据　　87\n5.1　无服务器的数据存储　　88\n5.1.1　内存存储　　88\n5.1.2　基于文件的存储　　88\n5.2　关系型数据库管理系统　　91\n5.2.1　MySQL　　91\n5.2.2　PostgreSQL　　99\n5.3　NoSQL数据库　　100\n5.3.1　Redis　　101\n5.3.2　MongoDB　　105\n5.3.3　Mongoose　　107\n5.4　小结　　109\n第6章　Connect　　110\n6.1　搭建一个Connect程序　　111\n6.2　Connect的工作机制　　112\n6.2.1　做日志的中间件　　112\n6.2.2　响应“hello world”的中间件　　113\n6.3　为什么中间件的顺序很重要　　114\n6.3.1　中间件什么时候不调用next()　　114\n6.3.2　用中间件的顺序执行认证　　115\n6.4　挂载中间件和服务器　　115\n6.4.1　认证中间件　　116\n6.4.2　显示管理面板的中间件　　117\n6.5　创建可配置中间件　　118\n6.5.1　创建可配置的logger中间件组件　　119\n6.5.2　构建路由中间件组件　　120\n6.5.3　构建一个重写URL的中间件组件　　122\n6.6　使用错误处理中间件　　123\n6.6.1　Connect的默认错误处理器　　124\n6.6.2　自行处理程序错误　　124\n6.6.3　使用多个错误处理中间件组件　　125\n6.7　小结　　129\n第7章　Connect自带的中间件　　130\n7.1　解析cookie、请求主体和查询字符串的中间件　　131\n7.1.1　cookieParser()：解析HTTP cookie　　131\n7.1.2　bodyParser()：解析请求主体　　134\n7.1.3　limit()：请求主体的限制　　135\n7.1.4　query()：查询字符串解析　　137\n7.2　实现Web程序核心功能的中间件　　138\n7.2.1　logger()：记录请求　　138\n7.2.2　favicon()：提供favicon　　140\n7.2.3　methodOverride()：伪造HTTP方法　　141\n7.2.4　vhost()：虚拟主机　　143\n7.2.5　session()：会话管理　　144\n7.3　处理Web程序安全的中间件　　148\n7.3.1　basicAuth()：HTTP基本认证　　148\n7.3.2　csrf()：跨站请求伪造防护　　150\n7.3.3　errorHandler()：开发错误处理　　150\n7.4　提供静态文件服务的中间件　　152\n7.4.1　static()：静态文件服务　　152\n7.4.2　compress()：压缩静态文件　　154\n7.4.3　directory()：目录列表　　156\n7.5　小结　　157\n第8章　Express　　158\n8.1　生成程序骨架　　160\n8.1.1　安装Express的可执行程序　　161\n8.1.2　生成程序　　162\n8.1.3　探索程序　　162\n8.2　配置Express和你的程序　　164\n8.3　渲染视图　　166\n8.3.1　视图系统配置　　167\n8.3.2　视图查找　　169\n8.3.3　把数据输出到视图中　　171\n8.4　处理表单和文件上传　　175\n8.4.1　实现照片模型　　175\n8.4.2　创建照片上传表单　　176\n8.4.3　显示上传照片列表　　178\n8.5　创建资源下载　　179\n8.5.1　创建照片下载路由　　179\n8.5.2　实现照片下载路由　　180\n8.6　小结　　182\n第9章　Express进阶　　183\n9.1　认证用户　　184\n9.1.1　保存和加载用户　　184\n9.1.2　注册新用户　　189\n9.1.3　已注册用户登录　　194\n9.1.4　用户加载中间件　　197\n9.2　先进的路由技术　　199\n9.2.1　校验用户内容提交　　199\n9.2.2　特定路由中间件　　202\n9.2.3　实现分页　　205\n9.3　创建一个公开的REST API　　208\n9.3.1　设计API　　208\n9.3.2　添加基本的认证　　209\n9.3.3　实现路由　　209\n9.3.4　启用内容协商　　212\n9.4　错误处理　　214\n9.4.1　处理404错误　　215\n9.4.2　处理错误　　217\n9.5　小结　　220\n第10章　测试Node程序　　221\n10.1　单元测试　　222\n10.1.1　assert模块　　222\n10.1.2　Nodeunit　　225\n10.1.3　Mocha　　227\n10.1.4　Vows　　232\n10.1.5　should.js　　234\n10.2　验收测试　　235\n10.2.1　Tobi　　236\n10.2.2　Soda　　237\n10.3　小结　　239\n第11章　Web程序模板　　240\n11.1　用模板保持代码的整洁性　　240\n11.2　嵌入JavaScript的模板　　244\n11.2.1　创建模板　　245\n11.2.2　用EJS过滤器处理模板数据　　246\n11.2.3　将EJS集成到你的程序中　　249\n11.2.4　在客户端程序中使用EJS　　250\n11.3　使用Mustache模板语言与Hogan　　251\n11.3.1　创建模板　　251\n11.3.2　Mustache标签　　252\n11.3.3　微调Hogan　　254\n11.4　用Jade做模板　　255\n11.4.1　Jade基础知识　　256\n11.4.2　Jade模板中的逻辑　　258\n11.4.3　组织Jade模板　　260\n11.5　小结　　264\n第三部分　在Node中更进一步\n第12章　部署Node程序并维持正常运行时间　　266\n12.1　安置Node程序　　266\n12.1.1　专用的和虚拟私有服务器　　267\n12.1.2　云主机　　268\n12.2　部署的基础知识　　269\n12.2.1　从Git存储库部署　　270\n12.2.2　让Node保持运行　　270\n12.3　让正常运行时间和性能达到最优　　271\n12.3.1　用Upstart维护正常运行时间　　272\n12.3.2　集群API：利用多核的优势　　273\n12.3.3　静态文件及代理　　275\n12.4　小结　　277\n第13章　超越Web服务器　　278\n13.1　Socket.IO　　278\n13.1.1　创建一个最小的Socket.IO程序　　279\n13.1.2　用Socket.IO触发页面和CSS的重新加载　　281\n13.1.3　Socket.IO的其他用法　　283\n13.2　深入TCP/IP网络　　284\n13.2.1　处理缓冲区和二进制数据　　284\n13.2.2　创建TCP服务器　　286\n13.2.3　创建TCP客户端　　289\n13.3　跟操作系统交互的工具　　290\n13.3.1　单例的全局process对象　　291\n13.3.2　使用文件系统模块　　293\n13.3.3　繁衍外部进程　　296\n13.4　开发命令行工具　　301\n13.4.1　解析命令行参数　　301\n13.4.2　处理stdin和stdout　　302\n13.4.3　添加彩色的输出　　304\n13.5　小结　　306\n第14章　Node生态系统　　307\n14.1　给Node开发人员的在线资源　　308\n14.1.1　Node和模块的参考资料　　308\n14.1.2　Google群组　　309\n14.1.3　IRC　　309\n14.1.4　GitHub问题列表　　310\n14.2　GitHub　　310\n14.2.1　GitHub入门　　311\n14.2.2　添加一个项目到GitHub中　　312\n14.2.3　用GitHub协作　　314\n14.3　为npm库做贡献　　316\n14.3.1　准备包　　317\n14.3.2　编写包规范　　317\n14.3.3　测试和发布包　　318\n14.4　小结　　320\n附录A　安装Node和社区附加组件　　321\n附录B　调试Node　　329\n附录C　Express的扩展及配置　　336","ebook_url":"https://read.douban.com/ebook/14300777/","pages":"356","images":{"small":"https://img3.doubanio.com/view/subject/s/public/s27264241.jpg","large":"https://img3.doubanio.com/view/subject/l/public/s27264241.jpg","medium":"https://img3.doubanio.com/view/subject/m/public/s27264241.jpg"},"alt":"https://book.douban.com/subject/25870705/","id":"25870705","publisher":"人民邮电出版社","isbn10":"7115352461","isbn13":"9787115352460","title":"Node.js实战","url":"https://api.douban.com/v2/book/25870705","alt_title":"Node.js in Action","author_intro":"作者简介：\nMike Cantelon\nNode.js核心框架贡献者、Node社区活跃分子、资深培训师和演讲人。\nMarc Harter\nNode.js核心框架贡献者。\nT.J. Holowaychuk\n参与开发了很多Node.js模块，包括流行的Express框架。\nNathan Rajlich\n大名鼎鼎的TooTallNate，Node.js核心代码提交者。\n译者简介：\n吴海星\n2001年毕业于南京理工大学。编程数载代码不过几十万，翻译几年码字不过几百万。项目不过十几个，带队不到五十人。年过而立，惴惴不安，愈加发奋，孜孜求学，愿凭绵薄之力，贡献于IT社区。","summary":"服务器端JavaScript？没错。Node.js是一个JavaScript服务器，支持可伸缩的高性能Web应用。借助异步I/O，这个服务器可以同时做很多事情，能满足聊天、游戏和实时统计等应用的需求。并且既然是JavaScript，那你就可以全栈使用一种语言。\n本书向读者展示了如何构建产品级应用，对关键概念的介绍清晰明了，贴近实际的例子，涵盖从安装到部署的各个环节，是一部讲解与实践并重的优秀著作。通过学习本书，读者将深入异步编程、数据存储、输出模板、读写文件系统，掌握创建TCP/IP服务器和命令行工具等非HTTP程序的技术。本书同样非常适合熟悉Rails、Django或PHP开发的读者阅读学习。\n本书主要内容：\nNode.js及其扩展的安装配置；\n全面理解异步编程和事件循环；\n学会开发微博、聊天和游戏等热门应用。","ebook_price":"29.99","price":"69.00元"},"9787121229428":{"rating":{"max":10,"numRaters":66,"average":"8.7","min":0},"subtitle":"","author":["【美】Kouichi Matsuda,Rodger Lea（松田浩一，罗杰•李）"],"pubdate":"2014-6","tags":[{"count":59,"name":"webgl","title":"webgl"},{"count":44,"name":"WebGL","title":"WebGL"},{"count":41,"name":"3D","title":"3D"},{"count":33,"name":"前端开发","title":"前端开发"},{"count":30,"name":"JavaScript","title":"JavaScript"},{"count":18,"name":"计算机图形学","title":"计算机图形学"},{"count":17,"name":"图形学","title":"图形学"},{"count":16,"name":"计算机","title":"计算机"}],"origin_title":"","image":"https://img3.doubanio.com/view/subject/m/public/s27306770.jpg","binding":"平装","translator":["谢光磊"],"catalog":"第1 章 WebGL 概述...................... 1\nWebGL 的优势 ...........................................3\n使用文本编辑器开发三维应用 ...............3\n轻松发布三维图形程序 .................................4\n充分利用浏览器的功能 ...........................5\n学习和使用WebGL 很简单 ...................5\nWebGL 的起源 .................................................5\nWebGL 程序的结构 ...................................6\n总结 .....................................7\n第2 章 WebGL 入门.................... 9\nCanvas 是什么？ ........................................10\n使用<canvas> 标签 ................................11\nDrawRectangle.js .............................................13\n最短的WebGL 程序：清空绘图区 ....................16\nHTML 文件（HelloCanvas.html）.............................16\nJavaScript 程序（HelloCanvas.js） ............................17\n用示例程序做实验 ..............................................22\n绘制一个点（版本1） ............................................22\nHelloPoint1.html ..............................................24\nHelloPoint1.js ....................................................24\n着色器是什么？ ...........................................25\n使用着色器的WebGL 程序的结构 .................................27\n初始化着色器 ...........................................29\n顶点着色器 ......................................................31\n片元着色器 ...........................................33\n绘制操作 .............................................34\nWebGL 坐标系统 ....................................35\n用示例程序做实验 ................................37\n绘制一个点（版本2） ..............................38\n使用attribute 变量..................................38\n示例程序（HelloPoint2.js） .........................................39\n获取attribute 变量的存储位置.......................41\n向attribute 变量赋值.............................................42\ngl.vertexAttrib3f() 的同族函数 .........................44\n用示例程序做实验 ...............................45\n通过鼠标点击绘点 ...........................................46\n示例程序（ClickedPoints.js） ...........................47\n注册事件响应函数 ..................................48\n响应鼠标点击事件 ............................50\n用示例程序做实验 ..............................53\n改变点的颜色 ............................................55\n示例程序（ColoredPoints.js） ..............................56\nuniform 变量 ........................................58\n获取uniform 变量的存储地址 .....................59\n向uniform 变量赋值 .................................60\ngl.uniform4f() 的同族函数 .......................61\n总结 ............................62\n第3 章 绘制和变换三角形................ 63\n绘制多个点 ...............................................64\n示例程序（MultiPoint.js） ........................................66\n使用缓冲区对象 ....................................69\n创建缓冲区对象（gl.createBuffer()） ...................70\n绑定缓冲区（gl.bindBuffer()） .....................................71\n向缓冲区对象中写入数据（gl.bufferData()）..............72\n类型化数组 ........................................74\n将缓冲区对象分配给attribute 变量（gl.vertexAttribPointer()） ...............75\n开启attribute 变量（gl.enableVertexAttribArray()） ................77\ngl.drawArrays() 的第2 个和第3 个参数 .................78\n用示例程序做实验 ........................................79\nHello Triangle ..................................80\n示例程序（HelloTriangle.js） .........................80\n基本图形 .................................................82\n用示例程序做实验 ...........................83\nHello Rectangle（HelloQuad） ...........................84\n用示例程序做实验 ...................................85\n移动、旋转和缩放 ........................................86\n平移 ................................................87\n示例程序（TranslatedTriangle.js） ...........................88\n旋转 ...........................................................91\n示例程序（RotatedTriangle.js） ..................................93\n变换矩阵：旋转 ........................................97\n变换矩阵：平移 ...................................100\n4×4 的旋转矩阵 ..................................101\n示例程序（RotatedTriangle_Matrix.js） ...................102\n平移：相同的策略 ................................105\n变换矩阵：缩放 ...............................106\n总结 ...........................................................108\n第4 章 高级变换与动画基础.............................. 109\n平移，然后旋转 ...........................................109\n矩阵变换库：cuon-matrix.js ....................110\n示例程序（RotatedTriangle_Matrix4.js） ............... 111\n复合变换 .............................................113\n示例程序（RotatedTranslatedTriangle.js）.....................115\n用示例程序做实验 ..................................117\n动画 .....................................118\n动画基础 .........................................119\n示例程序（RotatingTriangle.js） .......................119\n反复调用绘制函数（tick()） ............................123\n按照指定的旋转角度绘制三角形（draw()） .............123\n请求再次被调用（requestAnimationFrame()） ............125\n更新旋转角（animate()）................................126\n用示例程序做实验 ............................128\n总结 .....................................................130\n第5 章 颜色与纹理.............. 131\n将非坐标数据传入顶点着色器 ................131\n示例程序（MultiAttributeSize.js） .....................133\n创建多个缓冲区对象 .........................134\ngl.vertexAttribPointer() 的步进和偏移参数 ...............135\n示例程序（MultiAttributeSize_Interleaved.js） ...................136\n修改颜色（varying 变量） .......................140\n示例程序（MultiAttributeColor.js） .........................141\n用示例程序做实验 .........................144\n彩色三角形（ColoredTriangle.js） ............................145\n几何形状的装配和光栅化 ................145\n调用片元着色器 ............................149\n用示例程序做实验 ..................................149\nvarying 变量的作用和内插过程 ..............151\n在矩形表面贴上图像 ...........................................153\n纹理坐标 ...................................................156\n将纹理图像粘贴到几何图形上 .....................156\n示例程序（TexturedQuad.js） ...............................157\n设置纹理坐标（initVertexBuffers()）......................160\n配置和加载纹理（initTextures()） ..................160\n为WebGL 配置纹理（loadTexture()） .............164\n图像Y 轴反转 .................................164\n激活纹理单元（gl.activeTexture()） ..................165\n绑定纹理对象（gl.bindTexture()） ..................166\n配置纹理对象的参数（gl.texParameteri()） .........168\n将纹理图像分配给纹理对象（gl.texImage2D()） .....171\n将纹理单元传递给片元着色器（gl.uniform1i()） .........173\n从顶点着色器向片元着色器传输纹理坐标 .......................174\n在片元着色器中获取纹理像素颜色（texture2D()） ..................174\n用示例程序做试验 ............................175\n使用多幅纹理 ...............................................177\n示例程序（MultiTexture.js） ............................178\n总结 .......................................................183\n第6 章 OpenGL ES 着色器语言（GLSL ES）.............. 185\n回顾：基本着色器代码 ...............................186\nGLSL ES 概述 .............................................186\n你好，着色器！ ...................................................187\n基础 ......................187\n执行次序 .........................................187\n注释 ..................................................187\n数据值类型（数值和布尔值） ......................188\n变量 .........................................................188\nGLSL ES 是强类型语言 ........................189\n基本类型 ....................................................189\n赋值和类型转换 .........................190\n运算符 ............................................191\n矢量和矩阵 .........................................192\n赋值和构造 ...............................193\n访问元素 .........................................195\n运算符 ............................................197\n结构体 .....................................................200\n赋值和构造 ...................................200\n访问成员 ...............................................200\n运算符 ...........................................201\n数组 ..........................................................201\n取样器（纹理） ........................................202\n运算符优先级 ..........................................203\n程序流程控制：分支和循环 .......................203\nif 语句和if-else 语句 ............................203\nfor 语句 .......................................204\ncontinue、break 和discard 语句 ................205\n函数 ..........................................205\n规范声明 ........................................207\n参数限定词 ........................................207\n内置函数 .................................................208\n全局变量和局部变量 ..............................209\n存储限定字 ...........................................209\nconst 变量 .....................................209\nAttribute 变量 ..............................210\nuniform 变量 ..................................211\nvarying 变量 ..................................211\n精度限定字 ..............................................211\n预处理指令 .............................................213\n总结 ......................................................215\n第7 章 进入三维世界................ 217\n立方体由三角形构成 .............................217\n视点和视线 ...........................................218\n视点、观察目标点和上方向 ........... 219\n示例程序（LookAtTriangles.js） ...........................221\nLookAtTriangles.js 与RotatedTriangle_Matrix4.js ..........224\n从指定视点观察旋转后的三角形 .....................225\n示例程序（LookAtRotatedTriangles.js） ...................227\n用示例程序做实验 .................................228\n利用键盘改变视点 .............................230\n示例程序（LookAtTrianglesWithKeys.js） .................230\n独缺一角 ......................................232\n可视范围（正射类型） .............................233\n可视空间 ..................................................234\n定义盒状可视空间 ................................235\n示例程序（OrthoView.html） ........................236\n示例程序（OrthoView.js） ...............................237\nJavaScript 修改HTML 元素 ..........................239\n顶点着色器的执行流程 ............................239\n修改near 和far 值 .............................241\n补上缺掉的角（LookAtTrianglesWithKeys_ViewVolume.js） ..........243\n用示例程序做实验 ................................245\n可视空间（透视投影） ....................................246\n定义透视投影可视空间 .......................247\n示例程序（perspectiveview.js） .........................249\n投影矩阵的作用 ...................................251\n共冶一炉（模型矩阵、视图矩阵和投影矩阵） .............252\n示例程序（PerspectiveView_mvp.js） ........................254\n用示例程序做实验 ................................257\n正确处理对象的前后关系 ............................258\n隐藏面消除 .....................................260\n示例程序（DepthBuffer.js）..............................262\n深度冲突 ................................................263\n立方体 ...........................................................266\n通过顶点索引绘制物体 ....................268\n示例程序（HelloCube.js） ...........................268\n向缓冲区中写入顶点的坐标、颜色与索引 ....................271\n为立方体的每个表面指定颜色 .............274\n示例程序（ColoredCube.js） ............................275\n用示例程序做实验 ............................277\n总结 ..............................................279\n第8 章 光照......... 281\n光照原理 ....................................................281\n光源类型 .......................................283\n反射类型 ............................................284\n平行光下的漫反射 ............................286\n根据光线和表面的方向计算入射角 .................287\n法线：表面的朝向 .............................288\n示例程序（LightedCube.js） ..........................291\n环境光下的漫反射 ...................................296\n示例程序（LightedCube_ambient.js） .........................298\n运动物体的光照效果 .....................................299\n魔法矩阵：逆转置矩阵 .....................301\n示例程序（LightedTranslatedRotatedCube.js） .....................302\n点光源光 ............................................304\n示例程序（PointLightedCube.js） ...............305\n更逼真：逐片元光照 ......................................308\n示例程序（PointLightedCube_perFragment.js） ........309\n总结 ............................310\n第9 章 层次模型.......... 311\n多个简单模型组成的复杂模型 .....................311\n层次结构模型 ..................................313\n单关节模型 ......................................314\n示例程序（JointMode.js） ................................315\n绘制层次模型（draw()） .....................319\n多节点模型 ..........................................321\n示例程序（MultiJointModel.js） .........................323\n绘制部件（drawBox()）............................326\n绘制部件（drawSegments()） .......................327\n着色器和着色器程序对象：initShaders() 函数的作用 .................332\n创建���色器对象（gl.createShader()） ..................333\n指定着色器对象的代码（gl.shaderSource()） ................334\n编译着色器（gl.compileShader()） ...............334\n创建程序对象（gl.createProgram()） ..............................336\n为程序对象分配着色器对象（gl.attachShader()） .............337\n连接程序对象（gl.linkProgram()） ..........................337\n告知WebGL 系统所使用的程序对象（gl.useProgram()） ................339\ninitShaders() 函数的内部流程 .....................................339\n总结 ...........................................................342\n第10 章 高级技术......................... 343\n用鼠标控制物体旋转 .......................................343\n如何实现物体旋转 ......................................344\n示例程序（RotateObject.js） .......................344\n选中物体 ........................................347\n如何实现选中物体 .........................................347\n示例程序（PickObject.js） .................................348\n选中一个表面 ......................................351\n示例程序（PickFace.js）...................................352\nHUD（平视显示器） .................................355\n如何实现HUD ...................................355\n示例程序（HUD.html） ..............................356\n示例程序（HUD.js）...................................357\n在网页上方显示三维物体 ....................359\n雾化（大气效果） ...................................359\n如何实现雾化 ....................................360\n示例程序（Fog.js） .....................................361\n使用w 分量（Fog_w.js） ...............................363\n绘制圆形的点 .................................................364\n如何实现圆形的点 ......................................364\n示例程序（RoundedPoint.js） ...............................366\nα 混合 .............................................367\n如何实现α 混合 .....................................367\n示例程序（LookAtBlendedTriangles.js） .................369\n混合函数 .....................................................369\n半透明的三维物体（BlendedCube.js）................371\n透明与不透明物体共存 .........................372\n切换着色器 ............................373\n如何实现切换着色器 .....................................374\n示例程序（ProgramObject.js） ............................375\n渲染到纹理 .......................................................379\n帧缓冲区对象和渲染缓冲区对象 ....................380\n如何实现渲染到纹理 ...............................381\n示例程序（FramebufferObject.js） ........................382\n创建帧缓冲区对象（gl.createFramebuffer()） ............385\n创建纹理对象并设置其尺寸和参数 ....................385\n创建渲染缓冲区对象（gl.createRenderbuffer()） ...........386\n绑定渲染缓冲区并设置其尺寸（gl.bindRenderbuffer()，\ngl.renderbufferStorage()） ......................................386\n将纹理对象关联到帧缓冲区对象（gl.bindFramebuffer()，\ngl.framebufferTexture2D()） ................................388\n将渲染缓冲区对象关联到帧缓冲区对象（gl.framebufferRenderbuffer()） ...389\n检查帧缓冲区的配置（gl.checkFramebufferStatus()） ..........390\n在帧缓冲区进行绘图 ........................390\n绘制阴影 ..................................................392\n如何实现阴影 ................................392\n示例程序（Shadow.js） ...........................393\n提高精度 ........................................399\n示例程序（Shadow_highp.js） .........................400\n加载三维模型 .....................................401\nOBJ 文件格式 ....................................404\nMTL 文件格式 ...............................405\n示例程序（OBJViewer.js） ........................406\n自定义类型对象 ..................................409\n示例程序（OBJViewer.js 解析数据部分） .........411\n响应上下文丢失 .....................................418\n如何响应上下文丢失 ....................419\n示例程序（RotatingTriangle_contextLost.js） ................420\n总结 .............................................................422\n附录A WebGL 中无须交换缓冲区....................... 423\n附录B GLSL ES 1.0 内置函数..................... 427\n角度和三角函数 .....................................428\n指数函数 ...............................................429\n通用函数 ...................................................430\n几何函数 ...................................................433\n矩阵函数 ....................................................434\n矢量函数 .......................................................435\n纹理查询函数 ...........................................436\n附录C 投影矩阵....................... 437\n正射投影矩阵 ........................................................437\n透视投影矩阵 ......................................437\n附录D WebGL/OpenGL ：左手还是右手坐标系？............................ 439\n示例程序(CoordinateSystem.js) .............................440\n隐藏面消除和裁剪坐标系统 ......................................443\n裁剪坐标系和可视空间 ....................................444\n什么是对的？ .................................................446\n总结 .....................................448\n附录E 逆转置矩阵................... 449\n附录F 从文件中加载着色器............ 453\n附录G 世界坐标系和本地坐标系........... 457\n本地坐标系 ......................................................458\n世界坐标系 ...........................459\n变换与坐标系 ..........................................461\n附录H WebGL 的浏览器设置.................. 463","pages":"500","images":{"small":"https://img3.doubanio.com/view/subject/s/public/s27306770.jpg","large":"https://img3.doubanio.com/view/subject/l/public/s27306770.jpg","medium":"https://img3.doubanio.com/view/subject/m/public/s27306770.jpg"},"alt":"https://book.douban.com/subject/25909351/","id":"25909351","publisher":"电子工业出版社","isbn10":"7121229420","isbn13":"9787121229428","title":"WebGL编程指南","url":"https://api.douban.com/v2/book/25909351","alt_title":"","author_intro":"关于作者\nKouichi Matsuda 博士是多媒体产品用户界面和用户体验设计方面的专家。他先后供职于日本电气(NEC)、索尼(Sony) 研发中心、索尼(Sony) 计算机科学实验室，曾经做过产品研发，也做过科学研究，最终回到产品研发的岗位。目前，他是用户体验和人机交互领域的首席研究员，负责多款消费类电子产品的设计。他曾经设计了社交三维虚拟世界“PAW”，也曾经参与过VRML97(ISO/IEC 14772-1:1997) 标准的开发工作，在VRML和X3D(WebGL 的前身) 社区中仍然非常活跃。他撰写过15 本计算机技术的书籍，并翻译过25 本相关书籍。他专长于用户体验、用户界面、人机交互、自然语言处理和面向娱乐的网络设备，以及接口代理系统等领域。他不仅对技术领域的新鲜事物充满热情，还热衷于温泉、夏季的海滩、红酒和漫画（为此他已经沉迷于绘制插画一段时间了）。他在东京大学工程系获得了博士学位，你可以通过WebGL.prog.guide@gmail.com 联系他。\nRodger Lea 博士是卑诗大学媒体与图像跨学科中心的兼职教授，对多媒体和分布式计算等领域很感兴趣。他和他带领的研究小组在学术和工业领域耕耘超过20 年，参与制定了VRML97 标准，开发了多媒体操作系统、可交互数字电视原型，并领导了家用多媒体网络标准的制定工作。他发表了60 多篇学术论文，著有3 本技术书籍，并拥有12 项专利。目前，他的研究集中在探索发展中的互联网，但他仍然对有关多媒体和图形学的一切抱有热情。\n关于译者\n谢光磊，毕业于南京大学，目前为中科院在读硕士，即将成为淘宝UED 的一名前端工程师。因一次偶然的机会接触WebGL 而对其萌生兴趣，并愿意持久深入地研究这项技术。个人站点为 www.xieguanglei.com。","summary":"WebGL 是一项在网页上渲染三维图形的技术，也是HTML5 草案的一部分。\n《WebGL编程指南》的主要篇幅讲解了WebGL 原生API 和三维图形学的基础知识，包括渲染管线、着色器、矩阵变换、着色器编程语言（GLSL ES）等等，也讲解了使用WebGL 渲染三维场景的一般技巧，如光照、阴影、雾化等等。《WebGL编程指南》提供了丰富的示例程序供读者钻研，也提供了极具价值的附录供读者参考。\n《WebGL编程指南》适合有一定前端开发基础，希望学习WebGL，但对三维图形学缺乏了解的程序员们阅读。","price":"98.00元"},"9787115349101":{"rating":{"max":10,"numRaters":251,"average":"8.8","min":0},"subtitle":"","author":["Ilya Grigorik"],"pubdate":"2013-9","tags":[{"count":258,"name":"Web开发","title":"Web开发"},{"count":203,"name":"性能","title":"性能"},{"count":143,"name":"性能优化","title":"性能优化"},{"count":138,"name":"Web","title":"Web"},{"count":94,"name":"计算机","title":"计算机"},{"count":67,"name":"互联网","title":"互联网"},{"count":54,"name":"前端开发","title":"前端开发"},{"count":41,"name":"编程","title":"编程"}],"origin_title":"High Performance Browser Networking","image":"https://img1.doubanio.com/view/subject/m/public/s27249387.jpg","binding":"平装","translator":["李松峰"],"catalog":"版权声明\nSteve Souders推荐序\n前言\n第一部分：网络技术概览\n第1章 延迟与带宽\n第2章 TCP的构成\n第3章 UDP的构成\n第4章 传输层安全（TLS）\n第二部分：无线网络性能\n第5章 无线网络概览\n第6章 Wi-Fi\n第7章 移动网络\n第8章 移动网络的优化建议\n第三部分：HTTP\n第9章 HTTP简史\n第10章 Web性能要点\n第11章 HTTP 1.x\n第12章 HTTP 2.0\n第13章 优化应用的交付\n第四部分 浏览器API与协议\n第14章 浏览器网络概述\n第15章 XMLHttpRequest\n第16章 服务器发送事件\n第17章 WebSocket\n第18章 WebRTC\n关于封面","ebook_url":"https://read.douban.com/ebook/12055070/","pages":"336","images":{"small":"https://img1.doubanio.com/view/subject/s/public/s27249387.jpg","large":"https://img1.doubanio.com/view/subject/l/public/s27249387.jpg","medium":"https://img1.doubanio.com/view/subject/m/public/s27249387.jpg"},"alt":"https://book.douban.com/subject/25856314/","id":"25856314","publisher":"人民邮电出版社","isbn10":"711534910X","isbn13":"9787115349101","title":"Web性能权威指南","url":"https://api.douban.com/v2/book/25856314","alt_title":"High Performance Browser Networking","author_intro":"作者简介：\nIlya Grigorik\n是谷歌“Web加速”（Make The Web Fast）团队的性能工程师、开发大使。他每天的主要工作就是琢磨怎么让Web应用速度更快，总结并推广能够提升应用性能的最佳实践。\n在专注于研究Web性能之前，Ilya创办了PostRank公司并担任CTO，这是一家社交分析公司。他的这家公司被谷歌收购后，成为了Google Analytics中社交分析报告模块的核心。除了研究Web性能和分析，Ilya还会为开源项目做做贡献、看看书，或者写一些好玩的项目，比如VimGolf、GitHub Archive等。\n译者简介：\n李松峰\n2006年起投身翻译，出版过译著30余部，包括《JavaScript高级程序设计》、《简约至上》等畅销书。2008年进入出版业，从事技术图书编辑和审稿工作。\n2007年创立知识分享网站“为之漫笔”（cn-cuckoo.com），翻译了大量国外经典技术文章。2012年下半年创立“A List Apart中文版”站点（alistapart.cn），旨在向中文读者译介这一国际顶级Web设计与开发杂志。他经常参加技术社区活动，曾在W3ctech 2012 Mobile上分享“Dive into Responsive Web Design”。2013年1月应邀在金山网络分享“响应式Web设计”，2013年3月应邀在奇虎360分享“JS的国”。","summary":"本书是谷歌公司高性能团队核心成员的权威之作，堪称实战经验与规范解读完美结合的产物。本书目标是涵盖Web 开发者技术体系中应该掌握的所有网络及性能优化知识。全书以性能优化为主线，从TCP、UDP 和TLS 协议讲起，解释了如何针对这几种协议和基础设施来优化应用。然后深入探讨了无线和移动网络的工作机制。最后，揭示了HTTP 协议的底层细节，同时详细介绍了HTTP 2.0、 XHR、SSE、WebSocket、WebRTC 和DataChannel 等现代浏览器新增的具有革命性的新能力。\n本书适合所有Web 应用及站点开发人员阅读，包括但不限于前端、后端、运维、大数据分析、\nUI/UX、存储、视频、实时消息，以及性能工程师。\nIlya Grigorik 是谷歌“Web加速”（Make The Web Fast）团队的性能工程师、开发大使。他每天的主要工作就是琢磨怎么让Web应用速度更快，总结并推广能够提升应用性能的最佳实践。","ebook_price":"29.99","price":"69"},"9787115385734":{"rating":{"max":10,"numRaters":557,"average":"9.4","min":0},"subtitle":"","author":["[美] Kyle Simpson"],"pubdate":"2015-4","tags":[{"count":641,"name":"JavaScript","title":"JavaScript"},{"count":296,"name":"前端开发","title":"前端开发"},{"count":175,"name":"javascript","title":"javascript"},{"count":147,"name":"编程","title":"编程"},{"count":145,"name":"前端","title":"前端"},{"count":127,"name":"Web前端开发","title":"Web前端开发"},{"count":120,"name":"计算机","title":"计算机"},{"count":78,"name":"Web","title":"Web"}],"origin_title":"","image":"https://img3.doubanio.com/view/subject/m/public/s28033372.jpg","binding":"平装","translator":["赵望野","梁杰"],"catalog":"前言　　VIII\n第一部分　作用域和闭包\n序　　2\n第1章　作用域是什么　　4\n1.1　编译原理　　4\n1.2　理解作用域　　6\n1.2.1　演员表　　6\n1.2.2　对话　　6\n1.2.3　编译器有话说　　7\n1.2.4　引擎和作用域的对话　　9\n1.2.5　小测验　　10\n1.3　作用域嵌套　　10\n1.4　异常　　12\n1.5　小结　　12\n第2章　词法作用域　　14\n2.1　词法阶段　　14\n2.2　欺骗词法　　17\n2.2.1　eval　　17\n2.2.2　with　　18\n2.2.3　性能　　20\n2.3　小结　　21\n第3章　函数作用域和块作用域　　22\n3.1　函数中的作用域　　22\n3.2　隐藏内部实现　　23\n3.3　函数作用域　　26\n3.3.1　匿名和具名　　27\n3.3.2　立即执行函数表达式　　28\n3.4　块作用域　　30\n3.4.1　with　　31\n3.4.2　try/catch　　31\n3.4.3　let　　32\n3.4.4　const　　35\n3.5　小结　　36\n第4章　提升　　37\n4.1　先有鸡还是先有蛋　　37\n4.2　编译器再度来袭　　38\n4.3　函数优先　　40\n4.4　小结　　41\n第5章　作用域闭包　　43\n5.1　启示　　43\n5.2　实质问题　　44\n5.3　现在我懂了　　47\n5.4　循环和闭包　　48\n5.5　模块　　51\n5.5.1　现代的模块机制　　54\n5.5.2　未来的模块机制　　56\n5.6　小结　　57\n附录A　动态作用域　　58\n附录B　块作用域的替代方案　　60\n附录C　this词法　　64\n附录D　致谢　　67\n第二部分　this和对象原型\n序　　72\n第1章　关于this　　74\n1.1　为什么要用this　　74\n1.2　误解　　76\n1.2.1　指向自身　　76\n1.2.2　它的作用域　　79\n1.3　this到底是什么　　80\n1.4　小结　　80\n第2章　this全面解析　　82\n2.1　调用位置　　82\n2.2　绑定规则　　83\n2.2.1　默认绑定　　83\n2.2.2　隐式绑定　　85\n2.2.3　显式绑定　　87\n2.2.4　new绑定　　90\n2.3　优先级　　91\n2.4　绑定例外　　95\n2.4.1　被忽略的this　　96\n2.4.2　间接引用　　97\n2.4.3　软绑定　　98\n2.5　this词法　　99\n2.6　小结　　101\n第3章　对象　　102\n3.1　语法　　102\n3.2　类型　　103\n3.3　内容　　105\n3.3.1　可计算属性名　　106\n3.3.2　属性与方法　　107\n3.3.3　数组　　108\n3.3.4　复制对象　　109\n3.3.5　属性描述符　　111\n3.3.6　不变性　　114\n3.3.7　[[Get]]　　115\n3.3.8　[[Put]]　　116\n3.3.9　Getter和Setter　　117\n3.3.10　存在性　　119\n3.4　遍历　　121\n3.5　小结　　124\n第4章　混合对象“类”　　126\n4.1　类理论　　126\n4.1.1　“类”设计模式　　127\n4.1.2　JavaScript中的“类”　　128\n4.2　类的机制　　128\n4.2.1　建造　　128\n4.2.2　构造函数　　130\n4.3　类的继承　　130\n4.3.1　多态　　132\n4.3.2　多重继承　　134\n4.4　混入　　134\n4.4.1　显式混入　　135\n4.4.2　隐式混入　　139\n4.5　小结　　140\n第5章　原型　　142\n5.1　[[Prototype]]　　142\n5.1.1　Object.prototype　　144\n5.1.2　属性设置和屏蔽　　144\n5.2　“类”　　146\n5.2.1　“类”函数　　146\n5.2.2　“构造函数”　　149\n5.2.3　技术　　151\n5.3　（原型）继承　　153\n5.4　对象关联　　159\n5.4.1　创建关联　　159\n5.4.2　关联关系是备用　　161\n5.5　小结　　162\n第6章　行为委托　　164\n6.1　面向委托的设计　　165\n6.1.1　类理论　　165\n6.1.2　委托理论　　166\n6.1.3　比较思维模型　　170\n6.2　类与对象　　173\n6.2.1　控件“类”　　174\n6.2.2　委托控件对象　　176\n6.3　更简洁的设计　　178\n6.4　更好的语法　　182\n6.5　内省　　185\n6.6　小结　　187\n附录A　ES6中的Class　　189","ebook_url":"https://read.douban.com/ebook/12051836/","pages":"195","images":{"small":"https://img3.doubanio.com/view/subject/s/public/s28033372.jpg","large":"https://img3.doubanio.com/view/subject/l/public/s28033372.jpg","medium":"https://img3.doubanio.com/view/subject/m/public/s28033372.jpg"},"alt":"https://book.douban.com/subject/26351021/","id":"26351021","publisher":"人民邮电出版社","isbn10":"7115385734","isbn13":"9787115385734","title":"你不知道的JavaScript（上卷）","url":"https://api.douban.com/v2/book/26351021","alt_title":"","author_intro":"作者简介：\nKyle Simpson\n推崇开放的互联网，对JavaScript、HTML5、实时/端对端通信和Web性能有深入研究。他是技术书作家、技术培训师、讲师和开源社区的活跃成员。\n译者简介：\n赵望野\n前端工程师，前端基础技术组leader，曾经负责豌豆荚2.0的前端架构设计和主要开发工作，目前负责Front-end Technical Infrastructure的建设。新浪微博@赵望野。负责本书第一部分“作用域和闭包”的翻译。\n梁杰\n北京航空航天大学计算机科学与技术专业大四学生。热爱JavaScript、Python，热爱开源，喜欢做各种各样有趣的事情。负责本书第二部分“this和对象原型”的翻译。","summary":"JavaScript语言有很多复杂的概念，但却用简单的方式体现出来（比如回调函数），因此，JavaScript开发者无需理解语言内部的原理，就能编写出功能全面的程序；就像收音机一样，你无需理解里面的管子和线圈都是做什么用的，只要会操作收音机上的按键，就可以收听你喜欢的节目。然而，JavaScript的这些复杂精妙的概念才是语言的精髓，即使是经验丰富的JavaScript开发者，如果没有认真学习也无法真正理解语言本身的特性。正是因为绝大多数人不求甚解，一遇到出乎意料的行为就认为是语言本身有缺陷，进而把相关的特性加入黑名单，久而久之就排除了这门语言的多样性，人为地使它变得不完整、不安全。\n“你不知道的JavaScript”系列就是要让不求甚解的JavaScript开发者迎难而上，深入语言内部，弄清楚JavaScript每一个零部件的用途。本书介绍了该系列的两个主题：“作用域和闭包”以及“this和对象原型”。掌握了这些知识之后，无论什么技术、框架和流行词语，你都能轻松理解。","ebook_price":"24.99","series":{"id":"40642","title":"你不知道的JavaScript"},"price":"49.00元"},"9787115431165":{"rating":{"max":10,"numRaters":182,"average":"9.0","min":0},"subtitle":"","author":["[美] Kyle Simpson"],"pubdate":"2016-8","tags":[{"count":178,"name":"JavaScript","title":"JavaScript"},{"count":84,"name":"前端开发","title":"前端开发"},{"count":57,"name":"javascript","title":"javascript"},{"count":49,"name":"Web前端开发","title":"Web前端开发"},{"count":46,"name":"前端","title":"前端"},{"count":35,"name":"编程","title":"编程"},{"count":28,"name":"计算机","title":"计算机"},{"count":16,"name":"技术","title":"技术"}],"origin_title":"","image":"https://img3.doubanio.com/view/subject/m/public/s28969600.jpg","binding":"平装","translator":["单业","姜南"],"catalog":"前言 XI\n第一部分　类型和语法\n序　　2\n第1章 　类型　　3\n1.1　类型　　4\n1.2　内置类型　　4\n1.3　值和类型　　6\n1.3.1　undefined 和undeclared　　6\n1.3.2　typeof Undeclared　　7\n1.4　小结　　10\n第2章　值　　11\n2.1　数组　　11\n2.2　字符串　　13\n2.3　数字　　15\n2.3.1　数字的语法　　16\n2.3.2　较小的数值　　18\n2.3.3　整数的安全范围　　19\n2.3.4　整数检测　　20\n2.3.5　32 位有符号整数　　20\n2.4　特殊数值　　21\n2.4.1　不是值的值　　21\n2.4.2　undefined　　21\n2.4.3　特殊的数字　　23\n2.4.4　特殊等式　　27\n2.5　值和引用　　28\n2.6　小结　　31\n第3章　原生函数　　33\n3.1　内部属性[[Class]]　　34\n3.2　封装对象包装　　35\n3.3　拆封　　36\n3.4　原生函数作为构造函数　　37\n3.4.1　Array(..)　　37\n3.4.2　Object(..)、Function(..) 和RegExp(..)　　40\n3.4.3　Date(..) 和Error(..)　　41\n3.4.4　Symbol(..)　　42\n3.4.5　原生原型　　43\n3.5　小结　　45\n第4章　强制类型转换　　46\n4.1　值类型转换　　46\n4.2　抽象值操作　　47\n4.2.1　ToString　　48\n4.2.2　ToNumber　　52\n4.2.3　ToBoolean　　53\n4.3　显式强制类型转换　　56\n4.3.1　字符串和数字之间的显式转换　　57\n4.3.2　显式解析数字字符串　　62\n4.3.3　显式转换为布尔值　　65\n4.4　隐式强制类型转换　　67\n4.4.1　隐式地简化　　67\n4.4.2　字符串和数字之间的隐式强制类型转换　　68\n4.4.3　布尔值到数字的隐式强制类型转换　　71\n4.4.4　隐式强制类型转换为布尔值　　72\n4.4.5　|| 和&&　　73\n4.4.6　符号的强制类型转换　　76\n4.5　宽松相等和严格相等　　77\n4.5.1　相等比较操作的性能　　77\n4.5.2　抽象相等\n4.6　抽象关系比较　　89\n4.7　小结　　91\n第5章　语法　　92\n5.1　语句和表达式　　92\n5.1.1　语句的结果值　　93\n5.1.2　表达式的副作用　　95\n5.1.3　上下文规则　　99\n5.2　运算符优先级　　104\n5.2.1　短路　　107\n5.2.2　更强的绑定　　107\n5.2.3　关联　　108\n5.2.4　释疑　　110\n5.3　自动分号　　111\n5.4　错误　　113\n5.5　函数参数　　115\n5.6　try..finally　　117\n5.7　switch　　120\n5.8　小结　　122\n附录A　混合环境JavaScript　　123\n第二部分　异步和性能\n序　　136\n第1章　异步：现在与将来　　138\n1.1　分块的程序　　139\n1.2　事件循环　　141\n1.3　并行线程　　143\n1.4　并发　　148\n1.4.1　非交互　　150\n1.4.2　交互　　150\n1.4.3　协作　　154\n1.5　任务　　156\n1.6　语句顺序　　157\n1.7　小结　　159\n第2章　回调　　161\n2.1　continuation　　162\n2.2　顺序的大脑　　163\n2.2.1　执行与计划　　164\n2.2.2　嵌套回调与链式回调　　165\n2.3　信任问题　　169\n2.3.1　五个回调的故事　　170\n2.3.2　不只是别人的代码　　171\n2.4　省点回调　　173\n2.5　小结　　176\n第3章　Promise　　178\n3.1　什么是Promise　　179\n3.1.1　未来值　　179\n3.1.2　完成事件　　183\n3.2　具有then 方法的鸭子类型　　188\n3.3　Promise 信任问题　　190\n3.3.1　调用过早　　190\n3.3.2　调用过晚　　191\n3.3.3　回调未调用　　192\n3.3.4　调用次数过少或过多　　193\n3.3.5　未能传递参数/ 环境值　　193\n3.3.6　吞掉错误或异常　　194\n3.3.7　是可信任的Promise 吗　　195\n3.3.8　建立信任　　197\n3.4　链式流　　198\n3.5　错误处理　　206\n3.5.1　绝望的陷阱　　208\n3.5.2　处理未捕获的情况　　209\n3.5.3　成功的坑　　211\n3.6　Promise 模式　　212\n3.6.1　Promise.all([ .. ])　　212\n3.6.2　Promise.race([ .. ])　　213\n3.6.3　all([ .. ]) 和race([ .. ]) 的变体　　216\n3.6.4　并发迭代　　217\n3.7　Promise API 概述　　219\n3.7.1　new Promise(..) 构造器　　219\n3.7.2　Promise.resolve(..) 和Promise.reject(..)　　219\n3.7.3　then(..) 和catch(..)　　220\n3.7.4　Promise.all([ .. ]) 和Promise.race([ .. ])　　221\n3.8　Promise 局限性　　222\n3.8.1　顺序错误处理　　222\n3.8.2　单一值　　223\n3.8.3　单决议　　225\n3.8.4　惯性　　227\n3.8.5　无法取消的Promise　　230\n3.8.6　Promise 性能　　231\n3.9　小结　　233\n第4章　生成器　　234\n4.1　打破完整运行　　234\n4.1.1　输入和输出　　236\n4.1.2　多个迭代器　　239\n4.2　生成器产生值　　243\n4.2.1　生产者与迭代器　　243\n4.2.2　iterable　　246\n4.2.3　生成器迭代器　　247\n4.3　异步迭代生成器　　250\n4.4　生成器+Promise　　254\n4.4.1　支持Promise 的Generator Runner　　256\n4.4.2　生成器中的Promise 并发　　258\n4.5　生成器委托　　262\n4.5.1　为什么用委托　　264\n4.5.2　消息委托　　264\n4.5.3　异步委托　　268\n4.5.4　递归委托　　268\n4.6　生成器并发　　269\n4.7　形实转换程序　　273\n4.8　ES6 之前的生成器　　279\n4.8.1　手工变换　　280\n4.8.2　自动转换　　284\n4.9　小结　　285\n第5章　程序性能　　287\n5.1　Web Worker　　288\n5.1.1　Worker 环境　　290\n5.1.2　数据传递　　291\n5.1.3　共享Worker　　291\n5.1.4　模拟Web Worker　　293\n5.2　SIMD　　293\n5.3　asm.js　　295\n5.3.1　如何使用asm.js 优化　　295\n5.3.2　asm.js 模块　　296\n5.4　小结　　298\n第6章　性能测试与调优　　299\n6.1　性能测试　　99\n6.1.1　重复　　300\n6.1.2　Benchmark.js　　301\n6.2　环境为王　　303\n6.3　jsPerf.com　　305\n6.4　写好测试　　309\n6.5　微性能　　309\n6.5.1　不是所有的引擎都类似　　312\n6.5.2　大局　　314\n6.6　尾调用优化　　316\n6.7　小结　　318\n附录A　asynquence 库　　319\n附录B　高级异步模式　　339","ebook_url":"https://read.douban.com/ebook/52186338/","pages":"358","images":{"small":"https://img3.doubanio.com/view/subject/s/public/s28969600.jpg","large":"https://img3.doubanio.com/view/subject/l/public/s28969600.jpg","medium":"https://img3.doubanio.com/view/subject/m/public/s28969600.jpg"},"alt":"https://book.douban.com/subject/26854244/","id":"26854244","publisher":"人民邮电出版社","isbn10":"7115431167","isbn13":"9787115431165","title":"你不知道的JavaScript（中卷）","url":"https://api.douban.com/v2/book/26854244","alt_title":"","author_intro":"<作者介绍>\nKyle Simpson\n作家、培训师、讲师、开源社区的活跃成员，推崇开放的互联网，对JavaScript、HTML5、实时/端对端通信和Web性能有深入研究。\n<译者介绍>\n单业\n计算机专业硕士，软件工程师，曾供职于多家软件公司，从事软件开发工作，现居于上海。负责本书第二部分“异步和性能”的翻译。\n姜南\n从事过国内外金融、通信、移动互联网、数字出版等领域的IT系统开发工作，擅长的技术有Java、C#、HTML5、JavaScript、iOS、Android等。长期在独立技术博客——酷壳（coolshell.cn）发表翻译文章。负责本书第一部分“类型和语法”的翻译。","summary":"JavaScript这门语言简单易用，很容易上手，但其语言机制复杂微妙，即使是经验丰富的JavaScript开发人员，如果没有认真学习的话也无法真正理解。本套书直面当前JavaScript开发人员不求甚解的大趋势，深入理解语言内部的机制，全面介绍了JavaScript中常被人误解和忽视的重要知识点。本书是其中卷，主要介绍了类型、语法、异步和性能。","ebook_price":"39.99","series":{"id":"40642","title":"你不知道的JavaScript"},"price":"79.00元"},"9787115471659":{"rating":{"max":10,"numRaters":56,"average":"8.0","min":0},"subtitle":"","author":["[美] Kyle Simpson"],"pubdate":"2018-1-1","tags":[{"count":59,"name":"JavaScript","title":"JavaScript"},{"count":16,"name":"前端开发","title":"前端开发"},{"count":12,"name":"编程","title":"编程"},{"count":11,"name":"前端","title":"前端"},{"count":9,"name":"Web前端开发","title":"Web前端开发"},{"count":7,"name":"计算机","title":"计算机"},{"count":6,"name":"javascript","title":"javascript"},{"count":4,"name":"专业知识刷","title":"专业知识刷"}],"origin_title":"You don't know JS","image":"https://img1.doubanio.com/view/subject/m/public/s29656379.jpg","binding":"平装","translator":["单业"],"catalog":"前言 xi\n致谢 xvii\n第 一部分 起步上路\n序 2\n第 1 章 深入编程 4\n1.1 代码 4\n1.2 表达式 5\n1.3 实践 6\n1.3.1 输出 7\n1.3.2 输入 8\n1.4 运算符 9\n1.5 值与类型 11\n1.6 代码注释 13\n1.7 变量 14\n1.8 块 16\n1.9 条件判断 17\n1.10 循环 18\n1.11 函数 20\n1.12 实践 23\n1.13 小结 25\n第 2 章 深入JavaScript 26\n2.1 值与类型 26\n2.1.1 对象 28\n2.1.2 内置类型方法 30\n2.1.3 值的比较 31\n2.2 变量 35\n2.3 条件判断 37\n2.4 严格模式 39\n2.5 作为值的函数 40\n2.5.1 立即调用函数表达式 41\n2.5.2 闭包 42\n2.6 this标识符 44\n2.7 原型 46\n2.8 旧与新 47\n2.8.1 polyfilling 47\n2.8.2 transpiling 48\n2.9 非JavaScript 49\n2.10 小结 50\n第 3 章 深入“你不知道的JavaScript”系列 51\n3.1 作用域和闭包 51\n3.2 this和对象原型 52\n3.3 类型和语法 53\n3.4 异步和性能 53\n3.5 ES6及更新版本 54\n3.6 小结 55\n第 二部分 ES6及更新版本\n序 58\n第 1 章 ES？现在与未来 59\n1.1 版本 60\n1.2 transpiling 61\n1.3 小结 63\n第 2 章 语法 64\n2.1 块作用域声明 64\n2.1.1 let声明 65\n2.1.2 const声明 68\n2.1.3 块作用域函数 70\n2.2 spread/rest 71\n2.3 默认参数值 73\n2.4 解构 77\n2.4.1 对象属性复制模式 78\n2.4.2 不只是声明 79\n2.4.3 重复赋值 81\n2.5 太多，太少，刚刚好 83\n2.5.1 默认值赋值 84\n2.5.2 嵌套解构 84\n2.5.3 解构参数 85\n2.6　对象字面量扩展 90\n2.6.1　简洁属性 90\n2.6.2　简洁方法 90\n2.6.3　计算属性名 95\n2.6.4　设定[[Prototype]] 96\n2.6.5　super对象 97\n2.7　模板字面量 98\n2.7.1　插入表达式 99\n2.7.2　标签模板字面量 100\n2.8　箭头函数 103\n2.9　for..of循环 109\n2.10　正则表达式 111\n2.10.1　Unicode标识 111\n2.10.2　定点标识 112\n2.10.3　正则表达式flags 116\n2.11　数字字面量扩展 117\n2.12　Unicode 118\n2.12.1　支持Unicode的字符串运算 119\n2.12.2　字符定位 121\n2.12.3　Unicode标识符名 123\n2.13　符号 123\n2.13.1　符号注册 125\n2.13.2　作为对象属性的符号 127\n2.14　小结 128\n第 3 章　代码组织 129\n3.1　迭代器 129\n3.1.1　接口 130\n3.1.2　next()迭代 131\n3.1.3　可选的return(..)和throw(..) 132\n3.1.4　迭代器循环 133\n3.1.5　自定义迭代器 134\n3.1.6　迭代器消耗 137\n3.2　生成器 138\n3.2.1　语法 139\n3.2.2　迭代器控制 144\n3.2.3　提前完成 147\n3.2.4　错误处理 149\n3.2.5　Transpile生成器 151\n3.2.6　生成器使用 152\n3.3　模块 153\n3.3.1　旧方法 153\n3.3.2　前进 154\n3.3.3　新方法 156\n3.3.4　模块依赖环 164\n3.3.5　模块加载 166\n3.4　类 167\n3.4.1　class 168\n3.4.2　extends和super 169\n3.4.3　new.target 174\n3.4.4　static 175\n3.5　小结 176\n第 4 章　异步流控制 177\n4.1　Promise 177\n4.1.1　构造和使用Promise 178\n4.1.2　Thenable 180\n4.1.3　Promise API 181\n4.2　生成器 + Promise 183\n4.3　小结 185\n第 5 章　集合 187\n5.1　TypedArray 187\n5.1.1　大小端（Endianness） 188\n5.1.2　多视图 189\n5.1.3　带类数组构造器 190\n5.2　Map 192\n5.2.1　Map值 194\n5.2.2　Map键 194\n5.3　WeakMap 195\n5.4　Set 196\n5.5　WeakSet 198\n5.6　小结 199\n第 6 章　新增API 200\n6.1　Array 200\n6.1.1　静态函数Array.of(..) 200\n6.1.2　静态函数Array.from(..) 201\n6.1.3　创建数组和子类型 204\n6.1.4　原型方法copyWithin(..) 205\n6.1.5　原型方法fill(..) 206\n6.1.6　原型方法find(..) 206\n6.1.7　原型方法findIndex(..) 207\n6.1.8　原型方法entries()、values()、keys() 208\n6.2　Object 209\n6.2.1　静态函数Object.is(..) 209\n6.2.2　静态函数Object.getOwnPropertySymbols(..) 210\n6.2.3　静态函数Object.setPrototypeOf(..) 210\n6.2.4　静态函数Object.assign(..) 211\n6.3　Math 212\n6.4　Number 214\n6.4.1　静态属性 214\n6.4.2　静态函数Number.isNaN(..) 214\n6.4.3　静态函数Number.isFinite(..) 215\n6.4.4　整型相关静态函数 215\n6.5　字符串 216\n6.5.1　Unicode函数 217\n6.5.2　静态函数String.raw(..) 217\n6.5.3　原型函数repeat(..) 217\n6.5.4　字符串检查函数 218\n6.6　小结 218\n第 7 章　元编程 219\n7.1　函数名称 219\n7.2　元属性 222\n7.3　公开符号 223\n7.3.1　Symbol.iterator 223\n7.3.2　Symbol.toStringTag与Symbol.hasInstance 224\n7.3.3　Symbol.species 225\n7.3.4　Symbol.toPrimitive 226\n7.3.5　正则表达式符号 226\n7.3.6　Symbol.isConcatSpreadable 227\n7.3.7　Symbol.unscopables 228\n7.4　代理 228\n7.4.1　代理局限性 231\n7.4.2　可取消代理 232\n7.4.3　使用代理 233\n7.5　Reflect API 240\n7.6　特性测试 243\n7.7　尾递归调用（Tail Call Optimization,TCO） 245\n7.7.1　尾调用重写 247\n7.7.2　非TCO优化 248\n7.7.3　元在何处 250\n7.8　小结 251\n第 8 章　ES6之后 253\n8.1　异步函数 254\n8.2　Object.observe(..) 257\n8.2.1　自定义改变事件 258\n8.2.2　结束观测 259\n8.3　幂运算符 260\n8.4　对象属性与... 260\n8.5　Array#includes 261\n8.6　SIMD 262\n8.7　WebAssembly (WASM) 262\n8.8　小结 264","ebook_url":"https://read.douban.com/ebook/52186484/","pages":"264","images":{"small":"https://img1.doubanio.com/view/subject/s/public/s29656379.jpg","large":"https://img1.doubanio.com/view/subject/l/public/s29656379.jpg","medium":"https://img1.doubanio.com/view/subject/m/public/s29656379.jpg"},"alt":"https://book.douban.com/subject/27620408/","id":"27620408","publisher":"人民邮电出版社","isbn10":"7115471657","isbn13":"9787115471659","title":"你不知道的JavaScript（下卷）","url":"https://api.douban.com/v2/book/27620408","alt_title":"You don't know JS","author_intro":"作者:[美]凯尔?辛普森（Kyle Simpson） 译者:单业\nKyle Simpson，推崇开放的互联网，对JavaScript、HTML5、实时/端对端通信和Web性能有深入研究。他是技术书作家、技术培训师、讲师和开源社区的活跃成员。","summary":"JavaScript这门语言简单易用，很容易上手，但其语言机制复杂微妙，即使是经验丰富的JavaScript开发人员，如果没有认真学习的话也无法真正理解。本套书直面当前JavaScript开发人员不求甚解的大趋势，深入理解语言内部的机制，全面介绍了JavaScript中常被人误解和忽视的重要知识点。本书是其下卷，主要介绍了JavaScript入门知识和对ES6及未来发展趋势的展望。","ebook_price":"39.99","series":{"id":"40642","title":"你不知道的JavaScript"},"price":"79.00"},"9787115299222":{"rating":{"max":10,"numRaters":330,"average":"7.4","min":0},"subtitle":"HTML5和CSS3实战","author":["Ben Frain"],"pubdate":"2013-1-1","tags":[{"count":266,"name":"响应式设计","title":"响应式设计"},{"count":191,"name":"Web开发","title":"Web开发"},{"count":155,"name":"html5","title":"html5"},{"count":140,"name":"前端开发","title":"前端开发"},{"count":111,"name":"CSS3","title":"CSS3"},{"count":80,"name":"HTML5","title":"HTML5"},{"count":45,"name":"web","title":"web"},{"count":44,"name":"css3","title":"css3"}],"origin_title":"Responsive Web Design with HTML5 and CSS3","image":"https://img3.doubanio.com/view/subject/m/public/s24423104.jpg","binding":"平装","translator":["王永强"],"catalog":"第1章 　HTML5、CSS3及响应式设计入门　　1\n1.1 　为什么智能手机很重要（而老版的IE不再重要）　　2\n1.2 　响应式设计一定是最佳选择吗　　3\n1.3 　响应式网页设计的定义　　3\n1.4 　为什么要在响应式设计上停滞不前　　4\n1.5 　响应式网页设计示例　　4\n1.5.1 　下载视口调试工具　　4\n1.5.2 　在线创意源泉　　11\n1.6 　为什么HTML5很优秀　　12\n1.6.1 　省时省力　　12\n1.6.2 　新增了语义化标签元素　　13\n1.7 　CSS3为响应式设计和更多创新奠定了基础　　13\n1.7.1 　底线：CSS3不破坏任何东西　　14\n1.7.2 　CSS3如何解决日常设计问题　　14\n1.8 　看呐，不用图片　　17\n1.9 　HTML5和CSS3现在就能用吗　　20\n1.10 　响应式网页设计不是灵丹妙药　　20\n1.11 　引导客户：网站不必在所有浏览器中表现一致　　21\n1.12 　小结　　22\n第2章 　媒体查询：支持不同的视口　　23\n2.1 　现在就能使用媒体查询　　23\n2.2 　为什么响应式设计需要媒体查询　　24\n2.2.1 　媒体查询语法　　24\n2.2.2 　 媒体查询能检测那些特性　　26\n2.2.3 　用媒体查询改造我们的设计　　27\n2.2.4 　加载媒体查询的最佳方法　　27\n2.3 　我们的第一个响应式设计　　27\n2.3.1 　我们的设计是固定宽度的，不要惊讶　　28\n2.3.2 　响应式设计中要保证图片尽可能精简　　32\n2.3.3 　小视口下的内容剪切　　33\n2.4 　阻止移动浏览器自动调整页面大小　　34\n2.5 　针对不同视口宽度修正设计　　37\n2.6 　响应式设计中内容始终优先　　38\n2.7 　媒体查询只是必要条件之一　　42\n2.8 　小结　　42\n第3章 　拥抱流式布局　　43\n3.1 　固定布局经不起未来考验　　43\n3.2 　为什么响应式设计需要百分比布局　　44\n3.3 　将网页从固定布局修改为百分比布局　　44\n3.3.1 　需要牢记的公式　　45\n3.3.2 　设置百分比元素的上下文　　47\n3.3.3 　必须时刻牢记上下文　　52\n3.4 　用em替换px　　54\n3.5 　弹性图片　　56\n3.5.1 　让图片随视口缩放　　56\n3.5.2 　为特定图片指定特定规则　　58\n3.5.3 　给弹性图片设置阈值　　59\n3.5.4 　超级全能的max-width属性　　61\n3.6 　为不同的屏幕尺寸提供不同的图片　　61\n3.7 　流动网格布局和媒体查询的默契配合　　66\n3.8 　CSS网格系统　　66\n3.9 　小结　　72\n第4章 　响应式设计中的HTML5　　73\n4.1 　HTML5的哪些部分现在就能用　　73\n4.1.1 　大多数网站可以用HTML5编写　　74\n4.1.2 　腻子脚本和Modernizr　　74\n4.2 　如何编写HTML5网页　　75\n4.2.1 　HTML5的精简之道　　76\n4.2.2 　HTML5标签的合理写法　　76\n4.2.3 　伟大的<a>标签万岁　　77\n4.2.4 　HTML的废弃零件　　77\n4.3 　HTML5的全新语义化元素　　78\n4.3.1 　<section>　　78\n4.3.2 　<nav>　　79\n4.3.3 　<article>　　79\n4.3.4 　<aside>　　79\n4.3.5 　<hgroup>　　79\n4.3.6 　<header>　　81\n4.3.7 　<footer>　　81\n4.3.8 　<address>　　81\n4.4 　HTML5结构元素的实际用法　　81\n4.5 　HTML5的文本级语义元素　　87\n4.5.1 　<b>　　88\n4.5.2 　<em>　　88\n4.5.3 　<i>　　88\n4.5.4 　在页面中应用文本层语义元素　　88\n4.6 　遵循WAI-ARIA实现无障碍站点　　90\n4.7 　在HTML5中嵌入媒体　　93\n4.8 　用HTML5的方法为页面添加视频或音频　　93\n4.8.1 　提供备用的媒体源文件　　95\n4.8.2 　针对老版本浏览器的备用方案　　95\n4.8.3 　和标签的用法基本一致　　96\n4.9 　响应式视频　　96\n4.10 　离线Web应用　　99\n4.10.1 　离线Web应用概述　　99\n4.10.2 　让网页可离线使用　　99\n4.10.3 　理解manifest文件　　100\n4.10.4 　页面被自动加载到离线缓存　　101\n4.10.5 　版本注释的用途　　101\n4.10.6 　离线访问网站　　101\n4.10.7 　离线Web应用的故障诊断　　102\n4.11 　小结　　103\n第5章 　CSS3：选择器、字体和颜色模式　　104\n5.1 　CSS3给前端开发人员带来了什么　　104\n5.1.1 　Internet Explorer 6到8对CSS3的支持　　105\n5.1.2 　使用CSS3设计和开发页面　　105\n5.2 　CSS规则解析　　105\n5.3 　私有前缀及其用法　　106\n5.4 　快速而有效的CSS技巧　　108\n5.4.1 　CSS3多栏布局　　108\n5.4.2 　文字换行　　110\n5.5 　CSS3的新增选择器及其用法　　111\n5.5.1 　CSS3属性选择器　　111\n5.5.2 　CSS3结构伪类　　113\n5.5.3 　对伪元素的修正　　122\n5.6 　自定义网页字体　　123\n5.6.1 　@font-face规则　　124\n5.6.2 　使用@font-face嵌入网页字体　　124\n5.7 　帮帮我，标题模糊怎么办　　127\n5.8 　新的CSS3颜色格式和透明度　　129\n5.8.1 　RGB颜色　　130\n5.8.2 　HSL颜色　　131\n5.8.3 　针对IE6、IE7和IE8提供备用颜色值　　132\n5.8.4 　透明通道　　132\n5.9 　小结　　134\n第6章 　用CSS3创造令人惊艳的美　　135\n6.1 　文字阴影　　136\n6.1.1 　HEX、HSL或RGB颜色都可以　　136\n6.1.2 　px、em或rem都行　　136\n6.1.3 　取消文字阴影　　138\n6.1.4 　制作浮雕文字阴影效果　　139\n6.1.5 　多重文字阴影　　140\n6.2 　盒阴影　　140\n6.2.1 　内阴影　　141\n6.2.2 　多重阴影　　142\n6.3 　背景渐变　　143\n6.3.1 　线性背景渐变　　144\n6.3.2 　径向背景渐变　　147\n6.3.3 　重复渐变　　149\n6.4 　背景渐变图案　　151\n6.5 　CSS3的响应性　　153\n6.6 　组合使用CSS3属性　　155\n6.7 　多重背景图片　　159\n6.7.1 　背景图片大小　　161\n6.7.2 　背景图片位置　　161\n6.7.3 　背景属性的缩写语法　　161\n6.8 　更多CSS特性　　162\n6.9 　可缩放图标：响应式设计中的完美选择　　162\n6.10 　小结　　163\n第7章 　CSS3过渡、变形和动画　　164\n7.1 　什么是CSS3过渡以及如何使用它　　164\n7.1.1 　过渡相关的属性　　166\n7.1.2 　响应式网站中的有趣过渡　　168\n7.2 　CSS3的2D变形　　169\n7.3 　尝试CSS3的3D变形　　174\n7.3.1 　分析3D变形效果　　176\n7.3.2 　3D变形尚未成熟　　178\n7.4 　CSS3动画效果　　179\n7.5 　小结　　185\n第8章 　用HTML5和CSS3征服表单　　186\n8.1 　HTML5表单　　186\n8.1.1 　理解HTML5表单中的元素　　188\n8.1.2 　placeholder　　189\n8.1.3 　required　　189\n8.1.4 　autofocus　　190\n8.1.5 　autocomplete　　191\n8.1.6 　list（及对应的datalist元素）　　191\n8.1.7 　HTML5的新输入类型　　192\n8.1.8 　日期和时间输入类型　　198\n8.2 　如何给不支持新特性的浏览器打补丁　　203\n8.3 　使用CSS3美化HTML5表单　　204\n8.4 　小结　　210\n第9章 　解决跨浏览器问题　　211\n9.1 　渐进增强与优雅降级　　215\n9.2 　该不该修复老版本IE　　216\n9.2.1 　统计数据（再看看世界的变化）　　216\n9.2.2 　个人选择　　216\n9.3 　前端的瑞士军刀：Modernizr　　217\n9.3.1 　使用Modernizr辅助修正样式问题　　219\n9.3.2 　使用Modernizr让老版本IE支持HTML5元素　　221\n9.3.3 　给IE6、7、8追加min/max媒体查询功能　　222\n9.3.4 　使用Modernizr按需加载资源　　223\n9.4 　必要时将导航链接转换为下拉菜单　　225\n9.5 　高分辨率设备（未来趋势）　　228\n9.6 　小结　　231\n","pages":"231","images":{"small":"https://img3.doubanio.com/view/subject/s/public/s24423104.jpg","large":"https://img3.doubanio.com/view/subject/l/public/s24423104.jpg","medium":"https://img3.doubanio.com/view/subject/m/public/s24423104.jpg"},"alt":"https://book.douban.com/subject/20390374/","id":"20390374","publisher":"人民邮电出版社","isbn10":"7115299226","isbn13":"9787115299222","title":"响应式Web设计","url":"https://api.douban.com/v2/book/20390374","alt_title":"Responsive Web Design with HTML5 and CSS3","author_intro":"Ben Frain是一名具有十多年经验的网页设计师和前端工程师，直接与世界各地的客户和设计机构并肩工作。同时他还是一名技术记者，定期为一些关注Mac平台、前沿科技、网页设计和航空技术的刊物撰稿。\n在此之前，他曾是一名怀才不遇的（而且谦虚谨慎的）电视演员，毕业于索尔福德大学的媒体与表演专业。他写了四部（自认为）同样被低估的剧本，而且始终心怀能卖出一部的信念（尽管不像最初那么强烈了）。\n工作之余，在身体（和妻子）允许的情况下，他喜欢玩室内足球。 他的个人网站是www.benfrain.com，Twitter地址是twitter.com/benfrain。","summary":"随着iPad mini的发布，又一个新的屏幕尺寸诞生了。用不着全面统计，你就会发现移动互联网时代众多的屏幕规格，从智能手机的3、4、5英寸，到平板电脑的7、8、9、10英寸，再到笔记本和台式机的13至30英寸，绝非目前单一的固定或流式布局所能应付。于是，响应式设计应运而生，而且它也将成为移动互联网时代前端设计与开发人员的一门必修课。\n本书堪称学习响应式Web设计的难得佳作。它不仅全面、细致、图文并茂地介绍了响应式设计相关的技术，比如媒体查询、流式布局、弹性媒体和弹性字体等，还把近几年来Web设计领域公认的最佳设计理念有机地融入到了实例当中，比如移动先行（Mobile First）、渐进增强、平稳退化、无障碍设计等。更加难得的是，本书以设计跨屏幕的网页（响应式设计）为出发点，以点带面，把如今Web设计领域两大标准的最新版本HTML5和CSS3也纳入其中，读者在掌握先进设计方法的同时也能掌握最新的设计技术（比如使用新的HTML5结构化语义标记、嵌入媒体、响应式视频，以及CSS3的新选择器、特效、过渡、变形和动画等），从而可以免除重复学习新标准之苦，让自己一步跨入Web设计领域的最前沿。无论你想学习响应式Web设计，还是学习HTML5和CSS3的实际应用，本书都能满足你的需要，是毋庸置疑的明智之选。\n说到底，响应式Web设计并非一门独立的技术，而只是现有技术的一个组合应用。只要有一点HTML和CSS基础的读者都能顺利地掌握它。对于中、高级的前端设计和开发人员，翻阅本书也有助于理清自己的知识脉络，对这个新的设计理念获得更全面、深入的理解和把握。\n习惯移动阅读的读者，可访问图灵社区，购买本书电子版：http://www.ituring.com.cn/book/1055","price":"49.00元"},"9787115437303":{"rating":{"max":10,"numRaters":128,"average":"8.2","min":0},"subtitle":"","author":["陈屹"],"pubdate":"2016-11-1","tags":[{"count":155,"name":"React","title":"React"},{"count":73,"name":"Web前端","title":"Web前端"},{"count":64,"name":"JavaScript","title":"JavaScript"},{"count":38,"name":"前端","title":"前端"},{"count":36,"name":"前端开发","title":"前端开发"},{"count":22,"name":"编程","title":"编程"},{"count":22,"name":"技术","title":"技术"},{"count":22,"name":"Web开发","title":"Web开发"}],"origin_title":"","image":"https://img3.doubanio.com/view/subject/m/public/s29162154.jpg","binding":"平装","translator":[],"catalog":"第1章 初入React世界1\n1.1 React简介1\n1.1.1 专注视图层1\n1.1.2 Virtual DOM1\n1.1.3 函数式编程2\n1.2 JSX语法3\n1.2.1 JSX的由来3\n1.2.2 JSX基本语法7\n1.3 React组件11\n1.3.1 组件的演变11\n1.3.2 React组件的构建18\n1.4 React数据流21\n1.4.1 state21\n1.4.2 props23\n1.5 React生命周期29\n1.5.1 挂载或卸载过程29\n1.5.2 数据更新过程30\n1.5.3 整体流程33\n1.6 React与DOM34\n1.6.1 ReactDOM35\n1.6.2 ReactDOM的不稳定方法36\n1.6.3 refs38\n1.6.4 React之外的DOM操作40\n1.7 组件化实例：Tabs组件41\n1.8 小结47\n第2章 漫淡React48\n2.1 事件系统48\n2.1.1 合成事件的绑定方式48\n2.1.2 合成事件的实现机制49\n2.1.3 在React中使用原生事件51\n2.1.4 合成事件与原生事件混用51\n2.1.5 对比React合成事件与JavaScript原生事件54\n2.2 表单55\n2.2.1 应用表单组件55\n2.2.2 受控组件60\n2.2.3 非受控组件61\n2.2.4 对比受控组件和非受控组件62\n2.2.5 表单组件的几个重要属性63\n2.3 样式处理64\n2.3.1 基本样式设置64\n2.3.2 CSS Modules66\n2.4 组件间通信74\n2.4.1 父组件向子组件通信74\n2.4.2 子组件向父组件通信75\n2.4.3 跨级组件通信77\n2.4.4 没有嵌套关系的组件通信79\n2.5 组件间抽象81\n2.5.1 mixin81\n2.5.2 高阶组件86\n2.5.3 组合式组件开发实践93\n2.6 组件性能优化97\n2.6.1 纯函数97\n2.6.2 PureRender100\n2.6.3 Immutable103\n2.6.4 key109\n2.6.5 react—addons—perf110\n2.7 动画111\n2.7.1 CSS动画与JavaScript动画111\n2.7.2 玩转ReactTransition113\n2.7.3 缓动函数116\n2.8 自动化测试121\n2.8.1 Jest121\n2.8.2 Enzyme124\n2.8.3 自动化测试125\n2.9 组件化实例：优化Tabs组件125\n2.10 小结133\n第3章 解读React源码134\n3.1 初探React源码134\n3.2 Virtual DOM模型137\n3.2.1 创建React元素138\n3.2.2 初始化组件入口140\n3.2.3 文本组件141\n3.2.4 DOM标签组件144\n3.2.5 自定义组件150\n3.3 生命周期的管理艺术151\n3.3.1 初探React生命周期152\n3.3.2 详解React生命周期152\n3.3.3 无状态组件163\n3.4 解密setState机制164\n3.4.1 setState异步更新164\n3.4.2 setState循环调用风险165\n3.4.3 setState调用栈166\n3.4.4 初识事务168\n3.4.5 解密setState170\n3.5 diff算法172\n3.5.1 传统diff算法172\n3.5.2 详解diff172\n3.6 ReactPatch方法181\n3.7 小结183\n第4章 认识Flux架构模式184\n4.1 React独立架构184\n4.2 MV*与Flux190\n4.2.1 MVC／MVVM190\n4.2.2 Flux的解决方案193\n4.3 Flux基本概念194\n4.4 Flux应用实例198\n4.4.1 初始化目录结构198\n4.4.2 设计store198\n4.4.3 设计actionCreator200\n4.4.4 构建controller—view202\n4.4.5 重构view203\n4.4.6 添加单元测试205\n4.5 解读Flux206\n4.5.1 Flux核心思想206\n4.5.2 Flux的不足207\n4.6 小结207\n第5章 深入Redux应用架构208\n5.1 Redux简介208\n5.1.1 Redux是什么208\n5.1.2 Redux三大原则209\n5.1.3 Redux核心API210\n5.1.4 与React绑定211\n5.1.5 增强Flux的功能212\n5.2 Reduxmiddleware212\n5.2.1 middleware的由来212\n5.2.2 理解middleware机制213\n5.3 Redux异步流217\n5.3.1 使用middleware简化异步请求217\n5.3.2 使用middleware处理复杂异步流221\n5.4 Redux与路由224\n5.4.1 React Router225\n5.4.2 React Router Redux227\n5.5 Redux与组件229\n5.5.1 容器型组件229\n5.5.2 展示型组件229\n5.5.3 Redux中的组件230\n5.6 Redux应用实例231\n5.6.1 初始化Redux项目231\n5.6.2 划分目录结构232\n5.6.3 设计路由234\n5.6.4 让应用跑起来235\n5.6.5 优化构建脚本239\n5.6.6 添加布局文件239\n5.6.7 准备首页的数据242\n5.6.8 连接Redux245\n5.6.9 引入Redux Devtools250\n5.6.10 利用middleware实现Ajax\n请求发送251\n5.6.11 请求本地的数据252\n5.6.12 页面之间的跳转253\n5.6.13 优化与改进256\n5.6.14 添加单元测试257\n5.7 小结258\n第6章 Redux高阶运用259\n6.1 高阶reducer259\n6.1.1 reducer的复用259\n6.1.2 reducer的增强261\n6.2 Redux与表单262\n6.2.1 使用redux—form—utils减少创建表单的冗余代码263\n6.2.2 使用redux—form完成表单的异步验证265\n6.2.3 使用高阶reducer为现有模块引入表单功能267\n6.3 ReduxCRUD实战268\n6.3.1 准备工作268\n6.3.2 使用Table组件完成“查”功能269\n6.3.3 使用Modal组件完成“增”与“改”274\n6.3.4 巧用Modal实现数据的删除确认277\n6.3.5 善用promise玩转Redux异步事件流278\n6.4 Redux性能优化279\n6.4.1 Reselect280\n6.4.2 Immutable Redux282\n6.4.3 Reducer性能优化282\n6.5 解读Redux284\n6.5.1 参数归一化285\n6.5.2 初始状态及getState286\n6.5.3 subscribe286\n6.5.4 dispatch287\n6.5.5 replaceReducer288\n6.6 解读react—redux288\n6.6.1 Provider288\n6.6.2 connect290\n6.6.3 代码热替换293\n6.7 小结294\n第7章 React服务端渲染295\n7.1 React与服务端模板295\n7.1.1 什么是服务端渲染295\n7.1.2 react—view296\n7.1.3 react—view源码解读296\n7.2 React服务端渲染299\n7.2.1 玩转Node.js300\n7.2.2 React—Router和Koa—Router统一303\n7.2.3 同构数据处理的探讨306\n7.3 小结307\n第8章 玩转React可视化308\n8.1 React结合Canvas和SVG308\n8.1.1 Canvas与SVG308\n8.1.2 在React中的Canvas310\n8.1.3 React中的SVG311\n8.2 React与可视化组件316\n8.2.1 包装已有的可视化库316\n8.2.2 使用D3绘制UI部分317\n8.2.3 使用React绘制UI部分319\n8.3 Recharts组件化的原理322\n8.3.1 声明式的标签323\n8.3.2 贴近原生的配置项325\n8.3.3 接口式的API326\n8.4 小结328\n附录A 开发环境329\n附录B 编码规范345\n附录C Koamiddleware349","pages":"351","images":{"small":"https://img3.doubanio.com/view/subject/s/public/s29162154.jpg","large":"https://img3.doubanio.com/view/subject/l/public/s29162154.jpg","medium":"https://img3.doubanio.com/view/subject/m/public/s29162154.jpg"},"alt":"https://book.douban.com/subject/26918038/","id":"26918038","publisher":"人民邮电出版社","isbn10":"7115437300","isbn13":"9787115437303","title":"深入React技术栈","url":"https://api.douban.com/v2/book/26918038","alt_title":"","author_intro":"陈屹，前端架构师，就职于阿里巴巴。热衷开源事业，长年专注于前端架构、数据可视化、Node.js等领域，知乎专栏pure render的创办人。","summary":"全面讲述React技术栈的第一本原创图书，pure render专栏主创倾力打造\n覆盖React、Flux、Redux及可视化，帮助开发者在实践中深入理解技术和源码\n前端组件化主流解决方案，一本书玩转React“全家桶”\n本书讲解了非常多的内容，不仅介绍了面向普通用户的API、应用架构和周边工具，还深入介绍了底层实现。此外，本书非常重视实战，每一节都有实际的例子，细节丰富。我从这本书里学到了很多东西，强烈推荐！\n——阮一峰，蚂蚁金服技术专家，国内技术圈知名博主，《ES 6标准入门（第2版）》作者\nReact从诞生起就颠覆了诸多传统前端开发的“铁律”，这种破旧立新开启了前端开发全新的时代。它的用法和理念，代表了现在和未来几年前端技术的潮流风向。如果不想落伍，最好进行系统学习。实践出真知，从牛人的实践中收获自己的真知，恐怕是最好的捷径。这是我看到的第一本React中文原创著作，读来倍感亲切。\n——张克军，豆瓣前端专家，国内技术圈知名博主，前端布道师\n本书内容翔实，一扫“文档说明书”之风，有大量作者的实战经验。由浅入深，无论你是 React 初学者，还是进阶人士，本书都值得一读！\n——寸志，陆金所前端架构师，《前端外刊评论》发起人\n本书从几个维度去介绍 React。一是作为 View 库，它怎么实现组件化，以及它背后的实现原理。二是扩展到 Flux 应用架构及重要的衍生品 Redux，它们怎么与 React 结合做应用开发。三是对 React 与 server 的碰撞产生的一些思考。四是讲述它在可视化方面的优势与劣势。\n本书适合有一定经验的前端开发人员阅读。\n陈屹\n前端架构师，就职于阿里巴巴。热衷开源事业，长年专注于前端架构、数据可视化、Node.js等领域，知乎专栏pure render的创办人。","series":{"id":"13000","title":"图灵原创"},"price":"CNY 79.00"},"9787115335500":{"rating":{"max":10,"numRaters":836,"average":"8.5","min":0},"subtitle":"","author":["朴灵"],"pubdate":"2013-12-1","tags":[{"count":823,"name":"node.js","title":"node.js"},{"count":477,"name":"JavaScript","title":"JavaScript"},{"count":276,"name":"Node.js","title":"Node.js"},{"count":229,"name":"编程","title":"编程"},{"count":188,"name":"Web","title":"Web"},{"count":152,"name":"计算机","title":"计算机"},{"count":129,"name":"nodejs","title":"nodejs"},{"count":85,"name":"技术","title":"技术"}],"origin_title":"","image":"https://img3.doubanio.com/view/subject/m/public/s27269296.jpg","binding":"平装","translator":[],"catalog":"第1章　Node简介　　1\n1.1 　Node的诞生历程　　1\n1.2 　Node的命名与起源　　1\n1.2.1 　为什么是JavaScript　　2\n1.2.2 　为什么叫Node　　2\n1.3 　Node给JavaScript带来的意义　　2\n1.4 　Node的特点　　4\n1.4.1 　异步I/O　　4\n1.4.2 　事件与回调函数　　6\n1.4.3 　单线程　　7\n1.4.4 　跨平台　　7\n1.5 　Node的应用场景　　8\n1.5.1 　I/O密集型　　8\n1.5.2 　是否不擅长CPU密集型业务　　8\n1.5.3 　与遗留系统和平共处　　10\n1.5.4 　分布式应用　　10\n1.6 　Node的使用者　　10\n1.7 　参考资源　　11\n第2章　模块机制　　12\n2.1 　CommonJS规范　　13\n2.1.1 　CommonJS的出发点　　13\n2.1.2 　CommonJS的模块规范　　14\n2.2 　Node的模块实现　　15\n2.2.1 　优先从缓存加载　　16\n2.2.2 　路径分析和文件定位　　16\n2.2.3 　模块编译　　18\n2.3 　核心模块　　20\n2.3.1 　JavaScript核心模块的编译过程　　21\n2.3.2 　C/C++核心模块的编译过程　　22\n2.3.3 　核心模块的引入流程　　25\n2.3.4 　编写核心模块　　25\n2.4 　C/C++扩展模块　　27\n2.4.1 　前提条件　　28\n2.4.2 　C/C++扩展模块的编写　　29\n2.4.3 　C/C++扩展模块的编译　　30\n2.4.4 　C/C++扩展模块的加载　　31\n2.5 　模块调用栈　　32\n2.6 　包与NPM　　33\n2.6.1 　包结构　　34\n2.6.2 　包描述文件与NPM　　34\n2.6.3 　NPM常用功能　　37\n2.6.4 　局域NPM　　42\n2.6.5 　NPM潜在问题　　43\n2.7 　前后端共用模块　　44\n2.7.1 　模块的侧重点　　44\n2.7.2 　AMD规范　　44\n2.7.3 　CMD规范　　45\n2.7.4 　兼容多种模块规范　　45\n2.8 　总结　　46\n2.9 　参考资源　　46\n第3章　异步I/O　　47\n3.1 　为什么要异步I/O　　47\n3.1.1 　用户体验　　48\n3.1.2 　资源分配　　49\n3.2 　异步I/O实现现状　　50\n3.2.1 　异步I/O与非阻塞I/O　　50\n3.2.2 　理想的非阻塞异步I/O　　54\n3.2.3 　现实的异步I/O　　54\n3.3 　Node的异步I/O　　56\n3.3.1 　事件循环　　56\n3.3.2 　观察者　　56\n3.3.3 　请求对象　　57\n3.3.4 　执行回调　　59\n3.3.5 　小结　　60\n3.4 　非I/O的异步API　　60\n3.4.1 　定时器　　60\n3.4.2 　process.nextTick()　　61\n3.4.3 　setImmediate()　　62\n3.5 　事件驱动与高性能服务器　　63\n3.6 　总结　　65\n3.7 　参考资源　　65\n第4章　异步编程　　66\n4.1 　函数式编程　　66\n4.1.1 　高阶函数　　66\n4.1.2 　偏函数用法　　67\n4.2 　异步编程的优势与难点　　68\n4.2.1 　优势　　69\n4.2.2 　难点　　70\n4.3 　异步编程解决方案　　74\n4.3.1 　事件发布/订阅模式　　74\n4.3.2 　Promise/Deferred模式　　82\n4.3.3 　流程控制库　　93\n4.4 　异步并发控制　　105\n4.4.1 　bagpipe的解决方案　　105\n4.4.2 　async的解决方案　　109\n4.5 　总结　　110\n4.6 　参考资源　　110\n第5章　内存控制　　111\n5.1 　V8的垃圾回收机制与内存限制　　111\n5.1.1 　Node与V8　　112\n5.1.2 　V8的内存限制　　112\n5.1.3 　V8的对象分配　　112\n5.1.4 　V8的垃圾回收机制　　113\n5.1.5 　查看垃圾回收日志　　119\n5.2 　高效使用内存　　121\n5.2.1 　作用域　　121\n5.2.2 　闭包　　123\n5.2.3 　小结　　124\n5.3 　内存指标　　124\n5.3.1 　查看内存使用情况　　124\n5.3.2 　堆外内存　　126\n5.3.3 　小结　　127\n5.4 　内存泄漏　　127\n5.4.1 　慎将内存当做缓存　　127\n5.4.2 　关注队列状态　　130\n5.5 　内存泄漏排查　　130\n5.5.1 　node-heapdump　　131\n5.5.2 　node-memwatch　　132\n5.5.3 　小结　　135\n5.6 　大内存应用　　135\n5.7 　总结　　136\n5.8 　参考资源　　136\n第6章 　理解Buffer　　137\n6.1 　Buffer结构　　137\n6.1.1 　模块结构　　137\n6.1.2 　Buffer对象　　138\n6.1.3 　Buffer内存分配　　139\n6.2 　Buffer的转换　　141\n6.2.1 　字符串转Buffer　　141\n6.2.2 　Buffer转字符串　　142\n6.2.3 　Buffer不支持的编码类型　　142\n6.3 　Buffer的拼接　　143\n6.3.1 　乱码是如何产生的　　144\n6.3.2 　setEncoding()与string_decoder()　　144\n6.3.3 　正确拼接Buffer　　145\n6.4 　Buffer与性能　　146\n6.5 　总结　　149\n6.6 　参考资源　　149\n第7章　网络编程　　150\n7.1 　构建TCP服务　　150\n7.1.1 　TCP　　150\n7.1.2 　创建TCP服务器端　　151\n7.1.3 　TCP服务的事件　　153\n7.2 　构建UDP服务　　154\n7.2.1 　创建UDP套接字　　154\n7.2.2 　创建UDP服务器端　　154\n7.2.3 　创建UDP客户端　　155\n7.2.4 　UDP套接字事件　　155\n7.3 　构建HTTP服务　　155\n7.3.1 　HTTP　　156\n7.3.2 　http模块　　157\n7.3.3 　HTTP客户端　　161\n7.4 　构建WebSocket服务　　163\n7.4.1 　WebSocket握手　　164\n7.4.2 　WebSocket数据传输　　167\n7.4.3 　小结　　169\n7.5 　网络服务与安全　　169\n7.5.1 　TLS/SSL　　170\n7.5.2 　TLS服务　　172\n7.5.3 　HTTPS服务　　173\n7.6 　总结　　175\n7.7 　参考资源　　176\n第8章　构建Web应用　　177\n8.1 　基础功能　　177\n8.1.1 　请求方法　　178\n8.1.2 　路径解析　　179\n8.1.3 　查询字符串　　180\n8.1.4 　Cookie　　181\n8.1.5 　Session　　184\n8.1.6 　缓存　　190\n8.1.7 　Basic认证　　193\n8.2 　数据上传　　195\n8.2.1 　表单数据　　195\n8.2.2 　其他格式　　196\n8.2.3 　附件上传　　197\n8.2.4 　数据上传与安全　　199\n8.3 　路由解析　　201\n8.3.1 　文件路径型　　202\n8.3.2 　MVC　　202\n8.3.3 　RESTful　　207\n8.4 　中间件　　210\n8.4.1 　异常处理　　214\n8.4.2 　中间件与性能　　215\n8.4.3 　小结　　216\n8.5 　页面渲染　　217\n8.5.1 　内容响应　　217\n8.5.2 　视图渲染　　219\n8.5.3 　模板　　220\n8.5.4 　Bigpipe　　231\n8.6 　总结　　235\n8.7 　参考资源　　235\n第9章　玩转进程　　236\n9.1 　服务模型的变迁　　236\n9.1.1 　石器时代：同步　　236\n9.1.2 　青铜时代：复制进程　　237\n9.1.3 　白银时代：多线程　　237\n9.1.4 　黄金时代：事件驱动　　237\n9.2 　多进程架构　　238\n9.2.1 　创建子进程　　239\n9.2.2 　进程间通信　　240\n9.2.3 　句柄传递　　242\n9.2.4 　小结　　247\n9.3 　集群稳定之路　　248\n9.3.1 　进程事件　　248\n9.3.2 　自动重启　　249\n9.3.3 　负载均衡　　254\n9.3.4 　状态共享　　255\n9.4 　Cluster模块　　257\n9.4.1 　Cluster工作原理　　258\n9.4.2 　Cluster事件　　259\n9.5 　总结　　259\n9.6 　参考资源　　260\n第10章　测试　　261\n10.1 　单元测试　　261\n10.1.1 　单元测试的意义　　261\n10.1.2 　单元测试介绍　　263\n10.1.3 　工程化与自动化　　276\n10.1.4 　小结　　277\n10.2 　性能测试　　278\n10.2.1 　基准测试　　278\n10.2.2 　压力测试　　280\n10.2.3 　基准测试驱动开发　　281\n10.2.4 　测试数据与业务数据的转换　　283\n10.3 　总结　　284\n10.4 　参考资源　　284\n第11章　产品化　　285\n11.1 　项目工程化　　285\n11.1.1 　目录结构　　285\n11.1.2 　构建工具　　286\n11.1.3 　编码规范　　289\n11.1.4 　代码审查　　289\n11.2 　部署流程　　290\n11.2.1 　部署环境　　291\n11.2.2 　部署操作　　291\n11.3 　性能　　293\n11.3.1 　动静分离　　293\n11.3.2 　启用缓存　　294\n11.3.3 　多进程架构　　294\n11.3.4 　读写分离　　295\n11.4 　日志　　295\n11.4.1 　访问日志　　295\n11.4.2 　异常日志　　296\n11.4.3 　日志与数据库　　299\n11.4.4 　分割日志　　299\n11.4.5 　小结　　299\n11.5 　监控报警　　299\n11.5.1 　监控　　300\n11.5.2 　报警的实现　　302\n11.5.3 　监控系统的稳定性　　303\n11.6 　稳定性　　303\n11.7 　异构共存　　304\n11.8 　总结　　305\n11.9 　参考资源　　305\n附录A 　安装Node　　306\nA.1 　Windows系统下的Node安装　　306\nA.2 　Mac系统下Node的安装　　307\nA.3 　Linux系统下Node的安装　　308\nA.4 　总结　　309\nA.5 　参考资源　　309\n附录B 　调试Node　　310\nB.1 　Debugger　　310\nB.2 　Node Inspector　　311\nB.2.1 　安装Node Inspector　　312\nB.2.2 　错误堆栈　　312\nB.3 　总结　　313\n附录C 　Node编码规范　　314\nC.1 　根源　　314\nC.2 　编码规范　　315\nC.2.1 　空格与格式　　315\nC.2.2 　命名规范　　317\nC.2.3 　比较操作　　318\nC.2.4 　字面量　　318\nC.2.5 　作用域　　318\nC.2.6 　数组与对象　　319\nC.2.7 　异步　　320\nC.2.8 　类与模块　　320\nC.2.9 　注解规范　　321\nC.3 　最佳实践　　321\nC.3.1 　冲突的解决原则　　321\nC.3.2 　给编辑器设置检测工具　　321\nC.3.3 　版本控制中的hook　　322\nC.3.4 　持续集成　　322\nC.4 　总结　　322\nC.5 　参考资源　　323\n附录D 　搭建局域NPM仓库　　324\nD.1 　NPM仓库的安装　　325\nD.1.1 　安装Erlang和CouchDB　　325\nD.1.2 　搭建NPM仓库　　326\nD.2 　高阶应用　　328\nD.2.1 　镜像仓库　　328\nD.2.2 　私有模块应用　　328\nD.2.3 　纯私有仓库　　329\nD.3 　总结　　331\nD.4 　参考资源　　332","ebook_url":"https://read.douban.com/ebook/12053349/","pages":"332","images":{"small":"https://img3.doubanio.com/view/subject/s/public/s27269296.jpg","large":"https://img3.doubanio.com/view/subject/l/public/s27269296.jpg","medium":"https://img3.doubanio.com/view/subject/m/public/s27269296.jpg"},"alt":"https://book.douban.com/subject/25768396/","id":"25768396","publisher":"人民邮电出版社","isbn10":"7115335508","isbn13":"9787115335500","title":"深入浅出Node.js","url":"https://api.douban.com/v2/book/25768396","alt_title":"","author_intro":"朴灵\n真名田永强，文艺型码农，就职于阿里巴巴数据平台，资深工程师，Node.js布道者，写了多篇文章介绍Node.js的细节。活跃于CNode社区，是线下会议NodeParty的组织者和JSConf China（沪JS和京JS）的组织者之一。热爱开源，多个Node.js模块的作者。个人GitHub地址：http://github.com/JacksonTian。叩首问路，码梦为生。","summary":"本书从不同的视角介绍了 Node 内在的特点和结构。由首章Node 介绍为索引，涉及Node 的各个方面，主要内容包含模块机制的揭示、异步I/O 实现原理的展现、异步编程的探讨、内存控制的介绍、二进制数据Buffer 的细节、Node 中的网络编程基础、Node 中的Web 开发、进程间的消息传递、Node 测试以及通过Node 构建产品需要的注意事项。最后的附录介绍了Node 的安装、调试、编码规范和NPM 仓库等事宜。\n本书适合想深入了解 Node 的人员阅读。","ebook_price":"39.99","series":{"id":"13000","title":"图灵原创"},"price":"CNY 69.00"},"9787302423287":{"rating":{"max":10,"numRaters":1651,"average":"8.7","min":0},"subtitle":"","author":["周志华"],"pubdate":"2016-1-1","tags":[{"count":2580,"name":"机器学习","title":"机器学习"},{"count":1201,"name":"人工智能","title":"人工智能"},{"count":638,"name":"数据挖掘","title":"数据挖掘"},{"count":570,"name":"计算机","title":"计算机"},{"count":508,"name":"数据分析","title":"数据分析"},{"count":505,"name":"MachineLearning","title":"MachineLearning"},{"count":421,"name":"计算机科学","title":"计算机科学"},{"count":378,"name":"AI","title":"AI"}],"origin_title":"","image":"https://img1.doubanio.com/view/subject/m/public/s28735609.jpg","binding":"平装","translator":[],"catalog":"目录\n第1章 1\n1.1 引言 1\n1.2 基本术 2\n1.3 假设空间 4\n1.4 归纳偏好 6\n1.5 发展历程 10\n1.6 应用现状 13\n1.7 阅读材料 16\n习题 19\n参考文献 20\n休息一会儿 22\n第2章 模型评估与选择 23\n2.1 经验误差与过拟合 23\n2.2 评估方法 24\n2.2.1 留出法 25\n2.2.2 交叉验证法 26\n2.2.3 自助法 27\n2.2.4 调参与最终模型 28\n2.3 性能度量 28\n2.3.1 错误率与精度 29\n2.3.2 查准率、查全率与F1 30\n2.3.3 ROC与AUC 33\n2.3.4 代价敏感错误率与代价曲线 35\n2.4 比较检验 37\n2.4.1 假设检验 37\n2.4.2 交叉验证t检验 40\n2.4.3 McNemar检验 41\n2.4.4 Friedman检验与后续检验 42\n2.5 偏差与方差 44\n2.6 阅读材料 46\n习题 48\n参考文献 49\n休息一会儿 51\n第3章 线性模型 53\n3.1 基本形式 53\n3.2 线性回归 53\n3.3 对数几率回归 57\n3.4 线性判别分析 60\n3.5 多分类学习 63\n3.6 类别不平衡问题 66\n3.7 阅读材料 67\n习题 69\n参考文献 70\n休息一会儿 72\n第4章 决策树 73\n4.1 基本流程 73\n4.2 划分选择 75\n4.2.1 信息增益 75\n4.2.2 增益率 77\n4.2.3 基尼指数 79\n4.3 剪枝处理 79\n4.3.1 预剪枝 80\n4.3.2 后剪枝 82\n4.4 连续与缺失值 83\n4.4.1 连续值处理 83\n4.4.2 缺失值处理 85\n4.5 多变量决策树 88\n4.6 阅读材料 92\n习题 93\n参考文献 94\n休息一会儿 95\n第5章 神经网络 97\n5.1 神经元模型 97\n5.2 感知机与多层网络 98\n5.3 误差逆传播算法 101\n5.4 全局最小与局部极小 106\n5.5 其他常见神经网络 108\n5.5.1 RBF网络 108\n5.5.2 ART网络 108\n5.5.3 SOM网络 109\n5.5.4 级联相关网络 110\n5.5.5 Elman网络 111\n5.5.6 Boltzmann机 111\n5.6 深度学习 113\n5.7 阅读材料 115\n习题 116\n参考文献 117\n休息一会儿 120\n第6章 支持向量机 121\n6.1 间隔与支持向量 121\n6.2 对偶问题 123\n6.3 核函数 126\n6.4 软间隔与正则化 129\n6.5 支持向量回归 133\n6.6 核方法 137\n6.7 阅读材料 139\n习题 141\n参考文献 142\n休息一会儿 145\n第7章 贝叶斯分类器 147\n7.1 贝叶斯决策论 147\n7.2 极大似然估计 149\n7.3 朴素贝叶斯分类器 150\n7.4 半朴素贝叶斯分类器 154\n7.5 贝叶斯网 156\n7.5.1 结构 157\n7.5.2 学习 159\n7.5.3 推断 161\n7.6 EM算法 162\n7.7 阅读材料 164\n习题 166\n参考文献 167\n休息一会儿 169\n第8章 集成学习 171\n8.1 个体与集成 171\n8.2 Boosting 173\n8.3 Bagging与随机森林 178\n8.3.1 Bagging 178\n8.3.2 随机森林 179\n8.4 结合策略 181\n8.4.1 平均法 181\n8.4.2 投票法 182\n8.4.3 学习法 183\n8.5 多样性 185\n8.5.1 误差--分歧分解 185\n8.5.2 多样性度量 186\n8.5.3 多样性增强 188\n8.6 阅读材料 190\n习题 192\n参考文献 193\n休息一会儿 196\n第9章 聚类 197\n9.1 聚类任务 197\n9.2 性能度量 197\n9.3 距离计算 199\n9.4 原型聚类 202\n9.4.1 k均值算法 202\n9.4.2 学习向量量化 204\n9.4.3 高斯混合聚类 206\n9.5 密度聚类 211\n9.6 层次聚类 214\n9.7 阅读材料 217\n习题 220\n参考文献 221\n休息一会儿 224\n第10章 降维与度量学习 225\n10.1 k近邻学习 225\n10.2 低维嵌入 226\n10.3 主成分分析 229\n10.4 核化线性降维 232\n10.5 流形学习 234\n10.5.1 等度量映射 234\n10.5.2 局部线性嵌入 235\n10.6 度量学习 237\n10.7 阅读材料 240\n习题 242\n参考文献 243\n休息一会儿 246\n第11章 特征选择与稀疏学习 247\n11.1 子集搜索与评价 247\n11.2 过滤式选择 249\n11.3 包裹式选择 250\n11.4 嵌入式选择与L$_1$正则化 252\n11.5 稀疏表示与字典学习 254\n11.6 压缩感知 257\n11.7 阅读材料 260\n习题 262\n参考文献 263\n休息一会儿 266\n第12章 计算学习理论 267\n12.1 基础知识 267\n12.2 PAC学习 268\n12.3 有限假设空间 270\n12.3.1 可分情形 270\n12.3.2 不可分情形 272\n12.4 VC维 273\n12.5 Rademacher复杂度 279\n12.6 稳定性 284\n12.7 阅读材料 287\n习题 289\n参考文献 290\n休息一会儿 292\n第13章 半监督学习 293\n13.1 未标记样本 293\n13.2 生成式方法 295\n13.3 半监督SVM 298\n13.4 图半监督学习 300\n13.5 基于分歧的方法 304\n13.6 半监督聚类 307\n13.7 阅读材料 311\n习题 313\n参考文献 314\n休息一会儿 317\n第14章 概率图模型 319\n14.1 隐马尔可夫模型 319\n14.2 马尔可夫随机场 322\n14.3 条件随机场 325\n14.4 学习与推断 328\n14.4.1 变量消去 328\n14.4.2 信念传播 330\n14.5 近似推断 331\n14.5.1 MCMC采样 331\n14.5.2 变分推断 334\n14.6 话题模型 337\n14.7 阅读材料 339\n习题 341\n参考文献 342\n休息一会儿 345\n第15章 规则学习 347\n15.1 基本概念 347\n15.2 序贯覆盖 349\n15.3 剪枝优化 352\n15.4 一阶规则学习 354\n15.5 归纳逻辑程序设计 357\n15.5.1 最小一般泛化 358\n15.5.2 逆归结 359\n15.6 阅读材料 363\n习题 365\n参考文献 366\n休息一会儿 369\n第16章 强化学习 371\n16.1 任务与奖赏 371\n16.2 $K$-摇臂赌博机 373\n16.2.1 探索与利用 373\n16.2.2 $\\epsilon $-贪心 374\n16.2.3 Softmax 375\n16.3 有模型学习 377\n16.3.1 策略评估 377\n16.3.2 策略改进 379\n16.3.3 策略迭代与值迭代 381\n16.4 免模型学习 382\n16.4.1 蒙特卡罗强化学习 383\n16.4.2 时序差分学习 386\n16.5 值函数近似 388\n16.6 模仿学习 390\n16.6.1 直接模仿学习 391\n16.6.2 逆强化学习 391\n16.7 阅读材料 393\n习题 394\n参考文献 395\n休息一会儿 397\n附录 399\nA 矩阵 399\nB 优化 403\nC 概率分布 409\n后记 417\n索引 419","pages":"425","images":{"small":"https://img1.doubanio.com/view/subject/s/public/s28735609.jpg","large":"https://img1.doubanio.com/view/subject/l/public/s28735609.jpg","medium":"https://img1.doubanio.com/view/subject/m/public/s28735609.jpg"},"alt":"https://book.douban.com/subject/26708119/","id":"26708119","publisher":"清华大学出版社","isbn10":"7302423288","isbn13":"9787302423287","title":"机器学习","url":"https://api.douban.com/v2/book/26708119","alt_title":"","author_intro":"周志华，南京大学教授，计算机科学与技术系副主任，软件新技术国家重点实验室常务副主任，机器学习与数据挖掘研究所（LAMDA）所长，校、系学术委员会委员；ACM杰出科学家，IEEE Fellow，IAPR Fellow，中国计算机学会会士；长江学者特聘教授，国家杰出青年基金获得者。2007年创建南京大学机器学习与数据挖掘研究所（LAMDA），2010年11月任软件新技术国家重点实验室常务副主任，2013年5月任计算机系副主任。","summary":"机器学习是计算机科学与人工智能的重要分支领域. 本书作为该领域的入门教材，在内容上尽可能涵盖机器学习基础知识的各方面。 为了使尽可能多的读者通过本书对机器学习有所了解, 作者试图尽可能少地使用数学知识. 然而, 少量的概率、统计、代数、优化、逻辑知识似乎不可避免. 因此, 本书更适合大学三年级以上的理工科本科生和研究生, 以及具有类似背景的对机器学 习感兴趣的人士. 为方便读者, 本书附录给出了一些相关数学基础知识简介.\n全书共16 章，大致分为3 个部分：第1 部分（第1～3 章）介绍机器学习的基础知识；第2 部分（第4～10 章）讨论一些经典而常用的机器学习方法（决策树、神经网络、支持向量机、贝叶斯分类器、集成学习、聚类、降维与度量学习）；第3 部分（第11～16 章）为进阶知识，内容涉及特征选择与稀疏学习、计算学习理论、半监督学习、概率图模型、规则学习以及强化学习等.前3章之外的后续各章均相对独立, 读者可根据自己的兴趣和时间情况选择使用. 根据课时情况, 一个学期的本科生课程可考虑讲授前9章或前10章; 研究生课程则不妨使用全书.\n书中除第1章外, 每章都给出了十道习题. 有的习题是帮助读者巩固本章学习, 有的是为了引导读者扩展相关知识. 一学期的一般课程可使用这些习题, 再辅以两到三个针对具体数据集的大作业. 带星号的习题则有相当难度, 有些并无现成答案, 谨供富有进取心的读者启发思考.\n本书可作为高等院校计算机、自动化及相关专业的本科生或研究生教材，也可供对机器学习感兴趣的研究人员和工程技术人员阅读参考。","price":"88.00元"},"9787302275954":{"rating":{"max":10,"numRaters":1597,"average":"9.0","min":0},"subtitle":"","author":["李航"],"pubdate":"2012-3","tags":[{"count":2145,"name":"机器学习","title":"机器学习"},{"count":1652,"name":"统计学习","title":"统计学习"},{"count":734,"name":"数据挖掘","title":"数据挖掘"},{"count":711,"name":"统计学","title":"统计学"},{"count":585,"name":"数学","title":"数学"},{"count":556,"name":"统计","title":"统计"},{"count":531,"name":"计算机","title":"计算机"},{"count":525,"name":"MachineLearning","title":"MachineLearning"}],"origin_title":"","image":"https://img3.doubanio.com/view/subject/m/public/s9108113.jpg","binding":"平装","translator":[],"catalog":"第1章 统计学习方法概论\n1.1 统计学习\n1.2 监督学习\n1.3 统计学习三要素\n1.4 模型评估与模型选择\n1.5 i~则化与交叉验证\n1.6 泛化能力\n1.7 生成模型与判别模型\n1.8 分类问题\n1.9 标注问题\n1.10 回归问题\n本章概要\n继续阅读\n习题\n参考文献\n第2章 感知机\n2.1 感知机模型\n2.2 感知机学习策略\n2.3 感知机学习算法\n本章概要\n继续阅读\n习题\n参考文献\n第3章 众近邻法\n3.1 k近邻算法\n3.2 k近邻模型\n3.3 k近邻法的实现：kd树\n本章概要\n继续阅读\n习题\n参考文献\n第4章 朴素贝叶斯法\n4.1 朴素贝叶斯法的学习与分类\n4.2 朴素贝叶斯法的参数估计\n本章概要\n继续阅读\n习题\n参考文献\n第5章 决策树\n第6章 逻辑斯谛回归与最大熵模型\n第7章 支持向量机\n第8章 提升方法\n第9章 em算法及其推广\n第10章 隐马尔可夫模型\n第11章 条件随机场\n第12章 统计学习方法总结\n附录a 梯度下降法\n附录b 牛顿法和拟牛顿法\n附录c 拉格朗日对偶性\n索引","pages":"235","images":{"small":"https://img3.doubanio.com/view/subject/s/public/s9108113.jpg","large":"https://img3.doubanio.com/view/subject/l/public/s9108113.jpg","medium":"https://img3.doubanio.com/view/subject/m/public/s9108113.jpg"},"alt":"https://book.douban.com/subject/10590856/","id":"10590856","publisher":"清华大学出版社","isbn10":"7302275955","isbn13":"9787302275954","title":"统计学习方法","url":"https://api.douban.com/v2/book/10590856","alt_title":"","author_intro":"李航 日本京都大学电气工程系毕业，日本东京大学计算机科学博士。曾任职于日本NEC公司中央研究所，微软亚洲研究院高级研究员及主任研究员，现任华为诺亚方舟实验室首席科学家。北京大学、南开大学、西安交通大学客座教授。研究方向包括信息检索、自然语言处理、统计机器学习及数据挖掘。","summary":"详细介绍支持向量机、Boosting、最大熵、条件随机场等十个统计学习方法。","price":"38.00元"},"9787121310928":{"rating":{"max":10,"numRaters":93,"average":"9.3","min":0},"subtitle":"","author":["何海涛"],"pubdate":"2017-5","tags":[{"count":92,"name":"面试","title":"面试"},{"count":65,"name":"算法","title":"算法"},{"count":57,"name":"计算机","title":"计算机"},{"count":51,"name":"编程","title":"编程"},{"count":41,"name":"数据结构","title":"数据结构"},{"count":32,"name":"找工作","title":"找工作"},{"count":21,"name":"工作","title":"工作"},{"count":20,"name":"计算机科学","title":"计算机科学"}],"origin_title":"","image":"https://img3.doubanio.com/view/subject/m/public/s29413793.jpg","binding":"平装","translator":[],"catalog":"第1章  面试的流程\t1\n1.1  面试官谈面试\t1\n1.2  面试的3种形式\t2\n1.2.1  电话面试\t2\n1.2.2  共享桌面远程面试\t3\n1.2.3  现场面试\t4\n1.3  面试的3个环节\t5\n1.3.1  行为面试环节\t5\n1.3.2  技术面试环节\t10\n1.3.3  应聘者提问环节\t17\n1.4  本章小结\t18\n第2章  面试需要的基础知识\t20\n2.1  面试官谈基础知识\t20\n2.2  编程语言\t21\n2.2.1  C++\t22\n2.2.2  C#\t27\n2.3  数据结构\t36\n2.3.1  数组\t36\n2.3.2  字符串\t47\n2.3.3  链表\t55\n2.3.4  树\t59\n2.3.5  栈和队列\t67\n2.4  算法和数据操作\t71\n2.4.1  递归和循环\t72\n2.4.2  查找和排序\t78\n2.4.3  回溯法\t87\n2.4.4  动态规划与贪婪算法\t93\n2.4.5  位运算\t98\n2.5  本章小结\t103\n第3章  高质量的代码\t104\n3.1  面试官谈代码质量\t104\n3.2  代码的规范性\t105\n3.3  代码的完整性\t106\n3.4  代码的鲁棒性\t132\n3.5  本章小结\t151\n第4章  解决面试题的思路\t153\n4.1  面试官谈面试思路\t153\n4.2  画图让抽象问题形象化\t154\n4.3  举例让抽象问题具体化\t163\n4.4  分解让复杂问题简单化\t184\n4.5  本章小结\t199\n第5章  优化时间和空间效率\t201\n5.1  面试官谈效率\t201\n5.2  时间效率\t202\n5.3  时间效率与空间效率的平衡\t237\n5.4  本章小结\t254\n第6章  面试中的各项能力\t256\n6.1  面试官谈能力\t256\n6.2  沟通能力和学习能力\t257\n6.3  知识迁移能力\t260\n6.4  抽象建模能力\t293\n6.5  发散思维能力\t305\n6.6  本章小结\t313\n第7章  两个面试案例\t315\n7.1  案例一：（面试题67）把字符串转换成整数\t316\n7.2  案例二：（面试题68）树中两个节点的最低公共祖先\t324","pages":"348","images":{"small":"https://img3.doubanio.com/view/subject/s/public/s29413793.jpg","large":"https://img3.doubanio.com/view/subject/l/public/s29413793.jpg","medium":"https://img3.doubanio.com/view/subject/m/public/s29413793.jpg"},"alt":"https://book.douban.com/subject/27008702/","id":"27008702","publisher":"电子工业出版社","isbn10":"7121310929","isbn13":"9787121310928","title":"剑指Offer：名企面试官精讲典型编程题（第2版）","url":"https://api.douban.com/v2/book/27008702","alt_title":"","author_intro":"何海涛，现美国微软总部资深软件工程师，先后在Autodesk、思科、微软中国等跨国企业任职。著有《剑指Offer——名企面试官精讲典型编程题》、《Coding Interviews: Questions, Analysis and Solutions》（本书英文版）等书。多年来从事软件开发工作，对软件设计、开发、调试等均有较深的功底，对 C/C++、C#以及.NET等语言及平台都较为熟悉，对图形图像、CAD、设计模式、项目管理等领域均有专业经验。","summary":"《剑指Offer：名企面试官精讲典型编程题（第2版）》剖析了80个典型的编程面试题，系统整理基础知识、代码质量、解题思路、优化效率和综合能力这5个面试要点。《剑指Offer：名企面试官精讲典型编程题（第2版）》共分7章，主要包括面试的流程，讨论面试每一环节需要注意的问题；面试需要的基础知识，从编程语言、数据结构及算法三方面总结程序员面试知识点；高质量的代码，讨论影响代码质量的3个要素（规范性、完整性和鲁棒性），强调高质量代码除完成基本功能外，还能考虑特殊情况并对非法输入进行合理处理；解决面试题的思路，总结编程面试中解决难题的有效思考模式，如在面试中遇到复杂难题，应聘者可利用画图、举例和分解这3种方法将其化繁为简，先形成清晰思路，再动手编程；优化时间和空间效率，读者将学会优化时间效率及用空间换时间的常用算法，从而在面试中找到最优解；面试中的各项能力，总结应聘者如何充分表现学习和沟通能力，并通过具体面试题讨论如何培养知识迁移、抽象建模和发散思维能力；两个面试案例，总结哪些面试举动是不良行为，而哪些表现又是面试官所期待的行为。","price":"65.00"},"9787302356288":{"rating":{"max":10,"numRaters":192,"average":"8.9","min":0},"subtitle":"","author":["刘汝佳"],"pubdate":"2014-6-1","tags":[{"count":202,"name":"算法","title":"算法"},{"count":114,"name":"编程","title":"编程"},{"count":97,"name":"计算机","title":"计算机"},{"count":97,"name":"ACM","title":"ACM"},{"count":82,"name":"算法竞赛","title":"算法竞赛"},{"count":73,"name":"数据结构与算法","title":"数据结构与算法"},{"count":60,"name":"计算机科学","title":"计算机科学"},{"count":50,"name":"Algorithms","title":"Algorithms"}],"origin_title":"刘汝佳","image":"https://img3.doubanio.com/view/subject/m/public/s28393836.jpg","binding":"平装","translator":[],"catalog":"第1部分　语言篇\n第1章　程序设计入门 1\n1.1 算术表达式 1\n1.2 变量及其输入 3\n1.3 顺序结构程序设计 6\n1.4 分支结构程序设计 9\n1.5 注解与习题 13\n1.5.1 C语言、C99、C11及其他 13\n1.5.2 数据类型与输入格式 14\n1.5.3 习题 15\n1.5.4 小结 16\n第2章　循环结构程序设计 18\n2.1 for循环 18\n2.2 while循环和do-while循环 22\n2.3 循环的代价 25\n2.4 算法竞赛中的输入输出框架 27\n2.5 注解与习题 34\n2.5.1 习题 34\n2.5.2 小结 36\n第3章　数组和字符串 37\n3.1 数组 37\n3.2 字符数组 41\n3.3 竞赛题目选讲 45\n3.4 注解与习题 53\n3.4.1 进位制与整数表示 54\n3.4.2 思考题 55\n3.4.3 黑盒测试和在线评测系统 55\n3.4.4 例题一览与习题 56\n3.4.5 小结 59\n第4章　函数和递归 61\n4.1 自定义函数和结构体 61\n4.2 函数调用与参数传递 65\n4.2.1 形参与实参 65\n4.2.2 调用栈 66\n4.2.3 用指针作参数 69\n4.2.4 初学者易犯的错误 71\n4.2.5 数组作为参数和返回值 71\n4.2.6 把函数作为函数的参数 73\n4.3 递归 74\n4.3.1 递归定义 74\n4.3.2 递归函数 75\n4.3.3 C语言对递归的支持 75\n4.3.4 段错误与栈溢出 77\n4.4 竞赛题目选讲 79\n4.5 注解与习题 92\n4.5.1 头文件、副作用及其他 93\n4.5.2 例题一览和习题 95\n4.5.3 小结 99\n第5章　 C++与STL入门 100\n5.1 从C到C++ 100\n5.1.1 C++版框架 101\n5.1.2 引用 102\n5.1.3 字符串 103\n5.1.4 再谈结构体 105\n5.1.5 模板 106\n5.2 STL初步 108\n5.2.1 排序与检索 108\n5.2.2 不定长数组：vector 109\n5.2.3 集合：set 112\n5.2.4 映射：map 113\n5.2.5 栈、队列与优先队列 115\n5.2.6 测试STL 120\n5.3 应用：大整数类 123\n5.3.1 大整数类BigInteger 124\n5.3.2 四则运算 125\n5.3.3 比较运算符 126\n5.4 竞赛题目举例 127\n5.5 习题 134\n第2部分　基础篇\n第6章　数据结构基础 139\n6.1 再谈栈和队列 139\n6.2 链表 143\n6.3 树和二叉树 148\n6.3.1 二叉树的编号 148\n6.3.2 二叉树的层次遍历 150\n6.3.3 二叉树的递归遍历 155\n6.3.4 非二叉树 160\n6.4 图 162\n6.4.1 用DFS求连通块 162\n6.4.2 用BFS求最短路 164\n6.4.3 拓扑排序 167\n6.4.4 欧拉回路 168\n6.5 竞赛题目选讲 170\n6.6 训练参考 175\n第7章　暴力求解法 182\n7.1 简单枚举 182\n7.2 枚举排列 184\n7.2.1 生成1~n的排列 184\n7.2.2 生成可重集的排列 185\n7.2.3 解答树 186\n7.2.4 下一个排列 187\n7.3 子集生成 188\n7.3.1 增量构造法 188\n7.3.2 位向量法 188\n7.3.3 二进制法 189\n7.4 回溯法 191\n7.4.1 八皇后问题 191\n7.4.2 其他应用举例 194\n7.5 路径寻找问题 198\n7.6 迭代加深搜索 206\n7.7 竞赛题目选讲 209\n7.8 训练参考 213\n第3部分　竞赛篇\n第8章　高效算法设计 220\n8.1 算法分析初步 220\n8.1.1 渐进时间复杂度 220\n8.1.2 上界分析 222\n8.1.3 分治法 223\n8.1.4 正确对待算法分析结果 224\n8.2 再谈排序与检索 225\n8.2.1 归并排序 225\n8.2.2 快速排序 227\n8.2.3 二分查找 227\n8.3 递归与分治 229\n8.4 贪心法 231\n8.4.1 背包相关问题 231\n8.4.2 区间相关问题 232\n8.4.3 Huffman编码 234\n8.5 算法设计与优化策略 235\n8.6 竞赛题目选讲 244\n8.7 训练参考 252\n第9章　动态规划初步 259\n9.1 数字三角形 259\n9.1.1 问题描述与状态定义 259\n9.1.2 记忆化搜索与递推 260\n9.2 DAG上的动态规划 262\n9.2.1 DAG模型 262\n9.2.2 最长路及其字典序 262\n9.2.3 固定终点的最长路和最短路 264\n9.2.4 小结与应用举例 267\n9.3 多阶段决策问题 270\n9.3.1 多段图的最短路 270\n9.3.2 0-1背包问题 271\n9.4 更多经典模型 274\n9.4.1 线性结构上的动态规划 274\n9.4.2 树上的动态规划 280\n9.4.3 复杂状态的动态规划 284\n9.5 竞赛题目选讲 290\n9.6 训练参考 303\n第10章　数学概念与方法 310\n10.1 数论初步 310\n10.1.1 欧几里德算法和唯一分解定理 310\n10.1.2 Eratosthenes筛法 312\n10.1.3 扩展欧几里德算法 313\n10.1.4 同余与模算术 314\n10.1.5 应用举例 316\n10.2 计数与概率基础 318\n10.2.1 杨辉三角与二项式定理 319\n10.2.2 数论中的计数问题 321\n10.2.3 编码与解码 323\n10.2.4 离散概率初步 324\n10.3 其他数学专题 327\n10.3.1 递推 327\n10.3.2 数学期望 332\n10.3.3 连续概率 334\n10.4 竞赛题目选讲 336\n10.5 训练参考 341\n第11章　图论模型与算法 352\n11.1 再谈树 352\n11.1.1 无根树转有根树 352\n11.1.2 表达式树 353\n11.2 最小生成树 355\n11.2.1 Kruskal算法 356\n11.2.2 竞赛题目选解 358\n11.3 最短路问题 359\n11.3.1 Dijkstra算法 359\n11.3.2 Bellman-Ford算法 363\n11.3.3 Floyd算法 364\n11.3.4 竞赛题目选讲 365\n11.4 网络流初步 366\n11.4.1 最大流问题 366\n11.4.2 增广路算法 367\n11.4.3 最小割最大流定理 369\n11.4.4 最小费用最大流问题 370\n11.4.5 应用举例 372\n11.5 竞赛题目选讲 375\n11.6 训练参考 379\n11.7 总结与展望 384\n第12章　高级专题 386\n12.1 知识点选讲 386\n12.1.1 自动机 386\n12.1.2 树的经典问题和方法 392\n12.1.3 可持久化数据结构 397\n12.1.4 多边形的布尔运算 399\n12.2 难题选解 404\n12.2.1 数据结构 404\n12.2.2 网络流 409\n12.2.3 数学 411\n12.2.4 几何 415\n12.2.5 非完美算法 419\n12.2.6 杂题选讲 423\n12.3 小结与习题 446\n附录A 开发环境与方法 455\nA.1 命令行 455\nA.1.1 文件系统 455\nA.1.2 进程 456\nA.1.3 程序的执行 456\nA.1.4 重定向和管道 457\nA.1.5 常见命令 457\nA.2 操作系统脚本编程入门 458\nA.2.1 Windows下的批处理 458\nA.2.2 Linux下的Bash脚本 459\nA.2.3 再谈随机数 460\nA.3 编译器和调试器 460\nA.3.1 gcc的安装和测试 460\nA.3.2 常见编译选项 461\nA.3.3 gdb简介 462\nA.3.4 gdb的高级功能 463\nA.4 浅谈IDE 464\n主要参考书目 465","pages":"464","images":{"small":"https://img3.doubanio.com/view/subject/s/public/s28393836.jpg","large":"https://img3.doubanio.com/view/subject/l/public/s28393836.jpg","medium":"https://img3.doubanio.com/view/subject/m/public/s28393836.jpg"},"alt":"https://book.douban.com/subject/25902102/","id":"25902102","publisher":"清华大学出版社","isbn10":"7302356289","isbn13":"9787302356288","title":"算法竞赛入门经典（第2版）","url":"https://api.douban.com/v2/book/25902102","alt_title":"刘汝佳","author_intro":"刘汝佳，1982年12月生，高中毕业于重庆市外国语学校。2000年3月获得NOI2000全国青少年信息学奥林匹克竞赛一等奖第四名，进入国家集训队，并因此保送到清华大学计算机科学与技术系。大一时获2001年ACM/ICPC国际大学生程序设计竞赛亚洲-上海赛区冠军和2002年世界总决赛银牌（世界第四），2005年获学士学位，2008年获硕士学位。\n学生时代曾为中国计算机学会NOI科学委员会学生委员，担任IOI2002-2008中国国家队教练，并为NOI系列比赛命题十余道。现为NOI竞赛委员会委员，并在NOI 25周年时获得中国计算机学会颁发的“特别贡献奖”。\n2004年至今共为ACM/ICPC亚洲赛区命题二十余道，担任6次裁判和2次命题总监，并应邀参加IOI和ACM/ICPC相关国际研讨会，发表论文两篇。\n2004年初作为第一作者出版专著《算法艺术与信息学竞赛》，2009年出版译著《编程挑战》，2009年出版《算法竞赛入门经典》，2012年出版《算法竞赛入门经典——训练指南》。\n多年来在全国二十余个城市进行中学生竞赛培训工作，为北京、上海、吉隆坡等地的著名高校授课与宣讲，并多次与TopCoder、百度和网易有道等知名企业合作举办比赛，让更多的IT人才获得展示自我的平台。","summary":"《算法竞赛入门经典（第2版）》是一本算法竞赛的入门与提高教材，把C/C++语言、算法和解题有机地结合在一起，淡化理论，注重学习方法和实践技巧。全书内容分为12 章，包括程序设计入门、循环结构程序设计、数组和字符串、函数和递归、C++与STL入门、数据结构基础、暴力求解法、高效算法设计、动态规划初步、数学概念与方法、图论模型与算法、高级专题等内容，覆盖了算法竞赛入门和提高所需的主要知识点，并含有大量例题和习题。书中的代码规范、简洁、易懂，不仅能帮助读者理解算法原理，还能教会读者很多实用的编程技巧；书中包含的各种开发、测试和调试技巧也是传统的语言、算法类书籍中难以见到的。\n《算法竞赛入门经典（第2版）》可作为全国青少年信息学奥林匹克联赛（NOIP）复赛教材、全国青少年信息学奥林匹克竞赛（NOI）和ACM国际大学生程序设计竞赛（ACM/ICPC）的训练资料，也可作为IT工程师与科研人员的参考用书。","price":"CNY 49.80"},"9787121060748":{"rating":{"max":10,"numRaters":3009,"average":"8.3","min":0},"subtitle":"微软技术面试心得","author":["《编程之美》小组 编"],"pubdate":"2008-3","tags":[{"count":2211,"name":"算法","title":"算法"},{"count":1537,"name":"编程之美","title":"编程之美"},{"count":1508,"name":"编程","title":"编程"},{"count":1056,"name":"面试","title":"面试"},{"count":995,"name":"计算机","title":"计算机"},{"count":638,"name":"程序设计","title":"程序设计"},{"count":527,"name":"微软","title":"微软"},{"count":488,"name":"思维","title":"思维"}],"origin_title":"","image":"https://img3.doubanio.com/view/subject/m/public/s2992671.jpg","binding":"平装","translator":[],"catalog":"第1章 游戏之乐--游戏中碰到的题目\n1.1 让CPU占用率曲线听你指挥\n1.2 中国象棋将帅问题\n1.3 一摞烙饼的排序\n1.4 买书问题\n1.5 快速找出故障机器\n1.6 饮料供货\n1.7 光影切割问题\n1.8 小飞的电梯调度算法\n1.9 高效率地安排见面会\n1.10 双线程高效下载\n1.11 NIM（1）一排石头的游戏\n1.12 NIM（2）“拈”游戏分析\n1.13 NIM（3）两堆石头的游戏\n1.14 连连看游戏设计\n1.15 构造数独\n1.16 24点游戏\n1.17 俄罗斯方块游戏\n1.18 挖雷游戏\n第2章 数字之魅--数字中的技巧\n2.1 求二进制数中1的个数\n2.2 不要被阶乘吓倒\n2.3 寻找发帖“水王”\n2.4 1的数目\n2.5 寻找最大的K个数\n2.6 精确表达浮点数\n2.7 最大公约数问题\n2.8 找符合条件的整数\n2.9 斐波那契（Fibonacci）数列\n2.10 寻找数组中的最大值和最小值\n2.11 寻找最近点对\n2.12 快速寻找满足条件的两个数\n2.13 子数组的最大乘积\n2.14 求数组的子数组之和的最大值\n2.15 子数组之和的最大值（二维）\n2.16 求数组中最长递增子序列\n2.17 数组循环移位\n2.18 数组分割\n2.19 区间重合判断\n2.20 程序理解和时间分析\n2.21 只考加法的面试题\n第3章 结构之法--字符串及链表的探索\n3.1 字符串移位包含的问题\n3.2 电话号码对应英语单词\n3.3 计算字符串的相似度\n3.4 从无头单链表中删除节点\n3.5 最短摘要的生成\n3.6 编程判断两个链表是否相交\n3.7 队列中取最大值操作问题\n3.8 求二叉树中节点的最大距离\n3.9 重建二叉树\n3.10 分层遍历二叉树\n3.11 程序改错\n第4章 数学之趣--数学游戏的乐趣\n4.1 金刚坐飞机问题\n4.2 瓷砖覆盖地板\n4.3 买票找零\n4.4 点是否在三角形内\n4.5 磁带文件存放优化\n4.6 桶中取黑白球\n4.7 蚂蚁爬杆\n4.8 三角形测试用例\n4.9 数独知多少\n4.10 数字哑谜和回文\n4.11 挖雷游戏的概率","ebook_url":"https://read.douban.com/ebook/1523295/","pages":"327","images":{"small":"https://img3.doubanio.com/view/subject/s/public/s2992671.jpg","large":"https://img3.doubanio.com/view/subject/l/public/s2992671.jpg","medium":"https://img3.doubanio.com/view/subject/m/public/s2992671.jpg"},"alt":"https://book.douban.com/subject/3004255/","id":"3004255","publisher":"电子工业出版社","isbn10":"7121060744","isbn13":"9787121060748","title":"编程之美","url":"https://api.douban.com/v2/book/3004255","alt_title":"","author_intro":"","summary":"这本书收集了约60道算法和程序设计题目，这些题目大部分在近年的笔试、面试中出现过，或者是被微软员工热烈讨论过。作者试图从书中各种有趣的问题出发，引导读者发现问题，分析问题，解决问题，寻找更优的解法。本书的内容分为下面几个部分：\n（1）游戏之乐：从游戏和其他有趣问题出发，化繁为简，分析总结。\n（2）数字之魅：编程的过程实际上就是和数字及字符打交道的过程。这一部分收集了一些好玩的对数字进行处理的题目。\n（3）结构之法：汇集了常见的对字符串、链表、队列，以及树等进行操作的题目。\n（4）数学之趣：列举了一些不需要写具体程序的数学问题，锻炼读者的抽象思维能力。\n书中绝大部分题目都提供了详细的解说。 每道题目后面还有一至两道扩展问题，供读者进一步钻研。\n书中还讲述了面试的各种小故事，告诉读者微软需要什么样的技术人才，重视什么样的能力，如何甄别人才。回答读者关于IT业面试，招聘，职业发展的疑问。这本书的很多题目会出现在IT 行业的各种笔试、面试中，但这本书更深层的意义在于引导读者思考，和读者共享思考之乐，编程之美。","ebook_price":"22.00","price":"40.00元"},"9787115281487":{"rating":{"max":10,"numRaters":1343,"average":"8.6","min":0},"subtitle":"权威指南","author":["David Gourley","Brian Totty"],"pubdate":"2012-9","tags":[{"count":2141,"name":"HTTP","title":"HTTP"},{"count":995,"name":"网络","title":"网络"},{"count":760,"name":"计算机","title":"计算机"},{"count":613,"name":"互联网","title":"互联网"},{"count":585,"name":"协议","title":"协议"},{"count":531,"name":"web开发","title":"web开发"},{"count":311,"name":"基础理论","title":"基础理论"},{"count":246,"name":"编程","title":"编程"}],"origin_title":"HTTP: The Definitive Guide","image":"https://img1.doubanio.com/view/subject/m/public/s11329547.jpg","binding":"Paperback","translator":["陈涓","赵振平"],"catalog":"目录\n第一部分 　HTTP：Web 的基础\n第1章 　HTTP 概述　　3\n1.1 　HTTP——因特网的多媒体信使 　 　4\n1.2 　Web 客户端和服务器  4\n1.3 　资源　　 5\n1.3.1 　媒体类型 　 　6\n1.3.2 　URI 　 　7\n1.3.3 　URL　　7\n1.3.4 　URN　　8\n1.4 　事务　　 9\n1.4.1 　方法　　9\n1.4.2 　状态码 　 　10\n1.4.3 　Web 页面中可以包含多个对象  10\n1.5 　报文　　11\n1.6 　连接　　13\n1.6.1 　TCP/IP 　 　13\n1.6.2 　连接、IP 地址及端口号 　 　14\n1.6.3 　使用Telnet 实例 　 　16\n1.7 　协议版本　　18\n1.8 　Web 的结构组件 　 　19\n1.8.1 　代理 　 　19\n1.8.2 　缓存 　 　20\n1.8.3 　网关 　 　20\n1.8.4 　隧道 　 　21\n1.8.5 　Agent 代理 　 　21\n1.9 　起始部分的结束语 　 　22\n1.10 　更多信息　　22\n1.10.1 　HTTP 协议信息  22\n1.10.2 　历史透视 　 　23\n1.10.3 　其他万维网信息 　 　23\n第2章 URL 与资源 　 　25\n2.1 　浏览因特网资源 　 　26\n2.2 　URL 的语法 　 　28\n2.2.1 　方案——使用什么协议 　 　29\n2.2.2 　主机与端口 　 　30\n2.2.3 　用户名和密码 　 　30\n2.2.4 　路径 　 　31\n2.2.5 　参数 　 　31\n2.2.6 　查询字符串 　 　32\n2.2.7 　片段 　 　33\n2.3 　URL 快捷方式 　 　34\n2.3.1 　相对URL  34\n2.3.2 　自动扩展URL  37\n2.4 　各种令人头疼的字符 　 　38\n2.4.1 　URL 字符集  38\n2.4.2 　编码机制  38\n2.4.3 　字符限制  39\n2.4.4 　另外一点说明 　 　40\n2.5 　方案的世界　　40\n2.6 　未来展望　　42\n2.7 　更多信息　　44\n第3章 　HTTP 报文 　 　45\n3.1 　报文流 　 　46\n3.1.1 　报文流入源端服务器 　 　46\n3.1.2 　报文向下游流动 　 　47\n3.2 　报文的组成部分 　 　47\n3.2.1 　报文的语法 　 　48\n3.2.2 　起始行 　 　50\n3.2.3 　首部 　 　53\n3.2.4 　实体的主体部分 　 　55\n3.2.5 　版本0.9 的报文 　 　55\n3.3 　方法　　56\n3.3.1 　安全方法  56\n3.3.2 　GET　　56\n3.3.3 　HEAD 　 　57\n3.3.4 　PUT　　57\n3.3.5 　POST 　 　58\n3.3.6 　TRACE 　 　58\n3.3.7 　OPTIONS 60\n3.3.8 　DELETE 　 　60\n3.3.9 　扩展方法  61\n3.4 　状态码 　 　62\n3.4.1 　100 ～ 199——信息性状态码 　 　62\n3.4.2 　200 ～ 299——成功状态码 　 　63\n3.4.3 　300 ～ 399——重定向状态码 　 　64\n3.4.4 　400 ～ 499——客户端错误状态码 　 　68\n3.4.5 　500 ～ 599——服务器错误状态码 　 　69\n3.5 　首部　　70\n3.5.1 　通用首部  71\n3.5.2 　请求首部  72\n3.5.3 　响应首部  74\n3.5.4 　实体首部  75\n3.6 　更多信息　　77\n第4章 　连接管理 　 　79\n4.1 　TCP 连接 　 　80\n4.1.1 　TCP 的可靠数据管道 　 　80\n4.1.2 　TCP 流是分段的、由IP 分组传送  81\n4.1.3 　保持TCP 连接的正确运行 　 　82\n4.1.4 　用TCP 套接字编程  84\n4.2 　对TCP 性能的考虑  85\n4.2.1 　HTTP 事务的时延 　 　86\n4.2.2 　性能聚焦区域 　 　87\n4.2.3 　TCP 连接的握手时延 　 　87\n4.2.4 　延迟确认  88\n4.2.5 　TCP 慢启动 　 　89\n4.2.6 　Nagle 算法与TCP_NODELAY 　 　89\n4.2.7 　TIME_WAIT 累积与端口耗尽 　 　90\n4.3 　HTTP 连接的处理 　 　91\n4.3.1 　常被误解的Connection 首部  91\n4.3.2 　串行事务处理时延 　 　92\n4.4 　并行连接　　94\n4.4.1 　并行连接可能会提高页面的加载速度 　 　94\n4.4.2 　并行连接不一定更快 　 　95\n4.4.3 　并行连接可能让人“感觉”更快一些 　 　95\n4.5 　持久连接　　96\n4.5.1 　持久以及并行连接 　 　96\n4.5.2 　HTTP/1.0+ keep-alive 连接 　 　97\n4.5.3 　Keep-Alive 操作 　 　98\n4.5.4 　Keep-Alive 选项 　 　98\n4.5.5 　Keep-Alive 连接的限制和规则 　 　99\n4.5.6 　Keep-Alive 和哑代理  100\n4.5.7 　插入Proxy-Connection  102\n4.5.8 　HTTP/1.1 持久连接 　 　104\n4.5.9 　持久连接的限制和规则  104\n4.6 　管道化连接 　 　105\n4.7 　关闭连接的奥秘  106\n4.7.1 “ 任意”解除连接  106\n4.7.2 　Content-Length 及截尾操作 　 　107\n4.7.3 　连接关闭容限、重试以及幂等性  107\n4.7.4 　正常关闭连接  108\n4.8 　更多信息　　110\n4.8.1 　HTTP 连接  110\n4.8.2 　HTTP 性能问题  110\n4.8.3 　TCP/IP　　111\n第二部分 　HTTP 结构\n第5章 　Web 服务器  115\n5.1 　各种形状和尺寸的Web 服务器  116\n5.1.1 　Web 服务器的实现  116\n5.1.2 　通用软件Web 服务器 　 　117\n5.1.3 　Web 服务器设备  117\n5.1.4 　嵌入式Web 服务器 　 　118\n5.2 　最小的Perl Web 服务器  118\n5.3 　实际的Web 服务器会做些什么  120\n5.4 　第一步——接受客户端连接  121\n5.4.1 　处理新连接  121\n5.4.2 　客户端主机名识别  122\n5.4.3 　通过ident 确定客户端用户  122\n5.5 　第二步——接收请求报文  123\n5.5.1 　报文的内部表示法  124\n5.5.2 　连接的输入/ 输出处理结构 　 　125\n5.6 　第三步——处理请求  126\n5.7 　第四步——对资源的映射及访问 　 　126\n5.7.1 　docroot 　 　127\n5.7.2 　目录列表 　 　129\n5.7.3 　动态内容资源的映射  130\n5.7.4 　服务器端包含项  131\n5.7.5 　访问控制 　 　131\n5.8 　第五步——构建响应  131\n5.8.1 　响应实体 　 　131\n5.8.2 　MIME 类型 132\n5.8.3 　重定向 　 　133\n5.9 　第六步——发送响应  134\n5.10 　第七步——记录日志 　 　134\n5.11 　更多信息　　134\n第6章 　代理 　 　135\n6.1 　Web 的中间实体  136\n6.1.1 　私有和共享代理  136\n6.1.2 　代理与网关的对比  137\n6.2 　为什么使用代理  138\n6.3 　代理会去往何处  143\n6.3.1 　代理服务器的部署  144\n6.3.2 　代理的层次结构  144\n6.3.3 　代理是如何获取流量的  147\n6.4 　客户端的代理设置  148\n6.4.1 　客户端的代理配置：手工配置 　 　149\n6.4.2 　客户端代理配置：PAC 文件 　 　149\n6.4.3 　客户端代理配置：WPAD 　 　150\n6.5 　与代理请求有关的一些棘手问题 　 　151\n6.5.1 　代理URI 与服务器URI 的不同 　 　151\n6.5.2 　与虚拟主机一样的问题  152\n6.5.3 　拦截代理会收到部分URI  153\n6.5.4 　代理既可以处理代理请求，也可以处理服务器请求 　 　154\n6.5.5 　转发过程中对URI 的修改  154\n6.5.6 　URI 的客户端自动扩展和主机名解析  155\n6.5.7 　没有代理时URI 的解析 155\n6.5.8 　有显式代理时URI 的解析  156\n6.5.9 　有拦截代理时URI 的解析  157\n6.6 　追踪报文　　158\n6.6.1 　Via 首部 158\n6.6.2 　TRACE 方法 　 　162\n6.7 　代理认证　　164\n6 ｜ 目录\n6.8 　代理的互操作性  165\n6.8.1 　处理代理不支持的首部和方法 　 　166\n6.8.2 　OPTIONS：发现对可选特性的支持  166\n6.8.3 　Allow 首部  167\n6.9 　更多信息　　167\n第7章 　缓存 　 　169\n7.1 　冗余的数据传输  170\n7.2 　带宽瓶颈　　170\n7.3 　瞬间拥塞　　171\n7.4 　距离时延　　172\n7.5 　命中和未命中的  173\n7.5.1 　再验证 　 　173\n7.5.2 　命中率 　 　175\n7.5.3 　字节命中率  176\n7.5.4 　区分命中和未命中的情况 　 　176\n7.6 　缓存的拓扑结构  177\n7.6.1 　私有缓存 　 　177\n7.6.2 　公有代理缓存  177\n7.6.3 　代理缓存的层次结构  179\n7.6.4 　网状缓存、内容路由以及对等缓存 　 　180\n7.7 　缓存的处理步骤  181\n7.7.1 　第一步——接收  181\n7.7.2 　第二步——解析  182\n7.7.3 　第三步——查找  182\n7.7.4 　第四步——新鲜度检测  182\n7.7.5 　第五步——创建响应  182\n7.7.6 　第六步——发送  183\n7.7.7 　第七步——日志  183\n7.7.8 　缓存处理流程图  183\n7.8 　保持副本的新鲜  183\n7.8.1 　文档过期 　 　184\n7.8.2 　过期日期和使用期  185\n7.8.3 　服务器再验证  185\n7.8.4 　用条件方法进行再验证  186\n7.8.5 　If-Modified-Since:Date 再验证 　 　187\n7.8.6 　If-None-Match：实体标签再验证 　 　189\n7.8.7 　强弱验证器  190\n7.8.8 　什么时候应该使用实体标签和最近修改日期 　 　190\n7.9 　控制缓存的能力  191\n7.9.1 　no-Store 与no-Cache 响应首部　　191\n7.9.2 　max-age 响应首部 　 　192\n7.9.3 　Expires 响应首部 　 　192\n7.9.4 　must-revalidate 响应首部  192\n7.9.5 　试探性过期  193\n7.9.6 　客户端的新鲜度限制  194\n7.9.7 　注意事项 　 　194\n7.10 　设置缓存控制 　 　195\n7.10.1 　控制Apache 的HTTP 首部 　 　195\n7.10.2 　通过HTTP-EQUIV 控制HTML 缓存 　 　196\n7.11 　详细算法　　197\n7.11.1 　使用期和新鲜生存期 　 　198\n7.11.2 　使用期的计算 　 　198\n7.11.3 　完整的使用期计算算法 　 　201\n7.11.4 　新鲜生存期计算 　 　202\n7.11.5 　完整的服务器——新鲜度算法 　 　202\n7.12 　缓存和广告 　 　204\n7.12.1 　发布广告者的两难处境 　 　204\n7.12.2 　发布者的响应 　 　204\n7.12.3 　日志迁移 　 　205\n7.12.4 　命中计数和使用限制 　 　205\n7.13 　更多信息　　205\n第8章 　集成点：网关、隧道及中继 　 　207\n8.1 　网关　　208\n8.2 　协议网关　　210\n8.2.1 　HTTP/*：服务器端Web 网关  211\n8.2.2 　HTTP/HTTPS：服务器端安全网关　　212\n8.2.3 　HTTPS/HTTP 客户端安全加速器网关 　 　212\n8.3 　资源网关　　213\n8.3.1 　CGI  215\n8.3.2 　服务器扩展API  215\n8.4 　应用程序接口和Web 服务  216\n8.5 　隧道　　217\n8.5.1 　用CONNECT 建立HTTP 隧道  217\n8.5.2 　数据隧道、定时及连接管理 　 　219\n8.5.3 　SSL 隧道 219\n8.5.4 　SSL 隧道与HTTP/HTTPS 网关的对比  220\n8.5.5 　隧道认证 　 　221\n8.5.6 　隧道的安全性考虑  221\n8.6 　中继　　222\n8.7 　更多信息　　224\n第9章 　Web 机器人  225\n9.1 　爬虫及爬行方式  226\n9.1.1 　从哪儿开始：根集  226\n9.1.2 　链接的提取以及相对链接的标准化 　 　227\n9.1.3 　避免环路的出现  228\n9.1.4 　循环与复制  228\n9.1.5 　面包屑留下的痕迹  229\n9.1.6 　别名与机器人环路  230\n9.1.7 　规范化URL 　 　230\n9.1.8 　文件系统连接环路  231\n9.1.9 　动态虚拟Web 空间 　 　232\n9.1.10 　避免循环和重复 　 　233\n9.2 　机器人的HTTP  236\n9.2.1 　识别请求首部  236\n9.2.2 　虚拟主机 　 　236\n9.2.3 　条件请求 　 　237\n9.2.4 　对响应的处理  238\n9.2.5 　User-Agent 导向  239\n9.3 　行为不当的机器人  239\n9.4 　拒绝机器人访问  240\n9.4.1 　拒绝机器人访问标准  241\n9.4.2 　Web 站点和robots.txt 文件  242\n9.4.3 　robots.txt 文件的格式  243\n9.4.4 　其他有关robots.txt 的知识  246\n9.4.5 　缓存和robots.txt 的过期 　 　246\n9.4.6 　拒绝机器人访问的Perl 代码 　 　246\n9.4.7 　HTML 的robot-control 元标签 　 　249\n9.5 　机器人的规范 　 　251\n9.6 　搜索引擎　　254\n9.6.1 　大格局 　 　255\n9.6.2 　现代搜索引擎结构  255\n9.6.3 　全文索引 　 　255\n9.6.4 　发布查询请求  257\n9.6.5 　对结果进行排序，并提供查询结果 　 　258\n9.6.6 　欺诈　　258\n9.7 　更多信息　　258\n第10章 　HTTP-NG 　 　261\n10.1 　HTTP 发展中存在的问题  262\n10.2 　HTTP-NG 的活动  263\n10.3 　模块化及功能增强  263\n10.4 　分布式对象 　 　264\n10.5 　第一层——报文传输 　 　264\n10.6 　第二层——远程调用 　 　265\n10.7 　第三层——Web 应用 　 　265\n10.8 　WebMUX 　 　265\n10.9 　二进制连接协议 　 　266\n10.10 　当前的状态 　 　267\n10.11 　更多信息 　 　267\n第三部分 　识别、认证与安全\n第11章 　客户端识别与cookie 机制 　 　271\n11.1 　个性化接触 　 　272\n11.2 　HTTP 首部　　273\n11.3 　客户端IP 地址  274\n11.4 　用户登录　　275\n11.5 　胖URL　　277\n11.6 　cookie 　 　278\n11.6.1 　cookie 的类型  278\n11.6.2 　cookie 是如何工作的  279\n11.6.3 　cookie 罐：客户端的状态 　 　280\n11.6.4 　不同站点使用不同的cookie  282\n11.6.5 　cookie 成分  283\n11.6.6 　cookies 版本0（Netscape） 　 　284\n11.6.7 　cookies 版本1（RFC 2965）  285\n11.6.8 　cookie 与会话跟踪  288\n11.6.9 　cookie 与缓存  290\n11.6.10 　cookie、安全性和隐私 　 　291\n11.7 　更多信息　　292\n第12章 　基本认证机制  293\n12.1 　认证 　 　294\n12.1.1 　HTTP 的质询/ 响应认证框架 　 　294\n12.1.2 　认证协议与首部  295\n12.1.3 　安全域  296\n12.2 　基本认证　　297\n12.2.1 　基本认证实例  298\n12.2.2 　Base-64 用户名/ 密码编码 　 　298\n12.2.3 　代理认证  299\n12.3 　基本认证的安全缺陷 　 　300\n12.4 　更多信息　　301\n第13章 　摘要认证 　 　303\n13.1 　摘要认证的改进 　 　304\n13.1.1 　用摘要保护密码  304\n13.1.2 　单向摘要  306\n13.1.3 　用随机数防止重放攻击 　 　307\n13.1.4 　摘要认证的握手机制  307\n13.2 　摘要的计算 　 　308\n13.2.1 　摘要算法的输入数据  308\n13.2.2 　算法H(d) 和KD(s,d)  310\n13.2.3 　与安全性相关的数据（A1）  310\n13.2.4 　与报文有关的数据（A2）  310\n13.2.5 　摘要算法总述 　 　311\n13.2.6 　摘要认证会话  312\n13.2.7 　预授权  312\n13.2.8 　随机数的选择  315\n13.2.9 　对称认证  315\n13.3 　增强保护质量 　 　316\n13.3.1 　报文完整性保护  316\n13.3.2 　摘要认证首部  317\n13.4 　应该考虑的实际问题 　 　317\n13.4.1 　多重质询  318\n13.4.2 　差错处理  318\n13.4.3 　保护空间  318\n13.4.4 　重写URI  319\n13.4.5 　缓存 　 　319\n13.5 　安全性考虑 　 　320\n13.5.1 　首部篡改  320\n13.5.2 　重放攻击  320\n13.5.3 　多重认证机制  320\n13.5.4 　词典攻击  321\n13.5.5 　恶意代理攻击和中间人攻击  321\n13.5.6 　选择明文攻击  321\n13.5.7 　存储密码  322\n13.6 　更多信息　　322\n第14章 　安全HTTP  323\n14.1 　保护HTTP 的安全 　 　324\n14.2 　数字加密　　326\n14.2.1 　密码编制的机制与技巧 　 　326\n14.2.2 　密码 　 　327\n14.2.3 　密码机  328\n14.2.4 　使用了密钥的密码  328\n14.2.5 　数字密码  328\n14.3 　对称密钥加密技术 　 　330\n14.3.1 　密钥长度与枚举攻击  330\n14.3.2 　建立共享密钥  332\n14.4 　公开密钥加密技术 　 　332\n14.4.1 　RSA 　 　333\n14.4.2 　混合加密系统和会话密钥 　 　334\n14.5 　数字签名　　334\n14.6 　数字证书　　336\n14.6.1 　证书的主要内容  336\n14.6.2 　X.509 v3 证书  337\n14.6.3 　用证书对服务器进行认证 　 　338\n14.7 　HTTPS——细节介绍 　 　339\n14.7.1 　HTTPS 概述  339\n14.7.2 　HTTPS 方案  340\n14.7.3 　建立安全传输  341\n14.7.4 　SSL 握手  341\n14.7.5 　服务器证书  343\n14.7.6 　站点证书的有效性  344\n14.7.7 　虚拟主机与证书  345\n14.8 　HTTPS 客户端实例 　 　345\n14.8.1 　OpenSSL  346\n14.8.2 　简单的HTTPS 客户端 　 　347\n14.8.3 　执行OpenSSL 客户端 　 　350\n14.9 　通过代理以隧道形式传输安全流量 　 　351\n14.10 　更多信息 　 　353\n14.10.1 　HTTP 安全性 　 　353\n14.10.2 　SSL 与TLS  353\n14.10.3 　公开密钥基础设施  354\n14.10.4 　数字密码  354\n第四部分 　实体、编码和国际化\n第15章 　实体和编码  357\n15.1 　报文是箱子，实体是货物 　 　359\n15.2 　Content-Length: 实体的大小  361\n15.2.1 　检测截尾  361\n15.2.2 　错误的Content-Length 　 　362\n15.2.3 　Content-Length 与持久连接  362\n15.2.4 　内容编码  362\n15.2.5 　确定实体主体长度的规则 　 　362\n15.3 　实体摘要　　364\n15.4 　媒体类型和字符集 　 　364\n15.4.1 　文本的字符编码  365\n15.4.2 　多部分媒体类型  365\n15.4.3 　多部分表格提交  366\n15.4.4 　多部分范围响应  367\n15.5 　内容编码　　368\n15.5.1 　内容编码过程  368\n15.5.2 　内容编码类型  369\n15.5.3 　Accept-Encoding 首部 　 　369\n15.6 　传输编码和分块编码 　 　371\n15.6.1 　可靠传输  371\n15.6.2 　Transfer-Encoding 首部  372\n15.6.3 　分块编码  373\n15.6.4 　内容编码与传输编码的结合  375\n15.6.5 　传输编码的规则  375\n15.7 　随时间变化的实例 　 　375\n15.8 　验证码和新鲜度 　 　376\n15.8.1 　新鲜度  377\n15.8.2 　有条件的请求与验证码 　 　378\n15.9 　范围请求　　380\n15.10 　差异编码 　 　382\n15.11 　更多信息 　 　385\n第16章 　国际化 　 　387\n16.1 　HTTP 对国际性内容的支持  388\n16.2 　字符集与HTTP 　 　389\n16.2.1 　字符集是把字符转换为二进制码的编码　　389\n16.2.2 　字符集和编码如何工作 　 　390\n16.2.3 　字符集不对，字符就不对 　 　391\n16.2.4 　标准化的MIME charset 值 　 　391\n16.2.5 　Content-Type 首部和Charset 首部以及META 标志 　 　393\n16.2.6 　Accept-Charset 首部 　 　393\n16.3 　多语言字符编码入门 　 　394\n16.3.1 　字符集术语  394\n16.3.2 　字符集的命名很糟糕  395\n16.3.3 　字符 　 　396\n16.3.4 　字形、连笔以及表示形式 　 　396\n16.3.5 　编码后的字符集  397\n16.3.6 　字符编码方案  399\n16.4 　语言标记与HTTP  402\n16.4.1 　Content-Language 首部 　 　402\n16.4.2 　Accept-Language 首部 　 　403\n16.4.3 　语言标记的类型  404\n16.4.4 　子标记  404\n16.4.5 　大小写  405\n16.4.6 　IANA 语言标记注册 　 　405\n16.4.7 　第一个子标记——名字空间  405\n16.4.8 　第二个子标记——名字空间  406\n16.4.9 　其余子标记——名字空间 　 　407\n16.4.10 　配置和语言有关的首选项 　 　407\n16.4.11 　语言标记参考表 　 　407\n16.5 　国际化的URI 　 　408\n16.5.1 　全球性的可转抄能力与有意义的字符的较量 　 　408\n16.5.2 　URI 字符集合  408\n16.5.3 　转义和反转义  409\n16.5.4 　转义国际化字符  409\n16.5.5 　URI 中的模态切换  410\n16.6 　其他需要考虑的地方 　 　410\n16.6.1 　首部和不合规范的数据 　 　410\n16.6.2 　日期 　 　411\n16.6.3 　域名 　 　411\n16.7 　更多信息　　411\n16.7.1 　附录 　 　411\n16.7.2 　互联网的国际化  411\n16.7.3 　国际标准  412\n第17章 　内容协商与转码  413\n17.1 　内容协商技术 　 　414\n17.2 　客户端驱动的协商 　 　415\n17.3 　服务器驱动的协商 　 　415\n17.3.1 　内容协商首部集  416\n17.3.2 　内容协商首部中的质量值 　 　417\n17.3.3 　随其他首部集而变化  417\n17.3.4 　Apache 中的内容协商  417\n17.3.5 　服务器端扩展  418\n17.4 　透明协商　　419\n17.4.1 　进行缓存与备用候选  419\n17.4.2 　Vary 首部 　 　420\n17.5 　转码 　 　422\n17.5.1 　格式转换  422\n17.5.2 　信息综合  423\n17.5.3 　内容注入  423\n17.5.4 　转码与静态预生成的对比 　 　423\n17.6 　下一步计划 　 　424\n17.7 　更多信息　　424\n第五部分 　内容发布与分发\n第18章 　Web 主机托管 　 　429\n18.1 　主机托管服务 　 　430\n18.2 　虚拟主机托管 　 　431\n18.2.1 　虚拟服务器请求缺乏主机信息 　 　432\n18.2.2 　设法让虚拟主机托管正常工作 　 　433\n18.2.3 　HTTP/1.1 的Host 首部 　 　437\n18.3 　使网站更可靠 　 　438\n18.3.1 　镜像的服务器集群  438\n18.3.2 　内容分发网络  440\n18.3.3 　CDN 中的反向代理缓存  440\n18.3.4 　CDN 中的代理缓存 　 　440\n18.4 　让网站更快 　 　441\n18.5 　更多信息　　441\n第19章 　发布系统 　 　443\n19.1 　FrontPage 为支持发布而做的服务器扩展　　444\n19.1.1 　FrontPage 服务器扩展 　 　444\n19.1.2 　FrontPage 术语表 　 　445\n19.1.3 　FrontPage 的RPC 协议 　 　445\n19.1.4 　FrontPage 的安全模型 　 　448\n19.2 　WebDAV 与协作写作 　 　449\n19.2.1 　WebDAV 的方法 449\n19.2.2 　WebDAV 与XML 　 　450\n19.2.3 　WebDAV 首部集 451\n19.2.4 　WebDAV 的锁定与防止覆写 452\n19.2.5 　LOCK 方法  453\n19.2.6 　UNLOCK 方法 　 　456\n19.2.7 　属性和元数据  456\n19.2.8 　PROPFIND 方法  457\n19.2.9 　PROPPATCH 方法 　 　459\n19.2.10 　集合与名字空间管理 　 　460\n19.2.11 　MKCOL 方法  460\n19.2.12 　DELETE 方法 　 　461\n19.2.13 　COPY 与MOVE 方法 　 　462\n19.2.14 　增强的HTTP/1.1 方法 　 　465\n19.2.15 　WebDAV 中的版本管理 466\n19.2.16 　WebDAV 的未来发展  466\n19.3 　更多信息　　467\n第20章 　重定向与负载均衡 　 　469\n20.1 　为什么要重定向 　 　470\n20.2 　重定向到何地 　 　471\n20.3 　重定向协议概览 　 　471\n20.4 　通用的重定向方法 　 　474\n20.4.1 　HTTP 重定向 　 　474\n20.4.2 　DNS 重定向  475\n20.4.3 　任播寻址  480\n20.4.4 　IP MAC 转发 　 　481\n20.4.5 　IP 地址转发  482\n20.4.6 　网元控制协议  484\n20.5 　代理的重定向方法 　 　485\n20.5.1 　显式浏览器配置  485\n20.5.2 　代理自动配置  485\n20.5.3 　Web 代理自动发现协议 　 　487\n20.6 　缓存重定向方法 　 　492\n20.7 　因特网缓存协议 　 　496\n20.8 　缓存阵列路由协议 　 　497\n20.9 　超文本缓存协议 　 　500\n20.9.1 　HTCP 认证 　 　502\n20.9.2 　设置缓存策略  503\n20.10 　更多信息 　 　504\n第21章 　日志记录与使用情况跟踪 　 　505\n21.1 　记录内容　　506\n21.2 　日志格式　　507\n21.2.1 　常见日志格式  507\n21.2.2 　组合日志格式  508\n21.2.3 　网景扩展日志格式  509\n21.2.4 　网景扩展2 日志格式  510\n21.2.5 　Squid 代理日志格式 　 　512\n21.3 　命中率测量 　 　515\n21.3.1 　概述 　 　515\n21.3.2 　Meter 首部  516\n21.4 　关于隐私的考虑 　 　517\n21.5 　更多信息　　518\n第六部分 　附 　录\n附录A 　URI 方案　　521\n附录B 　HTTP 状态码 　 　529\n附录C 　HTTP 首部参考 　 　533\n附录D 　MIME 类型 　 　557\n附录E 　Base-64 编码 　 　603\n附录F 　摘要认证 　 　607\n附录G 　语言标记　　615\n附录H 　MIME 字符集注册表  641\n索引　　661","pages":"720","images":{"small":"https://img1.doubanio.com/view/subject/s/public/s11329547.jpg","large":"https://img1.doubanio.com/view/subject/l/public/s11329547.jpg","medium":"https://img1.doubanio.com/view/subject/m/public/s11329547.jpg"},"alt":"https://book.douban.com/subject/10746113/","id":"10746113","publisher":"人民邮电出版社","isbn10":"7115281483","isbn13":"9787115281487","title":"HTTP权威指南","url":"https://api.douban.com/v2/book/10746113","alt_title":"HTTP: The Definitive Guide","author_intro":"David Gourley是Endeca的首席技术官（Chief Technology Officer），负责Endeca产品的研究及开发。Endeca开发的因特网及内部网络信息访问解决方案为企业级数据的导航及研究提供了一些新的方式。在到Endeca工作之前，David是Inktomi基础工程组的一员，他在那儿帮助开发了Inktomi的因特网搜索数据库，是Inktomi的Web缓存产品的主要开发者。\nDavid在加州大学伯克利分校获得了计算机科学的学士学位，还拥有Web技术方面的几项专利。\nBrian Totty最近出任了Inktomi公司（这是1996年他参与建立的一家公司）研发部副总裁，在公司中他负责Web缓存、流媒体及因特网搜索技术的研发工作。他曾是Silicon Graphics公司的一名科学家，他在那儿为高性能网络和超级计算机系统设计软件并对其进行优化。在那之前，他是苹果计算机公司高级技术组的一名工程师。\nBrian在伊利诺伊大学Urbana-Champaign分校获得了计算机科学的博士学位，在MIT获得了计算机科学及电子工程的学士学位，在那里他获得了计算机系统研究的Organick奖。他还为加州大学扩展系统开发并讲授了一些屡获殊荣的因特网技术方面的课程。\nMarjorie Sayer在Inktomi公司负责编写Web缓存方面的软件。在加州大学伯克利分校获得了数学硕士和博士学位之后，一直致力于数学课程的改革。从1990年开始致力于能量资源管理、并行系统软件、电话和网络方面的写作。\nSailu Reddy目前在Inktomi公司负责嵌入式的性能增强型HTTP 代理的开发。Sailu从事复杂软件系统的开发已经有12年了，从1995年开始深入Web架构的研发工作。他是Netscape第一台Web服务器、Web 代理产品，以及后面几代产品的核心工程师。他具备HTTP应用程序、数据压缩技术、数据库引擎以及合作管理等方面的技术经验。Sailu在亚里桑那大学获得了信息系统的硕士学位并握有Web技术方面的多项专利。\nAnshu Aggarwal是Inktomi公司的工程总监。他领导着Inktomi公司Web缓存产品的协议处理工程组，从1997年就开始参与Inktomi的Web技术设计工作。Anshu在科罗拉多大学Boulder分校获得了计算机科学的硕士和博士学位，从事分布式多处理器的内存一致性技术研究。他还拥有电子工程的硕士和学士学位。Anshu撰写了多篇技术论文，还拥有两项专利。","summary":"超文本转移协议（Hypertext Transfer Protocol，HTTP）是在万维网上进行通信时所使用的协议方案。HTTP有很多应用，但最著名的是用于web浏览器和web服务器之间的双工通信。\nHTTP起初是一个简单的协议，因此你可能会认为关于这个协议没有太多好 说的。但现在，你手上拿着的是却一本两磅重 的书。如果你对我们怎么会写出一本650页 的关于HTTP的书感到奇怪的话，可以去看一下目录。本书不仅仅是一本HTTP首部的参考手册；它是一本名副其实的web结构圣经。\n本书中，我们尝试着将HTTP中一些互相关联且常被误解的规则梳理清楚，并编写了一系列基于各种主题的章节，对HTTP各方面的特性进行了介绍。纵观全书，我们对HTTP“为什么”这样做进行了详细的解释，而不仅仅停留在它是“怎么做”的。而且，为了节省大家寻找参考文献的时间，我们还对很多HTTP应用程序正常工作所必须的、重要的非HTTP技术进行了介绍。在组织得便于使用的附录中，可以找到按照字母排序的首部参考（这些首部构成了最常见的HTTP文本的基础）。我们希望这种概念性的设计有助于读者对HTTP的使用。\n本书是为所有希望理解HTTP以及Web底层结构的人编写的。软硬件工程师也可以将本书作为HTTP及相关web技术的条理清楚的参考书使用。系统架构师和网络管理员可以通过本书更好地了解如何设计、实现并管理复杂的网络架构。性能工程师和分析人员可以从高速缓存和性能优化的相关章节中获益。市场营销和咨询专家可以通过概念的介绍更好地理解web技术的前景。\n本书对一些常见的误解进行了说明，推荐了“各种使用诀窍”，提供了便捷的参考资料，并且对枯燥且令人费解的标准规范进行了可读性很强的介绍。在这本书里，我们对Web正常工作所必须且互相关联的技术进行了详细的介绍。\n本书是很多对因特网技术充满热情的人经过大量工作写成的。希望对你有所帮助。","price":"109.00元"},"9787115358851":{"rating":{"max":10,"numRaters":91,"average":"8.4","min":0},"subtitle":"","author":["[韩] 尹圣雨"],"pubdate":"2014-7","tags":[{"count":103,"name":"网络编程","title":"网络编程"},{"count":91,"name":"TCP/IP","title":"TCP/IP"},{"count":33,"name":"计算机","title":"计算机"},{"count":28,"name":"编程","title":"编程"},{"count":23,"name":"计算机网络","title":"计算机网络"},{"count":20,"name":"网络","title":"网络"},{"count":11,"name":"后台","title":"后台"},{"count":11,"name":"web","title":"web"}],"origin_title":"","image":"https://img3.doubanio.com/view/subject/m/public/s27309026.jpg","binding":"平装","translator":["金国哲"],"catalog":"第一部分　开始网络编程\n第1章　理解网络编程和套接字　　2\n1.1 　理解网络编程和套接字　　2\n1.2 　基于Linux的文件操作　　9\n1.3 　基于Windows平台的实现　　15\n1.4 　基于Windows的套接字相关函数及示例　　18\n1.5 　习题　　24\n第2章　套接字类型与协议设置　　26\n2.1 　套接字协议及其数据传输特性　　26\n2.2 　Windows平台下的实现及验证　　32\n2.3 　习题　　35\n第3章　地址族与数据序列　　36\n3.1 　分配给套接字的IP地址与端口号　　36\n3.2 　地址信息的表示　　39\n3.3 　网络字节序与地址变换　　42\n3.4 　网络地址的初始化与分配　　45\n3.5 　基于Windows的实现　　52\n3.6 　习题　　57\n第4章　基于TCP的服务器端/客户端（1）　　59\n4.1 　理解TCP和UDP　　59\n4.2 　实现基于TCP的服务器端/客户端　　64\n4.3 　实现迭代服务器端/客户端　　71\n4.4 　基于Windows的实现　　77\n4.5 　习题　　81\n第5章　基于TCP的服务器端/客户端（2）　　82\n5.1 　回声客户端的完美实现　　82\n5.2 　TCP原理　　91\n5.3 　基于Windows的实现　　96\n5.4 　习题　　99\n第6章　基于UDP的服务器端/客户端　　101\n6.1 　理解UDP　　101\n6.2 　实现基于UDP的服务器端/客户端　　103\n6.3 　UDP的数据传输特性和调用connect函数　　109\n6.4 　基于Windows的实现　　114\n6.5 　习题　　117\n第7章　优雅地断开套接字连接　　118\n7.1 　基于TCP的半关闭　　118\n7.2 　基于Windows的实现　　124\n7.3 　习题　　127\n第8章　域名及网络地址　　128\n8.1 　域名系统　　128\n8.2 　IP地址和域名之间的转换　　130\n8.3 　基于Windows的实现　　136\n8.4 　习题　　138\n第9章　套接字的多种可选项　　140\n9.1 　套接字可选项和I/O缓冲大小　　140\n9.2 　SO_REUSEADDR　　145\n9.3 　TCP_NODELAY　　150\n9.4 　基于Windows的实现　　152\n9.5 　习题　　154\n第10章　多进程服务器端　　155\n10.1 　进程概念及应用　　155\n10.2 　进程和僵尸进程　　159\n10.3 　信号处理　　165\n10.4 　基于多任务的并发服务器　　173\n10.5 　分割TCP的I/O程序　　178\n10.6 　习题　　182\n第11章　进程间通信　　183\n11.1 　进程间通信的基本概念　　183\n11.2 　运用进程间通信　　188\n11.3 　习题　　193\n第12章　I/O复用　　194\n12.1 　基于I/O复用的服务器端　　194\n12.2 　理解select函数并实现服务器端　　197\n12.3 　基于Windows的实现　　206\n12.4 　习题　　209\n第13章　多种I/O函数　　211\n13.1 　send & recv函数　　211\n13.2 　readv & writev函数　　221\n13.3 　基于Windows的实现　　225\n13.4 　习题　　229\n第14章　多播与广播　　230\n14.1 　多播　　230\n14.2 　广播　　236\n14.3 　基于Windows的实现　　240\n14.4 　习题　　242\n第二部分　基于Linux的编程\n第15章　套接字和标准I/O　　246\n15.1 　标准I/O函数的优点　　246\n15.2 　使用标准I/O函数　　249\n15.3 　基于套接字的标准I/O函数使用　　252\n15.4 　习题　　254\n第16章　关于I/O流分离的其他内容　　255\n16.1 　分离I/O流　　255\n16.2 　文件描述符的复制和半关闭　　259\n16.3 　习题　　264\n第17章　优于select的epoll　　265\n17.1 　epoll理解及应用　　265\n17.2 　条件触发和边缘触发　　273\n17.3 　习题　　283\n第18章　多线程服务器端的实现　　284\n18.1 　理解线程的概念　　284\n18.2 　线程创建及运行　　287\n18.3 　线程存在的问题和临界区　　296\n18.4 　线程同步　　299\n18.5 　线程的销毁和多线程并发服务器端的实现　　306\n18.6 　习题　　312\n第三部分　基于Windows的编程\n第19章　Windows平台下线程的使用　　316\n19.1 　内核对象　　316\n19.2 　基于Windows的线程创建　　317\n19.3 　内核对象的2种状态　　322\n19.4 　习题　　325\n第20章　Windows中的线程同步　　327\n20.1 　同步方法的分类及CRITICAL_SECTION同步　　327\n20.2 　内核模式的同步方法　　331\n20.3 　Windows平台下实现多线程服务器端　　339\n20.4 　习题　　343\n第21章　异步通知I/O模型　　344\n21.1 　理解异步通知I/O模型　　344\n21.2 　理解和实现异步通知I/O模型　　346\n21.3 　习题　　356\n第22章　重叠I/O模型　　357\n22.1 　理解重叠I/O模型　　357\n22.2 　重叠I/O的I/O完成确认　　362\n22.3 　习题　　370\n第23章　IOCP　　371\n23.1 　通过重叠I/O理解IOCP　　371\n23.2 　分阶段实现IOCP程序　　379\n23.3 　习题　　387\n第四部分　结束网络编程\n第24章　制作HTTP服务器端　　390\n24.1 　HTTP概要　　390\n24.2 　实现简单的Web服务器端　　394\n24.3 　习题　　401\n第25章　进阶内容　　403\n25.1 　网络编程学习的其他内容　　403\n25.2 　网络编程相关书籍介绍　　404\n索引　　406","pages":"410","images":{"small":"https://img3.doubanio.com/view/subject/s/public/s27309026.jpg","large":"https://img3.doubanio.com/view/subject/l/public/s27309026.jpg","medium":"https://img3.doubanio.com/view/subject/m/public/s27309026.jpg"},"alt":"https://book.douban.com/subject/25911735/","id":"25911735","publisher":"人民邮电出版社","isbn10":"7115358850","isbn13":"9787115358851","title":"TCP/IP网络编程","url":"https://api.douban.com/v2/book/25911735","alt_title":"","author_intro":"作者简介：\n尹圣雨\n曾为风投公司开发人员，因出版IT类书籍并开展相关讲座而闻名。2004年至今一直参与OpenGL ES图形库的建设和3D加速芯片的开发，以及Khronos Group（移动国际标准化财团）的标准制定相关业务，还参与手机DMB芯片的开发。现任（株）Axissoft公司CTO，致力于构建基于Web的解决方案。\nripeness21@gmail.com\n译者简介：\n金国哲\n毕业于重庆大学计算机学院，2009年至今在延边大学计算机系任教。\n主讲课程：Java程序设计、Android应用开发、Web程序设计等。\n主要研究方向：跨语言检索、自然语言处理等。\n曾主持并参与某部队入侵检测系统、论文自动采集及管理系统等多个软件开发项目。","summary":"第一部分主要介绍网络编程基础知识。此部分主要论述Windows和Linux平台网络编程必备基础知识，未过多涉及不同操作系统特性。\n第二部分和第三部分与操作系统有关。第二部分主要是Linux相关内容，而第三部分主要是Windows相关内容。从事Windows编程的朋友浏览第二部分内容后，同样可以提高技艺。\n第四部分对全书内容进行总结，包含了作者在自身经验基础上总结的学习建议，还介绍了网络编程经典书籍。","series":{"id":"660","title":"图灵程序设计丛书"},"price":"79.00元"},"9787115351531":{"rating":{"max":10,"numRaters":1750,"average":"8.1","min":0},"subtitle":"","author":["【日】上野宣"],"pubdate":"2014-4-15","tags":[{"count":1270,"name":"HTTP","title":"HTTP"},{"count":601,"name":"网络","title":"网络"},{"count":547,"name":"计算机","title":"计算机"},{"count":368,"name":"协议","title":"协议"},{"count":326,"name":"互联网","title":"互联网"},{"count":225,"name":"Web","title":"Web"},{"count":211,"name":"web","title":"web"},{"count":187,"name":"网络编程","title":"网络编程"}],"origin_title":"","image":"https://img3.doubanio.com/view/subject/m/public/s27283822.jpg","binding":"平装","translator":["于均良"],"catalog":"目录\n第1章　了解Web及网络基础　　001\n1.1　　使用HTTP协议访问Web　　002\n1.2　　HTTP的诞生003\n1.2.1　为知识共享而规划Web　　　　003\n1.2.2　Web成长时代　　　　004\n1.2.3　驻足不前的HTTP　　　　005\n1.3　　网络基础TCP/IP　　006\n1.3.1　TCP/IP协议族　　　　006\n1.3.2　TCP/IP的分层管理　　　　007\n1.3.3　TCP/IP通信传输流　　　　009\n1.4　　与HTTP关系密切的协议:IP、TCP和DNS　　010\n1.4.1　负责传输的IP协议　　　　011\n1.4.2　确保可靠性的TCP协议　　　　012\n1.5　　负责域名解析的DNS服务　　013\n1.6　　各种协议与HTTP协议的关系　　014\n1.7　　URI和URL　　016\n1.7.1　统一资源标识符　　016\n1.7.2　URI格式　　017\n第2章　简单的HTTP协议　　021\n2.1　　HTTP协议用于客户端和服务器端之间的通信　　022\n2.2　　通过请求和响应的交换达成通信　　022\n2.3　　HTTP是不保存状态的协议　　025\n2.4　　请求URI定位资源　　026\n2.5　　告知服务器意图的HTTP　　方法027\n2.6　　使用方法下达命令　　033\n2.7　　持久连接节省通信量　　034\n2.7.1　持久连接　　036\n2.7.2　管线化　　037\n2.8　　使用Cookie的状态管理　　037\n第3章HTTP报文内的HTTP信息　　041\n3.1HTTP报文　　042\n3.2　　请求报文及响应报文的结构　　042\n3.3　　编码提升传输速率　　044\n3.3.1　报文主体和实体主体的差异　　044\n3.3.2　压缩传输的内容编码　　044\n3.3.3　分割发送的分块传输编码　　045\n3.4　　发送多种数据的多部分对象集合　　046\n3.5　　获取部分内容的范围请求048\n3.6　　内容协商返回最合适的内容050\n第4章　返回结果的HTTP状态码　　053\n4.1　　状态码告知从服务器端返回的请求结果054\n4.2　　2XX成功　　055\n4.2.1　200　OK　　　　055\n4.2.2　204　No　Content　　　　056\n4.2.3　206　Partial　Content　　　　056\n4.3　　3XX　重定向　056\n4.3.1　301　Moved　Permanently　　057\n4.3.2　302　Found　057\n4.3.3　303　See　Other　　　　058\n4.3.4　304　Not　Modified　　059\n4.3.5　307　Temporary　Redirect　　059\n4.4　　4XX　客户端错误　　060\n4.4.1　400　Bad　Request　　060\n4.4.2　401　Unauthorized　　060\n4.4.3　403　Forbidden　　061\n4.4.4　404　Not　Found　　061\n4.5　　5XX　服务器错误　　062\n4.5.1　500　Internal　Server　Error　　062\n4.5.2　503　Service　Unavailable　　062\n第5章　与HTTP协作的Web服务器　　065\n5.1　　用单台虚拟主机实现多个域名　　066\n5.2　　通信数据转发程序：代理、网关、隧道　　067\n5.2.1　代理　　068\n5.2.2　网关　　070\n5.2.3　隧道　　070\n5.3　　保存资源的缓存　　071\n5.3.1　缓存的有效期限　　072\n5.3.2　客户端的缓存　　072\n第6章　HTTP　首部　　075\n6.1　　HTTP　报文首部　　076\n6.2　　HTTP　首部字段　　078\n6.2.1　HTTP首部字段传递重要信息　　078\n6.2.2　HTTP首部字段结构　　078\n6.2.3　4种HTTP首部字段类型　　079\n6.2.4　HTTP/1.1首部字段一览　　080\n6.2.5　非HTTP/1.1首部字段　　082\n6.2.6　　　End-to-end首部和Hop-by-hop首部　　083\n6.3　　HTTP/1.1　　通用首部字段　　083\n6.3.1　Cache-Control　　084\n6.3.2　Connection　　091\n6.3.3　Date　　093\n6.3.4　Pragma　　094\n6.3.5　Trailer　　095\n6.3.6　Transfer-Encoding　　096\n6.3.7　Upgrade　　097\n6.3.8　Via　　098\n6.3.9　Warning　　099\n6.4　　请求首部字段　　100\n6.4.1　Accept　　101\n6.4.2　Accept-Charset　　102\n6.4.3　Accept-Encoding　　103\n6.4.4　Accept-Language　　104\n6.4.5　Authorization　　105\n6.4.6　Expect　　106\n6.4.7　From　　107\n6.4.8　Host　　107\n6.4.9　If-Match　　108\n6.4.10　If-Modified-Since　　110\n6.4.11　If-None-Match　　111\n6.4.12　If-Range　　112\n6.4.13　If-Unmodified-Since　　113\n6.4.14　Max-Forwards　　114\n6.4.15　Proxy-Authorization　　115\n6.4.16　Range　　116\n6.4.17　Referer　　116\n6.4.18　TE　　117\n6.4.19　User-Agent　　118\n6.5　　响应首部字段119\n6.5.1　Accept-Ranges　　119\n6.5.2　Age　　120\n6.5.3　ETag　　　　120\n6.5.4　Location　　122\n6.5.5　Proxy-Authenticate　　123\n6.5.6　Retry-After　　123\n6.5.7　Server　　124\n6.5.8　Vary　　125\n6.5.9　WWW-Authenticate　　125\n6.6　　实体首部字段126\n6.6.1　Allow　　126\n6.6.2　Content-Encoding　　127\n6.6.3　Content-Language　　128\n6.6.4　Content-Length　　128\n6.6.5　Content-Location　　129\n6.6.6　Content-MD5　　129\n6.6.7　Content-Range　　130\n6.6.8　Content-Type　　131\n6.6.9　Expires　　131\n6.6.10　　Last-Modified　　132\n6.7　　为Cookie服务的首部字段　　132\n6.7.1　Set-Cookie　　134\n6.7.2　Cookie　　136\n6.8　　其他首部字段137\n6.8.1　X-Frame-Options　　137\n6.8.2　X-XSS-Protection　　138\n6.8.3　DNT　　138\n6.8.4　P3P　　139\n第7章　确保Web安全的HTTPS　　141\n7.1　　HTTP的缺点　　142\n7.1.1　通信使用明文可能会被窃听　　142\n7.1.2　不验证通信方的身份就可能遭遇伪装　　146\n7.1.3　无法证明报文完整性，可能已遭篡改　　148\n7.2　　HTTP+加密+认证+完整性保护=HTTPS　　150\n7.2.1　HTTP加上加密处理和认证以及完整性保护后即是HTTPS　　150\n7.2.2　HTTPS是身披SSL外壳的HTTP　　151\n7.2.3　相互交换密钥的公开密钥加密技术　　152\n7.2.4　证明公开密钥正确性的证书　　155\n7.2.5　HTTPS的安全通信机制　　161\n第8章　确认访问用户身份的认证　　167\n8.1　　何为认证　　168\n8.2　　BASIC　认证　　169\n8.3　　DIGEST　认证171\n8.4　　SSL客户端认证173\n8.4.1　SSL客户端认证的认证步骤　　174\n8.4.2　SSL客户端认证采用双因素认证　　175\n8.4.3　SSL客户端认证必要的费用　　175\n8.5　　基于表单认证　　175\n8.5.1　认证多半为基于表单认证　　176\n8.5.2　Session管理及Cookie应用　　177\n第9章　基于HTTP的功能追加协议　　179\n9.1　　基于HTTP的协议180\n9.2　　消除HTTP瓶颈的SPDY　　180\n9.2.1　HTTP的瓶颈　　180\n9.2.2　SPDY的设计与功能　　184\n9.2.3　SPDY消除Web瓶颈了吗　　185\n9.3　　使用浏览器进行全双工通信的WebSocket　　186\n9.3.1　WebSocket的设计与功能　　186\n9.3.2　WebSocket协议　　186\n9.4　　期盼已久的HTTP/2.0　　189\n9.5　　Web　　服务器管理文件的WebDAV　　190\n9.5.1　扩展HTTP/1.1的WebDAV　　191\n9.5.2　WebDAV内新增的方法及状态码　　192\n第10章　构建Web内容的技术　　195\n10.1　　HTML　　196\n10.1.1　Web页面几乎全由HTML构建　　196\n10.1.2　HTML的版本　　197\n10.1.3　设计应用CSS　　198\n10.2　　动态HTML　　198\n10.2.1　让Web页面动起来的动态HTML　　198\n10.2.2　更易控制HTML　　的DOM　　198\n10.3　　Web应用　　200\n10.3.1　　　通过Web提供功能的Web应用　　200\n10.3.2　与Web服务器及程序协作的CGI　　200\n10.3.3　因Java　　而普及的Servlet　　201\n10.4　　数据发布的格式及语言　　203\n10.4.1　可扩展标记语言　　203\n10.4.2　发布更新信息的RSS/Atom　　204\n10.4.3　JavaScript衍生的轻量级易用JSON　　206\n第11章　Web的攻击技术　　207\n11.1　　针对Web的攻击技术　　208\n11.1.1　HTTP不具备必要的安全功能　　208\n11.1.2　在客户端即可篡改请求　　209\n11.1.3　针对Web应用的攻击模式　　210\n11.2　　因输出值转义不完全引发的安全漏洞　　212\n11.2.1　跨站脚本攻击　　213\n11.2.2　SQL注入攻击　　218\n11.2.3　OS命令注入攻击　　223\n11.2.4　HTTP首部注入攻击　　225\n11.2.5　邮件首部注入攻击　　228\n11.2.6　目录遍历攻击　　229\n11.2.7　远程文件包含漏洞　　230\n11.3　　因设置或设计上的缺陷引发的安全漏洞　　232\n11.3.1　强制浏览　　232\n11.3.2　不正确的错误消息处理　　234\n11.3.3　开放重定向　　237\n11.4　　因会话管理疏忽引发的安全漏洞　　237\n11.4.1　会话劫持　　238\n11.4.2　会话固定攻击　　239\n11.4.3　跨站点请求伪造　　241\n11.5　　其他安全漏洞　　242\n11.5.1　密码破解　　242\n11.5.2　点击劫持　　247\n11.5.3　DoS攻击　　249\n11.5.4　后门程序　　250","ebook_url":"https://read.douban.com/ebook/12054542/","pages":"308","images":{"small":"https://img3.doubanio.com/view/subject/s/public/s27283822.jpg","large":"https://img3.doubanio.com/view/subject/l/public/s27283822.jpg","medium":"https://img3.doubanio.com/view/subject/m/public/s27283822.jpg"},"alt":"https://book.douban.com/subject/25863515/","id":"25863515","publisher":"人民邮电出版社","isbn10":"7115351538","isbn13":"9787115351531","title":"图解HTTP","url":"https://api.douban.com/v2/book/25863515","alt_title":"","author_intro":"作者简介\n上野 宣\nOWASP 日本分会会长，TRICORDER株式会社董事长。\n主要从事安全咨询、风险评估、信息安全教育等工作。著有《今晚我们一起学习邮件协议》（今夜わかるメールプロトコル）、《今晚我们一起学习TCP/IP》（今夜わかるTCP/IP）、《今晚我们一起学习HTTP》（今夜わかるHTTP）。担任The Tangled Web:A Guide to Securing Modern Web Application日文版的审校工作。\n译者简介\n于均良\n上海交通大学硕士，高级软件工程师，马拉松跑者，四点网创始人。","summary":"本书对互联网基盘——HTTP协议进行了全面系统的介绍。作者由HTTP协议的发展历史娓娓道来，严谨细致地剖析了HTTP协议的结构，列举诸多常见通信场景及实战案例，最后延伸到Web安全、最新技术动向等方面。本书的特色为在讲解的同时，辅以大量生动形象的通信图例，更好地帮助读者深刻理解HTTP通信过程中客户端与服务器之间的交互情况。读者可通过本书快速了解并掌握HTTP协议的基础，前端工程师分析抓包数据，后端工程师实现REST API、实现自己的HTTP服务器等过程中所需的HTTP相关知识点本书均有介绍。\n本书适合Web开发工程师，以及对HTTP协议感兴趣的各层次读者。","ebook_price":"19.99","series":{"id":"34135","title":"图解入门系列"},"price":"49.00元"},"9787115318978":{"rating":{"max":10,"numRaters":700,"average":"7.8","min":0},"subtitle":"","author":["[日]竹下隆史","[日]村山公保","[日]荒井透","[日]苅田幸雄"],"pubdate":"2013-7-1","tags":[{"count":618,"name":"TCP/IP","title":"TCP/IP"},{"count":362,"name":"网络","title":"网络"},{"count":317,"name":"计算机网络","title":"计算机网络"},{"count":217,"name":"计算机","title":"计算机"},{"count":139,"name":"网络编程","title":"网络编程"},{"count":90,"name":"计算机科学","title":"计算机科学"},{"count":70,"name":"编程","title":"编程"},{"count":63,"name":"图灵程序设计丛书","title":"图灵程序设计丛书"}],"origin_title":"マスタリングTCP/IP 入門編 第5版","image":"https://img1.doubanio.com/view/subject/m/public/s26676928.jpg","binding":"平装","translator":["乌尼日其其格"],"catalog":"第1章 网络基础知识\n1.1 　计算机网络出现的背景\n1.1.1 　计算机的普及与多样化\n1.1.2 　从独立模式到网络互连模式\n1.1.3 　从计算机通信到信息通信\n1.1.4 　计算机网络的作用\n1.2　 计算机与网络发展的7个阶段\n1.2.1 　批处理\n1.2.2 　分时系统\n1.2.3 　计算机之间的通信\n1.2.4 　计算机网络的产生\n1.2.5 　互联网的普及\n1.2.6 　以互联网技术为中心的时代\n1.2.7 　从“单纯建立连接”到“安全建立连接”\n1.2.8 　手握金刚钻的tcp/ip\n1.3 　协议\n1.3.1　 随处可见的协议\n1.3.2　 协议的必要性\n1.3.3　 协议如同人与人的对话\n1.3.4　 计算机中的协议\n1.3.5　 分组交换协议\n1.4 　协议由谁规定\n1.4.1 　计算机通信的诞生及其标准化\n1.4.2 　协议的标准化\n1.5 　协议分层与osi参考模型\n1.5.1 　协议的分层\n1.5.2 　通过对话理解分层\n1.5.3 　osi参考模型\n1.5.4 　osi参考模型中各个分层的作用\n1.6 　osi参考模型通信处理举例\n1.6.1 　7层通信\n1.6.2　 会话层以上的处理\n1.6.3　 传输层以下的处理\n1.7 　传输方式的分类\n1.7.1 　面向有连接型与面向无连接型\n1.7.2 　电路交换与分组交换\n1.7.3 　根据接收端数量分类\n1.8 　地址\n1.8.1　 地址的唯一性\n1.8.2　 地址的层次性\n1.9 　网络的构成要素\n1.9.1 　通信媒介与数据链路\n1.9.2 　网卡\n1.9.3 　中继器\n1.9.4 　网桥/2层交换机\n1.9.5 　路由器/3层交换机\n1.9.6 　4~7层交换机\n1.9.7 　网关\n1.10 　现代网络实态\n1.10.1 　网络的构成\n1.10.2　 互联网通信\n1.10.3　 移动通信\n1.10.4　 从信息发布者的角度看网络\n第2章 tcp/ip基础知识\n2.1 　tcp/ip出现的背景及其历史\n2.1.1 　从军用技术的应用谈起\n2.1.2　 arpanet的诞生\n2.1.3　 tcp/ip的诞生\n2.1.4　 unix系统的普及与互联网的扩张\n2.1.5　 商用互联网服务的启蒙\n2.2 　tcp/ip的标准化\n2.2.1 　tcp/ip的具体含义\n2.2.2 　tcp/ip标准化精髓\n2.2.3　 tcp/ip规范--rfc\n2.2.4 　tcp/ip的标准化流程\n2.2.5 　rfc的获取方法\n2.3　 互联网基础知识\n2.3.1 　互联网定义\n2.3.2 　互联网与tcp/ip的关系\n2.3.3 　互联网的结构\n2.3.4 　isp和区域网\n2.4 　tcp/ip协议分层模型\n2.4.1　 tcp/ip与osi参考模型\n2.4.2　 硬件（物理层）\n2.4.3 　网络接口层（数据链路层）\n2.4.4 　互联网层（网络层）\n2.4.5　 传输层\n2.4.6　 应用层（会话层以上的分层）\n2.5 　tcp/ip分层模型与通信示例\n2.5.1　 数据包首部\n2.5.2　 发送数据包\n2.5.3 　经过数据链路的包\n2.5.4 　数据包接收处理\n第3章 数据链路\n3.1 　数据链路的作用\n3.2 　数据链路相关技术\n3.2.1 　mac地址\n3.2.2　 共享介质型网络\n3.2.3 　非共享介质网络\n3.2.4　 根据mac地址转发\n3.2.5　 环路检测技术\n3.2.6　 vlan\n3.3 　以太网\n3.3.1 　以太网连接形式\n3.3.2　 以太网的分类\n3.3.3 　以太网的历史\n3.3.4 　以太网帧格式\n3.4 　无线通信\n3.4.1　 无线通信的种类\n3.4.2 　ieee802.11\n3.4.3 　ieee802.11b和ieee802.11g\n3.4.4 　ieee802.11a\n3.4.5 　ieee802.11n\n3.4.6 　使用无线lan时的注意事项\n3.4.7　 蓝牙\n3.4.8　 wimax\n3.4.9 　zigbee\n3.5 　ppp\n3.5.1 　ppp定义\n3.5.2 　lcp与ncp\n3.5.3　 ppp的帧格式\n3.5.4 　pppoe\n3.6 　其他数据链路\n3.6.1 　atm\n3.6.2　 pos\n3.6.3 　fddi\n3.6.4 　token ring\n3.6.5 　100vg-anylan\n3.6.6 　光纤通道\n3.6.7 　hippi\n3.6.8　 ieee1394\n3.6.9　 hdmi\n3.6.10 　iscsi\n3.6.11 　infiniband\n3.6.12 　docsis\n3.6.13 　高速plc\n3.7 　公共网络\n3.7.1 　模拟电话线路\n3.7.2　 移动通信服务\n3.7.3 　adsl\n3.7.4 　ftth\n3.7.5 　有线电视\n3.7.6 　专线\n3.7.7 　vpn\n3.7.8 　公共无线lan\n3.7.9 　其他公共无线通信服务\n第4章 ip协议\n4.1 　ip即网际协议\n4.1.1 　ip相当于osi参考模型的第3层\n4.1.2 　网络层与数据链路层的关系\n4.2 　ip基础知识\n4.2.1　 ip地址属于网络层地址\n4.2.2 　路由控制\n4.2.3 　数据链路的抽象化\n4.2.4 　ip属于面向无连接型\n4.3 　ip地址的基础知识\n4.3.1 　ip地址的定义\n4.3.2 　ip地址由网络和主机两部分标识组成\n4.3.3　 ip地址的分类\n4.3.4　 广播地址\n4.3.5　 ip多播\n4.3.6　 子网掩码\n4.3.7　 cidr与vlsm\n4.3.8　 全局地址与私有地址\n4.3.9 　全局地址由谁决定\n4.4 　路由控制\n4.4.1　 ip地址与路由控制\n4.4.2　 路由控制表的聚合\n4.5 　ip分割处理与再构成处理\n4.5.1 　数据链路不同，mtu则相异\n4.5.2 　ip报文的分片与重组\n4.5.3　 路径mtu发现\n4.6 　ipv6\n4.6.1　 ipv6的必要性\n4.6.2　 ipv6的特点\n4.6.3　 ipv6中ip地址的标记方法\n4.6.4 　ipv6地址的结构\n4.6.5　 全局单播地址\n4.6.6　 链路本地单播地址\n4.6.7　 唯一本地地址\n4.6.8 　ipv6分段处理\n4.7 　ipv4首部\n4.8 　ipv6首部格式\n第5章 ip协议相关技术\n5.1 　仅凭ip无法完成通信\n5.2 　dns\n5.2.1　 ip地址不便记忆\n5.2.2　 dns的产生\n5.2.3　 域名的构成\n5.2.4　 dns查询\n5.2.5　 dns如同互联网中的分布式数据库\n5.3 　arp\n5.3.1　 arp概要\n5.3.2　 arp的工作机制\n5.3.3　 ip地址和mac地址缺一不可？\n5.3.4 　rarp\n5.3.5　 代理arp\n5.4 　icmp\n5.4.1 　辅助ip的icmp\n5.4.2 　主要的icmp消息\n5.4.3 　其他icmp消息\n5.4.4 　icmpv6\n5.5　 dhcp\n5.5.1　 dhcp实现即插即用\n5.5.2　 dhcp的工作机制\n5.5.3　 dhcp中继代理\n5.6　 nat\n5.6.1　 nat定义\n5.6.2　 nat的工作机制\n5.6.3　 nat-pt（napt-pt）\n5.6.4　 nat的潜在问题\n5.6.5　 解决nat的潜在问题与nat穿越\n5.7 　ip隧道\n5.8 　其他ip相关技术\n5.8.1 　ip多播相关技术\n5.8.2 　ip任播\n5.8.3 　通信质量控制\n5.8.4 　显式拥塞通知\n5.8.5 　mobile ip\n第6章 tcp与udp\n6.1 　传输层的作用\n6.1.1　 传输层定义\n6.1.2　 通信处理\n6.1.3　 两种传输层协议tcp和udp\n6.1.4　 tcp与udp区分\n6.2　 端口号\n6.2.1　 端口号定义\n6.2.2　 根据端口号识别应用\n6.2.3 　通过ip地址、端口号、协议号进行通信识别\n6.2.4 　端口号如何确定\n6.2.5 　端口号与协议\n6.3　 udp\n6.4　 tcp\n6.4.1 　tcp的特点及其目的\n6.4.2 　通过序列号与确认应答提高可靠性\n6.4.3　 重发超时如何确定\n6.4.4 　连接管理\n6.4.5 　tcp以段为单位发送数据\n6.4.6 　利用窗口控制提高速度\n6.4.7 　窗口控制与重发控制\n6.4.8　 流控制\n6.4.9　 拥塞控制\n6.4.10　 提高网络利用率的规范\n6.4.11　 使用tcp的应用\n6.5　 其他传输层协议\n6.5.1　 udp-lite\n6.5.2　 sctp\n6.5.3 　dccp\n6.6　 udp首部的格式\n6.7　 tcp首部格式\n第7章 路由协议\n7.1　 路由控制的定义\n7.1.1　 ip地址与路由控制\n7.1.2 　静态路由与动态路由\n7.1.3　 动态路由的基础\n7.2 　路由控制范围\n7.2.1 　接入互联网的各种组织机构\n7.2.2 　自治系统与路由协议\n7.2.3 　igp与egp\n7.3 　路由算法\n7.3.1　 距离向量算法\n7.3.2　 链路状态算法\n7.3.3　 主要路由协议\n7.4　 rip\n7.4.1 　广播路由控制信息\n7.4.2 　根据距离向量确定路由\n7.4.3 　使用子网掩码时的rip处理\n7.4.4 　rip中路由变更时的处理\n7.4.5 　rip2\n7.5　 ospf\n7.5.1　 ospf是链路状态型路由协议\n7.5.2　 ospf基础知识\n7.5.3　 ospf工作原理概述\n7.5.4　 将区域分层化进行细分管理\n7.6　 bgp\n7.6.1　 bgp与as号\n7.6.2　 bgp是路径向量协议\n7.7 　mpls\n7.7.1　 mpls的网络基本动作\n7.7.2　 mpls的优点\n第8章 应用协议\n8.1 　应用层协议概要\n8.2 　远程登录\n8.2.1 　telnet\n8.2.2 　ssh\n8.3 　文件传输\n8.4 　电子邮件\n8.4.1 　电子邮件的工作机制\n8.4.2 　邮件地址\n8.4.3 　mime\n8.4.4 　smtp\n8.4.5 　pop\n8.4.6 　imap\n8.5 　www\n8.5.1 　互联网的蓬勃发展\n8.5.2　 www基本概念\n8.5.3 　uri\n8.5.4 　html\n8.5.5　 http\n8.5.6 　javascript、cgi、cookie\n8.6 　网络管理\n8.6.1　 snmp\n8.6.2　 mib\n8.6.3　 rmon\n8.6.4　 snmp应用举例\n8.7 　其他应用层协议\n8.7.1 　多媒体通信实现技术\n8.7.2 　p2p\n8.7.3　 ldap\n第9章 网络安全\n9.1　 tcp/ip与网络安全\n9.2　 网络安全构成要素\n9.2.1　 防火墙\n9.2.2 　ids（入侵检测系统）\n9.2.3 　反病毒/个人防火墙\n9.3 　加密技术基础\n9.3.1　 对称密码体制与公钥密码体制\n9.3.2　 身份认证技术\n9.4 　安全协议\n9.4.1 　ipsec与vpn\n9.4.2 　tls/ssl与https\n9.4.3 　ieee802.1x\n附录\n附1　 互联网上便捷的资源\n附1.1 　国际\n附1.2 　日本\n附2 　ip地址分类（a、b、c类）相关基础知识\n附2.1　 a类\n附2.2　 b类\n附2.3 　c类\n附3 　物理层\n附3.1 　物理层相关基础知识\n附3.2 　0/1编码\n附4 　传输介质相关基础知识\n附4.1 　同轴电缆\n附4.2 　双绞线\n附4.3 　光纤电缆\n附4.4 　无线\n附5 　插页导图","pages":"312","images":{"small":"https://img1.doubanio.com/view/subject/s/public/s26676928.jpg","large":"https://img1.doubanio.com/view/subject/l/public/s26676928.jpg","medium":"https://img1.doubanio.com/view/subject/m/public/s26676928.jpg"},"alt":"https://book.douban.com/subject/24737674/","id":"24737674","publisher":"人民邮电出版社","isbn10":"7115318972","isbn13":"9787115318978","title":"图解TCP/IP : 第5版","url":"https://api.douban.com/v2/book/24737674","alt_title":"マスタリングTCP/IP 入門編 第5版","author_intro":"作者简介：\n竹下隆史\nNet One Systems公司资深网络工程师。\n村山公保\n仓敷艺术科学大学产业科学技术学院信息学系教授。\n荒井透\n1958年生人。 Net One Systems公司资深网络工程师。\n苅田幸雄\n高能加速器研究所、计算科学中心研究员。\n译者简介：\n乌尼日其其格\nOracle资深中间件技术专家、资深技术顾问。精于问题诊断处理、擅长解决大型核心系统的性能故障，并拥有多项Oracle官方认证资质。","summary":"这是一本图文并茂的网络管理技术书籍，旨在让广大读者理解TCP/IP的基本知识、掌握TCP/IP的基本技能。\n书中讲解了网络基础知识、TCP/IP基础知识、数据链路、IP协议、IP协议相关技术、TCP与UDP、路由协议、应用协议、网络安全等内容，引导读者了解和掌握TCP/IP，营造一个安全的、使用放心的网络环境。\n本书适合计算机网络的开发、管理人员阅读，也可作为大专院校相关专业的教学参考书。","series":{"id":"34135","title":"图解入门系列"},"price":"69.00元"},"9787115191120":{"rating":{"max":10,"numRaters":931,"average":"8.4","min":0},"subtitle":"","author":["[英] Ben Forta"],"pubdate":"2009-1","tags":[{"count":592,"name":"数据库","title":"数据库"},{"count":403,"name":"mysql","title":"mysql"},{"count":376,"name":"MySQL","title":"MySQL"},{"count":215,"name":"SQL","title":"SQL"},{"count":214,"name":"计算机","title":"计算机"},{"count":124,"name":"Database","title":"Database"},{"count":119,"name":"编程","title":"编程"},{"count":96,"name":"入门","title":"入门"}],"origin_title":"MySQL Crash Course","image":"https://img3.doubanio.com/view/subject/m/public/s5968156.jpg","binding":"","translator":["刘晓霞","钟鸣"],"catalog":"第1章 了解SQL\n1.1 数据库基础\n1.1.1 什么是数据库\n1.1.2 表\n1.1.3 列和数据类型\n1.1.4 行\n1.1.5 主键\n1.2 什么是SQL\n1.3 动手实践\n1.4 小结\n第2章 MySQL简介\n2.1 什么是MySQL\n2.1.1 客户机-服务器软件\n2.1.2 MySQL版本\n2.2 MySQL工具\n2.2.1 mysql命令行实用程序\n2.2.2 MySQL Administrator\n2.2.3 MySQL Query Browser\n2.3 小结\n第3章 使用MySQL\n3.1 连接\n3.2 选择数据库\n3.3 了解数据库和表\n3.4 小结\n第4章 检索数据\n4.1 SELECT语句\n4.2 检索单个列\n4.3 检索多个列\n4.4 检索所有列\n4.5 检索不同的行\n4.6 限制结果\n4.7 使用完全限定的表名\n4.8 小结\n第5章 排序检索数据\n5.1 排序数据\n5.2 按多个列排序\n5.3 指定排序方向\n5.4 小结\n第6章 过滤数据\n6.1 使用WHERE子句\n6.2 WHERE子句操作符\n6.2.1 检查单个值\n6.2.2 不匹配检查\n6.2.3 范围值检查\n6.2.4 空值检查\n6.3 小结\n第7章 数据过滤\n7.1 组合WHERE子句\n7.1.1 AND操作符\n7.1.2 OR操作符\n7.1.3 计算次序\n7.2 IN操作符\n7.3 NOT操作符\n7.4 小结\n第8章 用通配符进行过滤\n8.1 LIKE操作符\n8.1.1 百分号（%）通配符\n8.1.2 下划线（_）通配符\n8.2 使用通配符的技巧\n8.3 小结\n第9章 用正则表达式进行搜索\n9.1 正则表达式介绍\n9.2 使用MySQL正则表达式\n9.2.1 基本字符匹配\n9.2.2 进行OR匹配\n9.2.3 匹配几个字符之一\n9.2.4 匹配范围\n9.2.5 匹配特殊字符\n9.2.6 匹配字符类\n9.2.7 匹配多个实例\n9.2.8 定位符\n9.3 小结\n第10章 创建计算字段\n10.1 计算字段\n10.2 拼接字段\n10.3 执行算术计算\n10.4 小结\n第11章 使用数据处理函数\n11.1 函数\n11.2 使用函数\n11.2.1 文本处理函数\n11.2.2 日期和时间处理函数\n11.2.3 数值处理函数\n11.3 小结\n第12章 汇总数据\n12.1 聚集函数\n12.1.1 AVG（）函数\n12.1.2 COUNT（）函数\n12.1.3 MAX（）函数\n12.1.4 MIN（）函数\n12.1.5 SUM（）函数\n12.2 聚集不同值\n12.3 组合聚集函数\n12.4 小结\n第13章 分组数据\n13.1 数据分组\n13.2 创建分组\n13.3 过滤分组\n13.4 分组和排序\n13.5 SELECT子句顺序\n13.6 小结\n第14章 使用子查询\n14.1 子查询\n14.2 利用子查询进行过滤\n14.3 作为计算字段使用子查询\n14.4 小结\n第15章 联结表\n15.1 联结\n15.1.1 关系表\n15.1.2 为什么要使用联结\n15.2 创建联结\n15.2.1 WHERE子句的重要性\n15.2.2 内部联结\n15.2.3 联结多个表\n15.3 小结\n第16章 创建高级联结\n16.1 使用表别名\n16.2 使用不同类型的联结\n16.2.1 自联结\n16.2.2 自然联结\n16.2.3 外部联结\n16.3 使用带聚集函数的联结\n16.4 使用联结和联结条件\n16.5 小结\n第17章 组合查询\n17.1 组合查询\n17.2 创建组合查询\n17.2.1 使用UNION\n17.2.2 UNION规则\n17.2.3 包含或取消重复的行\n17.2.4 对组合查询结果排序\n17.3 小结\n第18章 全文本搜索\n18.1 理解全文本搜索\n18.2 使用全文本搜索\n18.2.1 启用全文本搜索支持\n18.2.2 进行全文本搜索\n18.2.3 使用查询扩展\n18.2.4 布尔文本搜索\n18.2.5 全文本搜索的使用说明\n18.3 小结\n第19章 插入数据\n19.1 数据插入\n19.2 插入完整的行\n19.3 插入多个行\n19.4 插入检索出的数据\n19.5 小结\n第20章 更新和删除数据\n20.1 更新数据\n20.2 删除数据\n20.3 更新和删除的指导原则\n20.4 小结\n第21章 创建和操纵表\n21.1 创建表\n21.1.1 表创建基础\n21.1.2 使用NULL值\n21.1.3 主键再介绍\n21.1.4 使用AUTO_ INCREMENT\n21.1.5 指定默认值\n21.1.6 引擎类型\n21.2 更新表\n21.3 删除表\n21.4 重命名表\n21.5 小结\n第22章 使用视图\n22.1 视图\n22.1.1 为什么使用视图\n22.1.2 视图的规则和限制\n22.2 使用视图\n22.2.1 利用视图简化复杂的联结\n22.2.2 用视图重新格式化检索出的数据\n22.2.3 用视图过滤不想要的数据\n22.2.4 使用视图与计算字段\n22.2.5 更新视图\n22.3 小结\n第23章 使用存储过程\n23.1 存储过程\n23.2 为什么要使用存储过程\n23.3 使用存储过程\n23.3.1 执行存储过程\n23.3.2 创建存储过程\n23.3.3 删除存储过程\n23.3.4 使用参数\n23.3.5 建立智能存储过程\n23.3.6 检查存储过程\n23.4 小结\n第24章 使用游标\n24.1 游标\n24.2 使用游标\n24.2.1 创建游标\n24.2.2 打开和关闭游标\n24.2.3 使用游标数据\n24.3 小结\n第25章 使用触发器\n25.1 触发器\n25.2 创建触发器\n25.3 删除触发器\n25.4 使用触发器\n25.4.1 INSERT触发器\n25.4.2 DELETE触发器\n25.4.3 UPDATE触发器\n25.4.4 关于触发器的进一步介绍\n25.5 小结\n第26章 管理事务处理\n26.1 事务处理\n26.2 控制事务处理\n26.2.1 使用ROLLBACK\n26.2.2 使用COMMIT\n26.2.3 使用保留点\n26.2.4 更改默认的提交行为\n26.3 小结\n第27章 全球化和本地化\n27.1 字符集和校对顺序\n27.2 使用字符集和校对顺序\n27.3 小结\n第28章 安全管理\n28.1 访问控制\n28.2 管理用户\n28.2.1 创建用户账号\n28.2.2 删除用户账号\n28.2.3 设置访问权限\n28.2.4 更改口令\n28.3 小结\n第29章 数据库维护\n29.1 备份数据\n29.2 进行数据库维护\n29.3 诊断启动问题\n29.4 查看日志文件\n29.5 小结\n第30章 改善性能\n30.1 改善性能\n30.2 小结\n附录A MySQL入门\n附录B 样例表\n附录C MySQL语句的语法\n附录D MySQL数据类型\n附录E MySQL保留字\n索引","pages":"241","images":{"small":"https://img3.doubanio.com/view/subject/s/public/s5968156.jpg","large":"https://img3.doubanio.com/view/subject/l/public/s5968156.jpg","medium":"https://img3.doubanio.com/view/subject/m/public/s5968156.jpg"},"alt":"https://book.douban.com/subject/3354490/","id":"3354490","publisher":"人民邮电出版社","isbn10":"7115191123","isbn13":"9787115191120","title":"MySQL必知必会","url":"https://api.douban.com/v2/book/3354490","alt_title":"MySQL Crash Course","author_intro":"Ben Forta是世界知名的技术作家，也是Ad。be技术界最为知名的专家之一，目前担任Adobe公司的高级技术推广专家。他具有计算机行业20多年工作经验，多年来撰写了十几本技术图书，其中不少是世界畅销书，已被翻译为十几种文字。除本书外，他撰写的《正则表达式必知必会》也即将由人民邮电出版社出版。读者可以通过他的个人网站http：//www．forta．com了解更多信息。","summary":"《MySQL必知必会》MySQL是世界上最受欢迎的数据库管理系统之一。书中从介绍简单的数据检索开始，逐步深入一些复杂的内容，包括联结的使用、子查询、正则表达式和基于全文本的搜索、存储过程、游标、触发器、表约束，等等。通过重点突出的章节，条理清晰、系统而扼要地讲述了读者应该掌握的知识，使他们不经意间立刻功力大增。","series":{"id":"28522","title":"图灵程序设计丛书·数据库系列"},"price":"39.00元"},"9787111557975":{"rating":{"max":10,"numRaters":146,"average":"9.0","min":0},"subtitle":"","author":["付磊","张益军"],"pubdate":"2017-3-1","tags":[{"count":204,"name":"Redis","title":"Redis"},{"count":70,"name":"redis","title":"redis"},{"count":65,"name":"数据库","title":"数据库"},{"count":53,"name":"运维","title":"运维"},{"count":47,"name":"计算机","title":"计算机"},{"count":35,"name":"redis集群","title":"redis集群"},{"count":34,"name":"开发","title":"开发"},{"count":27,"name":"redis集群管理","title":"redis集群管理"}],"origin_title":"","image":"https://img3.doubanio.com/view/subject/m/public/s29335561.jpg","binding":"平装","translator":[],"catalog":"序　言\n前　言\n致　谢\n第1章　初识Redis 1\n1.1　盛赞Redis 1\n1.2　Redis特性 2\n1.3　Redis使用场景 5\n1.3.1　Redis可以做什么 5\n1.3.2　Redis不可以做什么 5\n1.4　用好Redis的建议 6\n1.5　正确安装并启动Redis 6\n1.5.1　安装Redis 7\n1.5.2　配置、启动、操作、关闭Redis 8\n1.6　Redis重大版本 11\n1.7　本章重点回顾 14\n第2章　API的理解和使用 15\n2.1　预备 15\n2.1.1　全局命令 15\n2.1.2　数据结构和内部编码 18\n2.1.3　单线程架构 19\n2.2　字符串 21\n2.2.1　命令 22\n2.2.2　内部编码 27\n2.2.3　典型使用场景 28\n2.3　哈希 31\n2.3.1　命令 32\n2.3.2　内部编码 35\n2.3.3　使用场景 36\n2.4　列表 38\n2.4.1　命令 38\n2.4.2　内部编码 43\n2.4.3　使用场景 44\n2.5　集合 46\n2.5.1　命令 46\n2.5.2　内部编码 50\n2.5.3　使用场景 51\n2.6　有序集合 52\n2.6.1　命令 53\n2.6.2　内部编码 59\n2.6.3　使用场景 59\n2.7　键管理 60\n2.7.1　单个键管理 60\n2.7.2　遍历键 67\n2.7.3　数据库管理 70\n2.8　本章重点回顾 73\n第3章　小功能大用处 74\n3.1　慢查询分析 74\n3.1.1　慢查询的两个配置参数 75\n3.1.2　最佳实践 77\n3.2　Redis Shell 78\n3.2.1　redis-cli详解 78\n3.2.2　redis-server详解 82\n3.2.3　redis-benchmark详解 83\n3.3　Pipeline 84\n3.3.1　Pipeline概念 84\n3.3.2　性能测试 85\n3.3.3　原生批量命令与Pipeline对比 86\n3.3.4　最佳实践 87\n3.4　事务与Lua 87\n3.4.1　事务 87\n3.4.2　Lua用法简述 90\n3.4.3　Redis与Lua 92\n3.4.4　案例 94\n3.4.5　Redis如何管理Lua脚本 96\n3.5　Bitmaps 98\n3.5.1　数据结构模型 98\n3.5.2　命令 98\n3.5.3　Bitmaps分析 101\n3.6　HyperLogLog 102\n3.7　发布订阅 105\n3.7.1　命令 106\n3.7.2　使用场景 108\n3.8　GEO 109\n3.9　本章重点回顾 112\n第4章　客户端 113\n4.1　客户端通信协议 113\n4.2　Java客户端Jedis 117\n4.2.1　获取Jedis 117\n4.2.2　Jedis的基本使用方法 118\n4.2.3　Jedis连接池的使用方法 122\n4.2.4　Redis中Pipeline的使用方法 125\n4.2.5　Jedis的Lua脚本 126\n4.3　Python客户端redis-py 128\n4.3.1　获取redis-py 128\n4.3.2　redis-py的基本使用方法 128\n4.3.3　redis-py中Pipeline的使用方法 130\n4.3.4　redis-py中的Lua脚本使用方法 130\n4.4　客户端管理 131\n4.4.1　客户端API 132\n4.4.2　客户端相关配置 145\n4.4.3　客户端统计片段 145\n4.5　客户端常见异常 146\n4.6　客户端案例分析 149\n4.6.1　Redis内存陡增 149\n4.6.2　客户端周期性的超时 151\n4.7　本章重点回顾 153\n第5章　持久化 154\n5.1　RDB 154\n5.1.1　触发机制 154\n5.1.2　流程说明 155\n5.1.3　RDB文件的处理 156\n5.1.4　RDB的优缺点 156\n5.2　AOF 157\n5.2.1　使用AOF 157\n5.2.2　命令写入 157\n5.2.3　文件同步 158\n5.2.4　重写机制 159\n5.2.5　重启加载 161\n5.2.6　文件校验 162\n5.3　问题定位与优化 162\n5.3.1　fork操作 162\n5.3.2　子进程开销监控和优化 163\n5.3.3　AOF追加阻塞 165\n5.4　多实例部署 166\n5.5　本章重点回顾 167\n第6章　复制 168\n6.1　配置 168\n6.1.1　建立复制 168\n6.1.2　断开复制 170\n6.1.3　安全性 170\n6.1.4　只读 170\n6.1.5　传输延迟 171\n6.2　拓扑 171\n6.3　原理 172\n6.3.1　复制过程 172\n6.3.2　数据同步 175\n6.3.3　全量复制 178\n6.3.4　部分复制 181\n6.3.5　心跳 183\n6.3.6　异步复制 184\n6.4　开发与运维中的问题 184\n6.4.1　读写分离 184\n6.4.2　主从配置不一致 186\n6.4.3　规避全量复制 186\n6.4.4　规避复制风暴 187\n6.5　本章重点回顾 188\n第7章　Redis的噩梦：阻塞 189\n7.1　发现阻塞 189\n7.2　内在原因 191\n7.2.1　API或数据结构使用不合理 191\n7.2.2　CPU饱和 193\n7.2.3　持久化阻塞 194\n7.3　外在原因 195\n7.3.1　CPU竞争 195\n7.3.2　内存交换 195\n7.3.3　网络问题 196\n7.4　本章重点回顾 199\n第8章　理解内存 200\n8.1　内存消耗 200\n8.1.1　内存使用统计 200\n8.1.2　内存消耗划分 201\n8.1.3　子进程内存消耗 203\n8.2　内存管理 204\n8.2.1　设置内存上限 204\n8.2.2　动态调整内存上限 204\n8.2.3　内存回收策略 205\n8.3　内存优化 209\n8.3.1　redisObject对象 209\n8.3.2　缩减键值对象 210\n8.3.3　共享对象池 211\n8.3.4　字符串优化 213\n8.3.5　编码优化 216\n8.3.6　控制键的数量 223\n8.4　本章重点回顾 225\n第9章　哨兵 226\n9.1　基本概念 226\n9.1.1　主从复制的问题 227\n9.1.2　高可用 227\n9.1.3　Redis Sentinel的高可用性 229\n9.2　安装和部署 232\n9.2.1　部署拓扑结构 232\n9.2.2　部署Redis数据节点 233\n9.2.3　部署Sentinel节点 234\n9.2.4　配置优化 236\n9.2.5　部署技巧 243\n9.3　API 244\n9.4　客户端连接 249\n9.4.1　Redis Sentinel的客户端 249\n9.4.2　Redis Sentinel客户端基本实现原理 249\n9.4.3　Java操作Redis Sentinel 251\n9.5　实现原理 254\n9.5.1　三个定时监控任务 254\n9.5.2　主观下线和客观下线 256\n9.5.3　领导者Sentinel节点选举 258\n9.5.4　故障转移 261\n9.6　开发与运维中的问题 262\n9.6.1　故障转移日志分析 262\n9.6.2　节点运维 268\n9.6.3　高可用读写分离 271\n9.7　本章重点回顾 272\n第10章　集群 274\n10.1　数据分布 274\n10.1.1　数据分布理论 274\n10.1.2　Redis数据分区 277\n10.1.3　集群功能限制 278\n10.2　搭建集群 278\n10.2.1　准备节点 278\n10.2.2　节点握手 280\n10.2.3　分配槽 282\n10.2.4　用redis-trib.rb搭建集群 284\n10.3　节点通信 287\n10.3.1　通信流程 287\n10.3.2　Gossip消息 287\n10.3.3　节点选择 290\n10.4　集群伸缩 291\n10.4.1　伸缩原理 291\n10.4.2　扩容集群 293\n10.4.3　收缩集群 301\n10.5　请求路由 305\n10.5.1　请求重定向 305\n10.5.2　Smart客户端 309\n10.5.3　ASK重定向 318\n10.6　故障转移 323\n10.6.1　故障发现 323\n10.6.2　故障恢复 329\n10.6.3　故障转移时间 334\n10.6.4　故障转移演练 334\n10.7　集群运维 336\n10.7.1　集群完整性 336\n10.7.2　带宽消耗 337\n10.7.3　Pub/Sub广播问题 337\n10.7.4　集群倾斜 338\n10.7.5　集群读写分离 339\n10.7.6　手动故障转移 341\n10.7.7　数据迁移 344\n10.8　本章重点回顾 344\n第11章　缓存设计 346\n11.1　缓存的收益和成本 346\n11.2　缓存更新策略 347\n11.3　缓存粒度控制 349\n11.4　穿透优化 350\n11.5　无底洞优化 352\n11.6　雪崩优化 359\n11.7　热点key重建优化 360\n11.8　本章重点回顾 364\n第12章　开发运维的“陷阱” 365\n12.1　Linux配置优化 365\n12.1.1　内存分配控制 365\n12.1.2　swappiness 367\n12.1.3　THP 369\n12.1.4　OOM killer 370\n12.1.5　使用NTP 371\n12.1.6　ulimit 371\n12.1.7　TCP backlog 372\n12.2　flushall/flushdb误操作 372\n12.2.1　缓存与存储 373\n12.2.2　借助AOF机制恢复 373\n12.2.3　RDB有什么变化 374\n12.2.4　从节点有什么变化 374\n12.2.5　快速恢复数据 374\n12.3　安全的Redis 375\n12.3.1　Redis密码机制 377\n12.3.2　伪装危险命令 378\n12.3.3　防火墙 380\n12.3.4　bind 380\n12.3.5　定期备份数据 381\n12.3.6　不使用默认端口 381\n12.3.7　使用非root用户启动 381\n12.4　处理bigkey 382\n12.4.1　bigkey的危害 382\n12.4.2　如何发现 382\n12.4.3　如何删除 383\n12.4.4　最佳实践思路 386\n12.5　寻找热点key 386\n12.6　本章重点回顾 391\n第13章　Redis监控运维云平台CacheCloud 392\n13.1　CacheCloud是什么 392\n13.1.1　现有问题 393\n13.1.2　CacheCloud基本功能 393\n13.2　快速部署 395\n13.2.1　CacheCloud环境需求 395\n13.2.2　CacheCloud快速开始 395\n13.3　机器部署 397\n13.3.1　部署脚本 398\n13.3.2　添加机器 399\n13.4　接入应用 400\n13.4.1　总体流程 401\n13.4.2　账户申请和审批 401\n13.4.3　应用申请和审批 402\n13.4.4　客户端接入 405\n13.5　用户功能 407\n13.5.1　应用统计信息 408\n13.5.2　实例列表 409\n13.5.3　应用详情 409\n13.5.4　命令曲线 409\n13.5.5　CacheCloud Redis Shell控制台 410\n13.5.6　慢查询 410\n13.5.7　应用拓扑 411\n13.6　运维功能 413\n13.6.1　应用运维 413\n13.6.2　接入已存在的Redis节点 415\n13.6.3　Redis配置模板 416\n13.6.4　迁移工具 417\n13.6.5　监控报警 420\n13.6.6　系统配置管理 422\n13.7　客户端上报 423\n13.7.1　客户端上报整体设计 424\n13.7.2　Jedis核心代码修改 424\n13.7.3　带上报功能的客户端 426\n13.7.4　CacheCloud客户端统计 427\n13.8　本章重点回顾 429\n第14章　Redis配置统计字典 430\n14.1　info系统状态说明 430\n14.1.1　命令说明 430\n14.1.2　详细说明 431\n14.2　standalone配置说明和分析 436\n14.2.1　总体配置 436\n14.2.2　最大内存及策略 437\n14.2.3　AOF相关配置 437\n14.2.4　RDB相关配置 438\n14.2.5　慢查询配置 438\n14.2.6　数据结构优化配置 439\n14.2.7　复制相关配置 439\n14.2.8　客户端相关配置 440\n14.2.9　安全相关配置 440\n14.3　Sentinel配置说明和分析 440\n14.4　Cluster配置说明和分析 441","ebook_url":"https://read.douban.com/ebook/30898272/","pages":"","images":{"small":"https://img3.doubanio.com/view/subject/s/public/s29335561.jpg","large":"https://img3.doubanio.com/view/subject/l/public/s29335561.jpg","medium":"https://img3.doubanio.com/view/subject/m/public/s29335561.jpg"},"alt":"https://book.douban.com/subject/26971561/","id":"26971561","publisher":"机械工业出版社","isbn10":"7111557972","isbn13":"9787111557975","title":"Redis开发与运维","url":"https://api.douban.com/v2/book/26971561","alt_title":"","author_intro":"付磊 搜狐视频高级研发工程师，CacheCloud项目联合创始人。拥有多年Redis开发运维经验，为公司多个核心业务提供Redis服务，同时热衷于技术传播和分享，撰写了大量关于Redis开发运维的技术文章。微博号carlosfl，博客地址是http://carlosfu.iteye.com。\n张益军 搜狐视频资深研发工程师，CacheCloud项目联合创始人，曾就职于美团、阿里巴巴等公司。搜狐视频投放组负责人，目前从事投放平台、反作弊等系统的架构设计和优化工作。研究兴趣包括海量峰值访问、分布式存储等。微博号益军YJ, 博客地址是http://hot66hot.iteye.com。","summary":"本书全面讲解Redis基本功能及其应用，并结合线上开发与运维监控中的实际使用案例，深入分析并总结了实际开发运维中遇到的“陷阱”，以及背后的原因， 包含大规模集群开发与管理的场景、应用案例与开发技巧，为高效开发运维提供了大量实际经验和建议。本书不要求读者有任何Redis使用经验,对入门与进阶DevOps的开发者提供有价值的帮助。主要内容包括：Redis的安装配置、API、各种高效功能、客户端、持久化、复制、高可用、内存、哨兵、集群、缓存设计等，Redis高可用集群解决方案，Redis设计和使用中的问题，最后提供了一个开源工具：Redis监控运维云平台CacheCloud。","ebook_price":"30.00","series":{"id":"25452","title":"数据库技术丛书"},"price":"89.00"},"9787111464747":{"rating":{"max":10,"numRaters":638,"average":"8.5","min":0},"subtitle":"","author":["黄健宏"],"pubdate":"2014-6","tags":[{"count":709,"name":"Redis","title":"Redis"},{"count":392,"name":"数据库","title":"数据库"},{"count":198,"name":"计算机","title":"计算机"},{"count":197,"name":"源码分析","title":"源码分析"},{"count":117,"name":"redis","title":"redis"},{"count":114,"name":"编程","title":"编程"},{"count":100,"name":"NoSQL","title":"NoSQL"},{"count":71,"name":"database","title":"database"}],"origin_title":"","image":"https://img1.doubanio.com/view/subject/m/public/s27297117.jpg","binding":"平装","translator":[],"catalog":"第1章 引言\t1\n1.1 Redis版本说明\t1\n1.2 章节编排\t1\n1.3 推荐的阅读方法\t4\n1.4 行文规则\t4\n1.5 配套网站\t5\n第一部分 数据结构与对象\n第2章 简单动态字符串\t8\n2.1 SDS的定义\t9\n2.2 SDS与C字符串的区别\t10\n2.3 SDS API\t17\n2.4 重点回顾\t18\n2.5 参考资料\t18\n第3章 链表\t19\n3.1 链表和链表节点的实现\t20\n3.2 链表和链表节点的API\t21\n3.3 重点回顾\t22\n第4章 字典\t23\n4.1 字典的实现\t24\n4.2 哈希算法\t27\n4.3 解决键冲突\t28\n4.4 rehash \t29\n4.5 渐进式rehash\t32\n4.6 字典API\t36\n4.7 重点回顾\t37\n第5章 跳跃表\t38\n5.1 跳跃表的实现\t39\n5.2 跳跃表API\t44\n5.3 重点回顾\t45\n第6章 整数集合\t46\n6.1 整数集合的实现\t46\n6.2 升级\t48\n6.3 升级的好处\t50\n6.4 降级\t51\n6.5 整数集合API\t51\n6.6 重点回顾\t51\n第7章 压缩列表\t52\n7.1 压缩列表的构成\t52\n7.2 压缩列表节点的构成\t54\n7.3 连锁更新\t57\n7.4 压缩列表API\t59\n7.5 重点回顾\t59\n第8章 对象\t60\n8.1 对象的类型与编码\t60\n8.2 字符串对象\t64\n8.3 列表对象\t68\n8.4 哈希对象\t71\n8.5 集合对象\t75\n8.6 有序集合对象\t77\n8.7 类型检查与命令多态\t81\n8.8 内存回收\t84\n8.9 对象共享\t85\n8.10 对象的空转时长\t87\n8.11 重点回顾\t88\n第二部分 单机数据库的实现\n第9章 数据库\t90\n9.1 服务器中的数据库\t90\n9.2 切换数据库\t91\n9.3 数据库键空间\t93\n9.4 设置键的生存时间或过期时间\t99\n9.5 过期键删除策略\t107\n9.6 Redis的过期键删除策略\t108\n9.7 AOF、RDB和复制功能对过期键的处理\t111\n9.8 数据库通知\t113\n9.9 重点回顾\t117\n第10章 RDB持久化\t118\n10.1 RDB 文件的创建与载入\t119\n10.2 自动间隔性保存\t121\n10.3 RDB 文件结构\t125\n10.4 分析RDB文件\t133\n10.5 重点回顾\t137\n10.6 参考资料\t137\n第11章 AOF持久化\t138\n11.1 AOF持久化的实现\t139\n11.2 AOF文件的载入与数据还原\t142\n11.3 AOF重写\t143\n11.4 重点回顾\t150\n第12章 事件\t151\n12.1 文件事件\t151\n12.2 时间事件\t156\n12.3 事件的调度与执行\t159\n12.4 重点回顾\t161\n12.5 参考资料\t161\n第13章 客户端\t162\n13.1 客户端属性\t163\n13.2 客户端的创建与关闭\t172\n13.3 重点回顾\t174\n第14章 服务器\t176\n14.1 命令请求的执行过程\t176\n14.2 serverCron函数\t184\n14.3 初始化服务器\t192\n14.4 重点回顾\t196\n第三部分 多机数据库的实现\n第15章 复制\t198\n15.1 旧版复制功能的实现\t199\n15.2 旧版复制功能的缺陷\t201\n15.3 新版复制功能的实现\t203\n15.4 部分重同步的实现\t204\n15.5 PSYNC 命令的实现\t209\n15.6 复制的实现\t211\n15.7 心跳检测\t216\n15.8 重点回顾\t218\n第16章 Sentinel\t219\n16.1 启动并初始化Sentinel \t220\n16.2 获取主服务器信息\t227\n16.3 获取从服务器信息\t229\n16.4 向主服务器和从服务器发送信息\t230\n16.5 接收来自主服务器和从服务器的频道信息\t231\n16.6 检测主观下线状态\t234\n16.7 检查客观下线状态\t236\n16.8 选举领头Sentinel \t238\n16.9 故障转移\t240\n16.10 重点回顾\t243\n16.11 参考资料\t244\n第17章 集群\t245\n17.1 节点\t245\n17.2 槽指派\t251\n17.3 在集群中执行命令\t258\n17.4 重新分片\t265\n17.5 ASK错误\t267\n17.6 复制与故障转移\t273\n17.7 消息\t281\n17.8 重点回顾\t288\n第四部分 独立功能的实现\n第18章 发布与订阅\t290\n18.1 频道的订阅与退订\t292\n18.2 模式的订阅与退订\t295\n18.3 发送消息\t298\n18.4 查看订阅信息\t300\n18.5 重点回顾\t303\n18.6 参考资料\t304\n第19章 事务\t305\n19.1 事务的实现\t306\n19.2 WATCH 命令的实现\t310\n19.3 事务的ACID 性质\t314\n19.4 重点回顾\t319\n19.5 参考资料\t320\n第20章 Lua脚本\t321\n20.1 创建并修改Lua 环境\t322\n20.2 Lua 环境协作组件\t327\n20.3 EVAL命令的实现\t329\n20.4 EVALSHA 命令的实现\t332\n20.5 脚本管理命令的实现\t333\n20.6 脚本复制\t336\n20.7 重点回顾\t342\n20.8 参考资料\t343\n第21章 排序\t344\n21.1 SORT <key> 命令的实现\t345\n21.2 ALPHA 选项的实现\t347\n21.3 ASC 选项和DESC 选项的实现\t348\n21.4 BY选项的实现\t350\n21.5 带有ALPHA 选项的BY 选项的实现\t352\n21.6 LIMIT 选项的实现\t353\n21.7 GET选项的实现\t355\n21.8 STORE 选项的实现\t358\n21.9 多个选项的执行顺序\t359\n21.10 重点回顾\t361\n第22章 二进制位数组\t362\n22.1 位数组的表示\t363\n22.2 GETBIT命令的实现\t365\n22.3 SETBIT 命令的实现\t366\n22.4 BITCOUNT 命令的实现\t369\n22.5 BITOP 命令的实现\t376\n22.6 重点回顾\t377\n22.7 参考资料\t377\n第23章 慢查询日志\t378\n23.1 慢查询记录的保存\t380\n23.2 慢查询日志的阅览和删除\t382\n23.3 添加新日志\t383\n23.4 重点回顾\t385\n第24章 监视器\t386\n24.1 成为监视器\t387\n24.2 向监视器发送命令信息\t387\n24.3 重点回顾\t388","ebook_url":"https://read.douban.com/ebook/7519526/","pages":"388","images":{"small":"https://img1.doubanio.com/view/subject/s/public/s27297117.jpg","large":"https://img1.doubanio.com/view/subject/l/public/s27297117.jpg","medium":"https://img1.doubanio.com/view/subject/m/public/s27297117.jpg"},"alt":"https://book.douban.com/subject/25900156/","id":"25900156","publisher":"机械工业出版社","isbn10":"7111464745","isbn13":"9787111464747","title":"Redis设计与实现","url":"https://api.douban.com/v2/book/25900156","alt_title":"","author_intro":"黄健宏 软件开发者，他喜欢函数式编程，热爱开源软件。出于对数据库的强烈兴趣，他开始阅读和分析 Redis 源代码，并对 Redis 2.6 和 Redis 3.0 的源代码进行了详细注释。他翻译并维护着 Redis 中文文档网站 www.RedisDoc .com ，编写 了 OORedis 库。除此之外，他还是《Redis in Action》一书的译者。\n作者的豆瓣主页：douban.com/people/i_m_huangz/","summary":"【官方网站】\n本书的官方网站 www.RedisBook.com 提供了书本试读、相关源码下载和勘误回报等服务，欢迎读者浏览和使用。\n【编辑推荐】\n系统而全面地描述了 Redis 内部运行机制\n图示丰富，描述清晰，并给出大量参考信息，是NoSQL数据库开发人员案头必备\n包括大部分Redis单机特征，以及所有多机特性\n【读者评价】\n这本书描述的知识点很丰富，覆盖很全，里面提到特性较多，有不少我们也没用过 :) 每个命令内部的机制的介绍很不错，很多估计也是首次有详细文档介绍。\n——杨卫华（@TimYang）新浪微博技术总监\n近几年Redis以其高性能、高灵活性的优点，变得越来越流行。但很多人在使用Redis时，仅仅还是停留在比较表层的功能性认识，缺乏对内部机制原理的深入理解。本书是huangz同学长期对Redis源码的阅读心得结晶，书中对Redis的各个方面都进行了详细且深入的讲解，将复杂的原理用最简单的方式为大家解构和讲解，强烈推荐给每一位Redis的使用者阅读。\n—— iammutex，NoSQLFan站长，乐视网技术经理\nRedis 是近些年来特别火爆的 NoSQL 之一。纵观中外各种书籍还没有一本能对 Redis 内部进行深入剖析，《Redis 设计与实现》可谓开此先河。常和作者在网上交流，知道作者为这本书付出了大量的心血。这本书行文流畅，思路清晰，详细地介绍了 Redis 源码的方方面面。无论是想学习 NoSQL、网络编程的初学者，还是源码控的进阶者，本书都会有很大的帮助。\n—— 阮若夷，支付宝高级专家\n【内容简介】\n本书全面而完整地讲解了Redis的内部机制与实现方式，对Redis的大多数单机功能以及所有多机功能的实现原理进行了介绍，展示了这些功能的核心数据结构以及关键的算法思想,图示丰富，描述清晰，并给出大量参考信息。通过阅读本书，读者可以快速、有效地了解Redis的内部构造以及运作机制，更好、更高效地使用Redis。\n本书主要分为四大部分。第一部分“数据结构与对象”介绍了Redis中的各种对象及其数据结构，并说明这些数据结构如何影响对象的功能和性能。第二部分“单机数据库的实现”对Redis实现单机数据库的方法进行了介绍，包括数据库、RDB持久化、AOF持久化、事件等。第三部分“多机数据库的实现”对Redis的Sentinel、复制、集群三个多机功能进行了介绍。第四部分“独立功能的实现”对Redis中各个相对独立的功能模块进行了介绍，涉及发布与订阅、事务、Lua脚本、排序、二进制位数组、慢查询日志、监视器等。本书作者专门维护了www.redisbook.com网站，提供带有详细注释的Redis源代码，以及本书相关的更新内容。","ebook_price":"30.00","series":{"id":"25452","title":"数据库技术丛书"},"price":"79.00"},"9787121198854":{"rating":{"max":10,"numRaters":433,"average":"9.4","min":0},"subtitle":"第3版","author":["施瓦茨 (Baron Schwartz)","扎伊采夫 (Peter Zaitsev)","特卡琴科 (Vadim Tkachenko)"],"pubdate":"2013-5-1","tags":[{"count":825,"name":"MySQL","title":"MySQL"},{"count":550,"name":"数据库","title":"数据库"},{"count":268,"name":"高性能MySQL","title":"高性能MySQL"},{"count":188,"name":"计算机","title":"计算机"},{"count":111,"name":"mysql","title":"mysql"},{"count":98,"name":"编程","title":"编程"},{"count":90,"name":"计算机科学","title":"计算机科学"},{"count":63,"name":"软件开发","title":"软件开发"}],"origin_title":"High Performance MySQL,3rd","image":"https://img1.doubanio.com/view/subject/m/public/s27783358.jpg","binding":"平装","translator":["宁海元","周振兴","彭立勋","翟卫祥,刘辉"],"catalog":"推荐序 xxiii\n前言 xxv\n第1 章 mysql 架构与历史 1\n1.1 mysql 逻辑架构 1\n1.1.1 连接管理与安全性2\n1.1.2 优化与执行 3\n1.2 并发控制 3\n1.2.1 读写锁 4\n1.2.2 锁粒度 4\n1.3 事务6\n1.3.1 隔离级别 8\n1.3.2 死锁 9\n1.3.3 事务日志 10\n1.3.4 mysql 中的事务 10\n1.4 多版本并发控制 12\n1.5 mysql 的存储引擎 13\n1.5.1 innodb 存储引擎 16\n1.5.2 myisam 存储引擎 17\n1.5.3 mysql 内建的其他存储引擎 19\n.1.5.4 第三方存储引擎 22\n1.5.5 选择合适的引擎 24\n1.5.6 转换表的引擎 27\n1.6 mysql 时间线（timeline） 29\n1.7 mysql 的开发模式 32\n1.8 总结 33\n第2 章 mysql 基准测试 35\n2.1 为什么需要基准测试 35\n2.2 基准测试的策略 37\n2.2.1 测试何种指标 38\n2.3 基准测试方法 40\n2.3.1 设计和规划基准测试 41\n2.3.2 基准测试应该运行多长时间 42\n2.3.3 获取系统性能和状态 43\n2.3.4 获得准确的测试结果 44\n2.3.5 运行基准测试并分析结果 46\n2.3.6 绘图的重要性 47\n2.4 基准测试工具 49\n2.4.1 集成式测试工具 49\n2.4.2 单组件式测试工具 50\n2.5 基准测试案例 52\n2.5.1 http_load 53\n2.5.2 mysql 基准测试套件 54\n2.5.3 sysbench 55\n2.5.4 数据库测试套件中的dbt2 tpc-c 测试 60\n2.5.5 percona 的tpcc-mysql 测试工具 63\n2.6 总结 65\n第3 章 服务器性能剖析 67\n3.1 性能优化简介 67\n3.1.1 通过性能剖析进行优化 69\n3.1.2 理解性能剖析 71\n3.2 对应用程序进行性能剖析 72\n3.2.1 测量php 应用程序 74\n3.3 剖析mysql 查询 77\n3.3.1 剖析服务器负载 77\n3.3.2 剖析单条查询 81\n3.3.3 使用性能剖析 87\n3.4 诊断间歇性问题 88\n3.4.1 单条查询问题还是服务器问题 89\n3.4.2 捕获诊断数据 93\n3.4.3 一个诊断案例 98\n3.5 其他剖析工具 106\n3.5.1 使用user_statistics 表 106\n3.5.2 使用strace 107\n3.6 总结 108\n第4 章 schema 与数据类型优化 111\n4.1 选择优化的数据类型 111\n4.1.1 整数类型 113\n4.1.2 实数类型 113\n4.1.3 字符串类型 114\n4.1.4 日期和时间类型 121\n4.1.5 位数据类型 123\n4.1.6 选择标识符（identifier） 125\n4.1.7 特殊类型数据 127\n4.2 mysql schema 设计中的陷阱 127\n4.3 范式和反范式 129\n4.3.1 范式的优点和缺点 130\n4.3.2 反范式的优点和缺点 130\n4.3.3 混用范式化和反范式化 131\n4.4 缓存表和汇总表 132\n4.4.1 物化视图 134\n4.4.2 计数器表 135\n4.5 加快alter table 操作的速度 136\n4.5.1 只修改.frm 文件 137\n4.5.2 快速创建myisam 索引 139\n4.6 总结 140\n第5 章 创建高性能的索引 141\n5.1 索引基础 141\n5.1.1 索引的类型 142\n5.2 索引的优点 152\n5.3 高性能的索引策略 153\n5.3.1 独立的列 153\n5.3.2 前缀索引和索引选择性 153\n5.3.3 多列索引 157\n5.3.4 选择合适的索引列顺序 159\n5.3.5 聚簇索引 162\n5.3.6 覆盖索引 171\n5.3.7 使用索引扫描来做排序 175\n5.3.8 压缩（前缀压缩）索引 177\n5.3.9 冗余和重复索引 178\n5.3.10 未使用的索引 181\n5.3.11 索引和锁 181\n5.4 索引案例学习 183\n5.4.1 支持多种过滤条件 183\n5.4.2 避免多个范围条件 185\n5.4.3 优化排序 186\n5.5 维护索引和表 187\n5.5.1 找到并修复损坏的表 187\n5.5.2 更新索引统计信息 188\n5.5.3 减少索引和数据的碎片 190\n5.6 总结 192\n第6 章 查询性能优化 195\n6.1 为什么查询速度会慢 195\n6.2 慢查询基础：优化数据访问 196\n6.2.1 是否向数据库请求了不需要的数据 196\n6.2.2 mysql 是否在扫描额外的记录 198\n6.3 重构查询的方式 201\n6.3.1 一个复杂查询还是多个简单查询 201\n6.3.2 切分查询 202\n6.3.3 分解关联查询 203\n6.4 查询执行的基础 204\n6.4.1 mysql 客户端/ 服务器通信协议 205\n6.4.2 查询缓存 208\n6.4.3 查询优化处理 208\n6.4.4 查询执行引擎 222\n6.4.5 返回结果给客户端 223\n6.5 mysql 查询优化器的局限性 223\n6.5.1 关联子查询 223\n6.5.2 union 的限制 228\n6.5.3 索引合并优化 228\n6.5.4 等值传递 229\n6.5.5 并行执行 229\n6.5.6 哈希关联 229\n6.5.7 松散索引扫描 229\n6.5.8 最大值和最小值优化 231\n6.5.9 在同一个表上查询和更新 232\n6.6 查询优化器的提示（hint） 232\n6.7 优化特定类型的查询 236\n6.7.1 优化count() 查询 236\n6.7.2 优化关联查询 239\n6.7.3 优化子查询 239\n6.7.4 优化group by 和distinct 239\n6.7.5 优化limit 分页 241\n6.7.6 优化sql_calc_found_rows 243\n6.7.7 优化union 查询 243\n6.7.8 静态查询分析 244\n6.7.9 使用用户自定义变量 244\n6.8 案例学习 251\n6.8.1 使用mysql 构建一个队列表 251\n6.8.2 计算两点之间的距离 254\n6.8.3 使用用户自定义函数 257\n6.9 总结 258\n第7 章 mysql 高级特性 259\n7.1 分区表 259\n7.1.1 分区表的原理 260\n7.1.2 分区表的类型 261\n7.1.3 如何使用分区表 262\n7.1.4 什么情况下会出问题 263\n7.1.5 查询优化 266\n7.1.6 合并表 267\n7.2 视图 270\n7.2.1 可更新视图 272\n7.2.2 视图对性能的影响 273\n7.2.3 视图的限制 274\n7.3 外键约束 275\n7.4 在mysql 内部存储代码 276\n7.4.1 存储过程和函数 278\n7.4.2 触发器 279\n7.4.3 事件 281\n7.4.4 在存储程序中保留注释 283\n7.5 游标 283\n7.6 绑定变量 284\n7.6.1 绑定变量的优化 286\n7.6.2 sql 接口的绑定变量 286\n7.6.3 绑定变量的限制 288\n7.7 用户自定义函数 289\n7.8 插件 290\n7.9 字符集和校对 291\n7.9.1 mysql 如何使用字符集 292\n7.9.2 选择字符集和校对规则 295\n7.9.3 字符集和校对规则如何影响查询 296\n7.10 全文索引 299\n7.10.1 自然语言的全文索引 300\n7.10.2 布尔全文索引 302\n7.10.3 mysql5.1 中全文索引的变化 303\n7.10.4 全文索引的限制和替代方案 304\n7.10.5 全文索引的配置和优化 306\n7.11 分布式（xa）事务 307\n7.11.1 内部xa 事务 307\n7.11.2 外部xa 事务 308\n7.12 查询缓存 309\n7.12.1 mysql 如何判断缓存命中 309\n7.12.2 查询缓存如何使用内存 311\n7.12.3 什么情况下查询缓存能发挥作用 313\n7.12.4 如何配置和维护查询缓存 316\n7.12.5 innodb 和查询缓存 319\n7.12.6 通用查询缓存优化 320\n7.12.7 查询缓存的替代方案 321\n7.13 总结 321\n第8 章 优化服务器设置 325\n8.1 mysql 配置的工作原理 326\n8.1.1 语法、作用域和动态性 327\n8.1.2 设置变量的副作用 328\n8.1.3 入门 331\n8.1.4 通过基准测试迭代优化 332\n8.2 什么不该做 333\n8.3 创建mysql 配置文件 335\n8.3.1 检查mysql 服务器状态变量 339\n8.4 配置内存使用 340\n8.4.1 mysql 可以使用多少内存？ 340\n8.4.2 每个连接需要的内存 341\n8.4.3 为操作系统保留内存 341\n8.4.4 为缓存分配内存 342\n8.4.5 innodb 缓冲池（buffer pool） 342\n8.4.6 myisam 键缓存（key caches） 344\n8.4.7 线程缓存 346\n8.4.8 表缓存（table cache） 347\n8.4.9 innodb 数据字典（data dictionary） 348\n8.5 配置mysql 的i/o 行为 349\n8.5.1 innodb i/o 配置 349\n8.5.2 myisam 的i/o 配置 361\n8.6 配置mysql 并发 363\n8.6.1 innodb 并发配置 364\n8.6.2 myisam 并发配置 365\n8.7 基于工作负载的配置 366\n8.7.1 优化blob 和text 的场景 367\n8.7.2 优化排序（filesorts） 368\n8.8 完成基本配置 369\n8.9 安全和稳定的设置 371\n8.10 高级innodb 设置 374\n8.11 总结 376\n第9 章 操作系统和硬件优化 377\n9.1 什么限制了mysql 的性能 377\n9.2 如何为mysql 选择cpu 378\n9.2.1 哪个更好：更快的cpu 还是更多的cpu 378\n9.2.2 cpu 架构 380\n9.2.3 扩展到多个cpu 和核心 381\n9.3 平衡内存和磁盘资源 382\n9.3.1 随机i/o 和顺序i/o 383\n9.3.2 缓存，读和写 384\n9.3.3 工作集是什么 385\n9.3.4 找到有效的内存/ 磁盘比例 386\n9.3.5 选择硬盘 387\n9.4 固态存储 389\n9.4.1 闪存概述 390\n9.4.2 闪存技术 391\n9.4.3 闪存的基准测试 392\n9.4.4 固态硬盘驱动器（ssd） 393\n9.4.5 pcie 存储设备 395\n9.4.6 其他类型的固态存储 396\n9.4.7 什么时候应该使用闪存 396\n9.4.8 使用flashcache 397\n9.4.9 优化固态存储上的mysql 399\n9.5 为备库选择硬件 402\n9.6 raid 性能优化 403\n9.6.1 raid 的故障转移、恢复和镜像 405\n9.6.2 平衡硬件raid 和软件raid 406\n9.6.3 raid 配置和缓存 407\n9.7 san 和nas 410\n9.7.1 san 基准测试 411\n9.7.2 使用基于nfs 或smb 的san 412\n9.7.3 mysql 在san 上的性能 412\n9.7.4 应该用san 吗 413\n9.8 使用多磁盘卷 414\n9.9 网络配置 416\n9.10 选择操作系统 418\n9.11 选择文件系统 419\n9.12 选择磁盘队列调度策略 421\n9.13 线程 422\n9.14 内存交换区 422\n9.15 操作系统状态 424\n9.15.1 如何阅读vmstat 的输出 425\n9.15.2 如何阅读iostat 的输出 426\n9.15.3 其他有用的工具 428\n9.15.4 cpu 密集型的机器 428\n9.15.5 i/o 密集型的机器 429\n9.15.6 发生内存交换的机器 430\n9.15.7 空闲的机器 430\n9.16 总结 431\n第10 章 复制 433\n10.1 复制概述 433\n10.1.1 复制解决的问题 434\n10.1.2 复制如何工作 435\n10.2 配置复制 436\n10.2.1 创建复制账号 437\n10.2.2 配置主库和备库 437\n10.2.3 启动复制 439\n10.2.4 从另一个服务器开始复制 441\n10.2.5 推荐的复制配置 443\n10.3 复制的原理 445\n10.3.1 基于语句的复制 445\n10.3.2 基于行的复制 446\n10.3.3 基于行或基于语句：哪种更优 446\n10.3.4 复制文件 448\n10.3.5 发送复制事件到其他备库 449\n10.3.6 复制过滤器 450\n10.4 复制拓扑 452\n10.4.1 一主库多备库 452\n10.4.2 主动- 主动模式下的主- 主复制 453\n10.4.3 主动- 被动模式下的主- 主复制 455\n10.4.4 拥有备库的主- 主结构 456\n10.4.5 环形复制 457\n10.4.6 主库、分发主库以及备库 458\n10.4.7 树或金字塔形 460\n10.4.8 定制的复制方案 460\n10.5 复制和容量规划 465\n10.5.1 为什么复制无法扩展写操作 466\n10.5.2 备库什么时候开始延迟 466\n10.5.3 规划冗余容量 467\n10.6 复制管理和维护 468\n10.6.1 监控复制 468\n10.6.2 测量备库延迟 469\n10.6.3 确定主备是否一致 469\n10.6.4 从主库重新同步备库 470\n10.6.5 改变主库 471\n10.6.6 在一个主- 主配置中交换角色 476\n10.7 复制的问题和解决方案 477\n10.7.1 数据损坏或丢失的错误 477\n10.7.2 使用非事务型表 480\n10.7.3 混合事务型和非事务型表 480\n10.7.4 不确定语句 481\n10.7.5 主库和备库使用不同的存储引擎 481\n10.7.6 备库发生数据改变 481\n10.7.7 不唯一的服务器id 482\n10.7.8 未定义的服务器id 482\n10.7.9 对未复制数据的依赖性 482\n10.7.10 丢失的临时表 483\n10.7.11 不复制所有的更新 484\n10.7.12 innodb 加锁读引起的锁争用 484\n10.7.13 在主- 主复制结构中写入两台主库 486\n10.7.14 过大的复制延迟 488\n10.7.15 来自主库的过大的包 491\n10.7.16 受限制的复制带宽 491\n10.7.17 磁盘空间不足 492\n10.7.18 复制的局限性 492\n10.8 复制有多快 492\n10.9 mysql 复制的高级特性 494\n10.10 其他复制技术 496\n10.11 总结 498\n第11 章 可扩展的mysql 501\n11.1 什么是可扩展性 501\n11.1.1 正式的可扩展性定义 503\n11.2 扩展mysql 507\n11.2.1 规划可扩展性 507\n11.2.2 为扩展赢得时间 508\n11.2.3 向上扩展 509\n11.2.4 向外扩展 510\n11.2.5 通过多实例扩展 525\n11.2.6 通过集群扩展 526\n11.2.7 向内扩展 530\n11.3 负载均衡 532\n11.3.1 直接连接 534\n11.3.2 引入中间件 537\n11.3.3 一主多备间的负载均衡 540\n11.4 总结 541\n第12 章 高可用性 543\n12.1 什么是高可用性 543\n12.2 导致宕机的原因 544\n12.3 如何实现高可用性 545\n12.3.1 提升平均失效时间（mtbf） 545\n12.3.2 降低平均恢复时间（mttr） 547\n12.4 避免单点失效 548\n12.4.1 共享存储或磁盘复制 549\n12.4.2 mysql 同步复制 551\n12.4.3 基于复制的冗余 555\n12.5 故障转移和故障恢复 556\n12.5.1 提升备库或切换角色 558\n12.5.2 虚拟ip 地址或ip 接管 558\n12.5.3 中间件解决方案 559\n12.5.4 在应用中处理故障转移 560\n12.6 总结 560\n第13 章 云端的mysql 563\n13.1 云的优点、缺点和相关误解 564\n13.2 mysql 在云端的经济价值 566\n13.3 云中的mysql 的可扩展性和高可用性 567\n13.4 四种基础资源 568\n13.5 mysql 在云主机上的性能 569\n13.5.1 在云端的mysql 基准测试 571\n13.6 mysql 数据库即服务（dbaas） 573\n13.6.1 amazon rds 573\n13.6.2 其他dbaas 解决方案 574\n13.7 总结 575\n第14 章 应用层优化 577\n14.1 常见问题 577\n14.2 web 服务器问题 579\n14.2.1 寻找最优并发度 581\n14.3 缓存 582\n14.3.1 应用层以下的缓存 583\n14.3.2 应用层缓存 584\n14.3.3 缓存控制策略 586\n14.3.4 缓存对象分层 587\n14.3.5 预生成内容 588\n14.3.6 作为基础组件的缓存 589\n14.3.7 使用handlersocket 和memcached 589\n14.4 拓展mysql 590\n14.5 mysql 的替代品 590\n14.6 总结 591\n第15 章 备份与恢复 593\n15.1 为什么要备份 594\n15.2 定义恢复需求 595\n15.3 设计mysql 备份方案 596\n15.3.1 在线备份还是离线备份 597\n15.3.2 逻辑备份还是物理备份 598\n15.3.3 备份什么 601\n15.3.4 存储引擎和一致性 603\n15.4 管理和备份二进制日志 605\n15.4.1 二进制日志格式 606\n15.4.2 安全地清除老的二进制日志 607\n15.5 备份数据 607\n15.5.1 生成逻辑备份 607\n15.5.2 文件系统快照 610\n15.6 从备份中恢复 617\n15.6.1 恢复物理备份 618\n15.6.2 还原逻辑备份 619\n15.6.3 基于时间点的恢复 622\n15.6.4 更高级的恢复技术 624\n15.6.5 innodb 崩溃恢复 625\n15.7 备份和恢复工具 628\n15.7.1 mysql enterprise backup 628\n15.7.2 percona xtrabackup 628\n15.7.3 mylvmbackup 629\n15.7.4 zmanda recovery manager 629\n15.7.5 mydumper 629\n15.7.6 mysqldump 629\n15.8 备份脚本化 631\n15.9 总结 633\n第16 章 mysql 用户工具 635\n16.1 接口工具 635\n16.2 命令行工具集 636\n16.3 sql 实用集 637\n16.4 监测工具 637\n16.4.1 开源的监控工具 638\n16.4.2 商业监控系统 640\n16.4.3 innotop 的命令行监控 642\n16.5 总结 646\n附录a mysql 分支与变种 649\n附录b mysql 服务器状态 655\n附录c 大文件传输 683\n附录d explain 687\n附录e 锁的调试 703\n附录f 在mysql 上使用sphinx 713\n索引 739","ebook_url":"https://read.douban.com/ebook/35648568/","pages":"764","images":{"small":"https://img1.doubanio.com/view/subject/s/public/s27783358.jpg","large":"https://img1.doubanio.com/view/subject/l/public/s27783358.jpg","medium":"https://img1.doubanio.com/view/subject/m/public/s27783358.jpg"},"alt":"https://book.douban.com/subject/23008813/","id":"23008813","publisher":"电子工业出版社","isbn10":"7121198851","isbn13":"9787121198854","title":"高性能MySQL","url":"https://api.douban.com/v2/book/23008813","alt_title":"High Performance MySQL,3rd","author_intro":"关于作者\nBaron Schwartz 是一位软件工程师，居住在弗吉尼亚州的Charlottesville，网络常用名是Xaprb，这是按照QWERTY 键盘的顺序在Dvorak 键盘上打出来的名字。在不忙于解决有趣的编程挑战时，Baron 会和他的妻子Lynn 以及小狗Carbon 一起享受闲暇的时光。他有一个软件工程方面的博客，地址是http://www.xaprb.com/blog/\nPeter Zaitsev 曾经是MySQL AB 公司高性能组的经理，目前在运作mysqlperformance\nblog.com 网站。他擅长于帮助那些每天有数以百万计访问量的网站的管理员解决问题，这些网站通常需要几百台机器来处理TB 级的数据。他常常为了解决一个问题而不停地升级硬件和软件（比如查询优化）。Peter 还经常在各种会议上演讲。\nVadim Tkachenko 曾经是MySQL AB 公司的性能工程师。作为一名在多线程编程和同步方面的专家，他的主要工作是基准测试、性能剖析，以及找出系统的性能瓶颈。他还在性能监控和调优方面做了一些工作，使得MySQL 在多核机器上有更好的可扩展性。\n================================================================\n译者简介\n宁海元 有超过十年的数据库管理经验，从最初到SQL Server 2000到Oracle到MySQL，擅长数据库高可用架构，性能优化和故障诊断。2007年加入淘宝，带领淘宝DBA团队支撑了淘宝业务的快速增长，完成了数据库的垂直拆分、水平拆分，迁移到MySQL体系等主要工作。目前专注于无线数据领域。网络常用名NinGoo，个人博客：http://www.ningoo.net\n周振兴 毕业于北京师范大学数学系，09年加入淘宝数据库团队负责MySQL运维管理工作，有丰富的MySQL性能优化、Troubleshooting经验，对MySQL主要模块的实现和原理有深入的研究，经历淘宝MySQL实例从30到3000的发展，对系统架构、高可用环境规划都有深入理解。个人博客：http://orczhou.com\n彭立勋 2010年大学毕业后加入阿里巴巴运维部。作为一名MySQL DBA，在运维MySQL的过程中，对MySQL和InnoDB的一些功能和缺陷就进行了补充，编写了多主复制和数据闪回等补丁。目前在阿里集团核心系统研发部数据库组，专注于MySQL数据库相关的开发工作。后来一些补丁被MySQL之父Mony看中，成为MariaDB提交组（Maria-captains）成员，并且把多主复制，线程内存监控等补丁合并到了MariaDB 10.0版本。\n翟卫祥 毕业于武汉大学，研究生阶段从事数据库相关研究。毕业后就职于阿里巴巴集团数据库技术团队至今，主要负责阿里内部MySQL代码分支维护，包括MySQL Bug Fix及新特性开发。对MySQL内核有一定的研究。\n刘辉 2008年毕业于西安电子科技大学计算机系，硕士学位。2011年加入阿里巴巴集团数据库技术团队，花名希羽，MySQL内核开发工程师。","summary":"《高性能mysql(第3版)》是mysql 领域的经典之作，拥有广泛的影响力。第3 版更新了大量的内容，不但涵盖了最新mysql 5.5版本的新特性，也讲述了关于固态盘、高可扩展性设计和云计算环境下的数据库相关的新内容，原有的基准测试和性能优化部分也做了大量的扩展和补充。全书共分为16 章和6 个附录，内容涵盖mysql 架构和历史，基准测试和性能剖析，数据库软硬件性能优化，复制、备份和恢复，高可用与高可扩展性，以及云端的mysql 和mysql相关工具等方面的内容。每一章都是相对独立的主题，读者可以有选择性地单独阅读。\n《高性能mysql(第3版)》不但适合数据库管理员（dba）阅读，也适合开发人员参考学习。不管是数据库新手还是专家，相信都能从本书有所收获。","ebook_price":"96.00","price":"128.00元"},"9787564115197":{"rating":{"max":10,"numRaters":95,"average":"8.0","min":0},"subtitle":"LINUX系统编程","author":["Robert Love"],"pubdate":"2009-7","tags":[{"count":140,"name":"Linux","title":"Linux"},{"count":78,"name":"系统编程","title":"系统编程"},{"count":64,"name":"编程","title":"编程"},{"count":48,"name":"Linux/Unix","title":"Linux/Unix"},{"count":40,"name":"操作系统","title":"操作系统"},{"count":38,"name":"计算机","title":"计算机"},{"count":30,"name":"linux","title":"linux"},{"count":26,"name":"Programming","title":"Programming"}],"origin_title":"","image":"https://img3.doubanio.com/view/subject/m/public/s26696540.jpg","binding":"","translator":["O'Reilly Taiwan公司"],"catalog":"序\n前言\n第一章 介绍与基本概念\n系统编程\nAPI与ABI\n标准\nLinux编程的概念\n向系统编程迈进\n第二章 文件I／O\n打开文件\n以read()进行读取操作\n以write()进行写入操作\n同步化I／O\n关闭文件\n使用lseek()查找文件位置\n针对特定位置的读取与写入\n截短文件\n多任务式I／O\n内核内部\n结束语\n第三章 缓冲式I／O\n用户缓冲式I／O\n标准I／O\n打开文件\n经文件描述符打开流\n关闭流\n从流中读取\n使用缓冲式I／O的简单程序\n查找一个流\n刷新一个流\n错误与EOF\n取得相应的文件描述符\n控制与缓冲机制\n线程安全\n标准I／O的缺陷\n结束语\n第四章 高级文件I／O\n分散一聚集I／O\n事件轮询接口\n将文件映射至内存\n对一般文件I／0的用法提供建议\n同步化、同步及异步操作\nI／O调度程序与I／O性能\n结束语\n第五章 进程管理\n进程ID\n运行一个新进程\n终止一个进程\n等待已终止的子进程\n用户与组\n会话与进程组\n守护进程\n结束语\n第六章 高级进程管理\n进程的调度\n让出处理器\n进程优先级\n实时系统\n资源限制\n第七章 文件和目录管理\n文件与其元数据\n目录\n链接\n文件的复制以及移动\n设备节点\n带外通信\n第八章 内存管理\n进程地址空间\n分配动态内存\n管理数据段\n匿名内存映射\n高级内存分配\n调试内存分配\n基于堆栈的分配\n选择内存分配机制\n操作内存\n锁定内存\n投机取巧的分配策略\n第九章 信号\n信号的概念\n基本的信号管理\n发送一个信号\n可重人性\n信号集\n阻挡信号\n高级信号管理\n以payload送出信号\n结束语\n第十章 时间\n时间的数据结构\nPOSIX时钟\n取得当前时间\n设定当前时间\n操作时间\n调整系统时钟\n休眠与等待\n定时器\n附录GCC对C语言的扩展\n参考书目","pages":"382","images":{"small":"https://img3.doubanio.com/view/subject/s/public/s26696540.jpg","large":"https://img3.doubanio.com/view/subject/l/public/s26696540.jpg","medium":"https://img3.doubanio.com/view/subject/m/public/s26696540.jpg"},"alt":"https://book.douban.com/subject/3907181/","id":"3907181","publisher":"东南大学出版社","isbn10":"756411519X","isbn13":"9787564115197","title":"LINUX系统编程","url":"https://api.douban.com/v2/book/3907181","alt_title":"","author_intro":"","summary":"《LINUX系统编程》讲述了：在某些时刻，几乎所有的程序员都要与其程序所处操作系统中的系统调用和程序库打交道。《LINUX系统编程》主要讨论如何编写Linux系统软件——代码位于底层，并且直接跟内核及核心系统程序库对话。《Linux系统编程》描述了使用标准接口包括使用Linux独有的高级接口时，在功能和性能之间如何进行权衡取舍的策略。\n该书同样也是一本内行人士编写灵活高效代码的学习指南。作为内核黑客和《LINUX系统编程》的作者，Robert Love不仅阐释了系统接口应该如何工作，还介绍了它们实际上是如何工作的，以及怎样安全有效地使用它们。《Linux系统编程》包含了帮助你在任何层面编写更佳代码的实用技巧。\n《LINUX系统编程》主题包括：\n读写文件以及其他文件I／O操作，包括Linux内核如何实现和管理文件I／O，内存映射与优化\n技术进程管理的系统调用，包括实时进程\n文件与目录——创建、移动、复制、删除和管理\n内存管理——内存分配接口，管理内存，以及优化内存访问\n信号及其在Unix系统中的角色，以及基本和高级信号接口\n时间、休眠和时钟管理，从基础开始讲述，并且涵盖POSIX时钟和高精度计时器拥有《Linux系统编程》，你将从理论和应用的角度深入了解Linux，可以最大限度地利用系统的潜能。","price":"56.00元"},"9787115352118":{"rating":{"max":10,"numRaters":226,"average":"9.5","min":0},"subtitle":"","author":["史蒂文斯 (W.Richard Stevens)","拉戈 (Stephen A.Rago)"],"pubdate":"2014-6-1","tags":[{"count":201,"name":"Unix","title":"Unix"},{"count":189,"name":"编程","title":"编程"},{"count":188,"name":"Linux/Unix","title":"Linux/Unix"},{"count":109,"name":"计算机","title":"计算机"},{"count":86,"name":"计算机科学","title":"计算机科学"},{"count":83,"name":"程序设计","title":"程序设计"},{"count":75,"name":"Linux","title":"Linux"},{"count":67,"name":"C","title":"C"}],"origin_title":"Advanced Programming in the UNIX Environment, Third Edition","image":"https://img1.doubanio.com/view/subject/m/public/s28284137.jpg","binding":"平装","translator":["戚正伟","张亚英","尤晋元"],"catalog":"第1章 UNIX基础知识\n1.1 引言\n1.2 UNIX体系结构\n1.3 登录\n1.4 文件和目录\n1.5 输入和输出\n1.6 程序和进程\n1.7 出错处理\n1.8 用户标识\n1.9 信号\n1.10 时间值\n1.11 系统调用和库函数\n1.12 小结\n习题\n第2章 UNIX标准及实现\n2.1 引言\n2.2 UNIX标准化\n2.2.1 ISO C\n2.2.2 IEEE POSIX\n2.2.3 Single UNIX Specification\n2.2.4 FIPS\n2.3 UNIX系统实现\n2.3.1 SVR4\n2.3.2 4.4BSD\n2.3.3 FreeBSD\n2.3.4 Linux\n2.3.5 Mac OS X\n2.3.6 Solaris\n2.3.7 其他UNIX系统\n2.4 标准和实现的关系\n2.5 限制\n2.5.1 ISO C限制\n2.5.2 POSIX限制\n2.5.3 XSI限制\n2.5.4 函数sysconf、pathconf和fpathconf\n2.5.5 不确定的运行时限制\n2.6 选项\n2.7 功能测试宏\n2.8 基本系统数据类型\n2.9 标准之间的冲突\n2.10 小结\n习题\n第3章 文件I/O\n3.1 引言\n3.2 文件描述符\n3.3 函数open和openat\n3.4 函数creat\n3.5 函数close\n3.6 函数lseek\n3.7 函数read\n3.8 函数write\n3.9 I/O的效率\n3.10 文件共享\n3.11 原子操作\n3.12 函数dup和dup2\n3.13 函数sync、fsync和fdatasync\n3.14 函数fcntl\n3.15 函数ioctl\n3.16 /dev/fd\n3.17 小结\n习题\n第4章 文件和目录\n4.1 引言\n4.2 函数stat、fstat、fstatat和lstat\n4.3 文件类型\n4.4 设置用户ID和设置组ID\n4.5 文件访问权限\n4.6 新文件和目录的所有权\n4.7 函数access和faccessat\n4.8 函数umask\n4.9 函数chmod、fchmod和fchmodat\n4.10 粘着位\n4.11 函数chown、fchown、fchownat和lchown\n4.12 文件长度\n4.13 文件截断\n4.14 文件系统\n4.15 函数link、linkat、unlink、unlinkat和remove\n4.16 函数rename和renameat\n4.17 符号链接\n4.18 创建和读取符号链接\n4.19 文件的时间\n4.20 函数futimens、utimensat和utimes\n4.21 函数mkdir、mkdirat和rmdir\n4.22 读目录\n4.23 函数chdir、fchdir和getcwd\n4.24 设备特殊文件\n4.25 文件访问权限位小结\n4.26 小结\n习题\n第5章 标准I/O库\n5.1 引言\n5.2 流和FILE对象\n5.3 标准输入、标准输出和标准错误\n5.4 缓冲\n5.5 打开流\n5.6 读和写流\n5.7 每次一行I/O\n5.8 标准I/O的效率\n5.9 二进制I/O\n5.10 定位流\n5.11 格式化I/O\n5.12 实现细节\n5.13 临时文件\n5.14 内存流\n5.15 标准I/O的替代软件\n5.16 小结\n习题\n第6章 系统数据文件和信息\n6.1 引言\n6.2 口令文件\n6.3 阴影口令\n6.4 组文件\n6.5 附属组ID\n6.6 实现区别\n6.7 其他数据文件\n6.8 登录账户记录\n6.9 系统标识\n6.10 时间和日期例程\n6.11 小结\n习题\n第7章 进程环境\n7.1 引言\n7.2 main函数\n7.3 进程终止\n7.4 命令行参数\n7.5 环境表\n7.6 C程序的存储空间布局\n7.7 共享库\n7.8 存储空间分配\n7.9 环境变量\n7.10 函数setjmp和longjmp\n7.11 函数getrlimit和setrlimit\n7.12 小结\n习题\n第8章 进程控制\n8.1 引言\n8.2 进程标识\n8.3 函数fork\n8.4 函数vfork\n8.5 函数exit\n8.6 函数wait和waitpid\n8.7 函数waitid\n8.8 函数wait3和wait4\n8.9 竞争条件\n8.10 函数exec\n8.11 更改用户ID和更改组ID\n8.12 解释器文件\n8.13 函数system\n8.14 进程会计\n8.15 用户标识\n8.16 进程调度\n8.17 进程时间\n8.18 小结\n习题\n第9章 进程关系\n9.1 引言\n9.2 终端登录\n9.3 网络登录\n9.4 进程组\n9.5 会话\n9.6 控制终端\n9.7 函数tcgetpgrp、tcsetpgrp和tcgetsid\n9.8 作业控制\n9.9 shell执行程序\n9.10 孤儿进程组\n9.11 FreeBSD实现\n9.12 小结\n习题\n第10章 信号\n10.1 引言\n10.2 信号概念\n10.3 函数signal\n10.4 不可靠的信号\n10.5 中断的系统调用\n10.6 可重入函数\n10.7 SIGCLD语义\n10.8 可靠信号术语和语义\n10.9 函数kill和raise\n10.10 函数alarm和pause\n10.11 信号集\n10.12 函数sigprocmask\n10.13 函数sigpending\n10.14 函数sigaction\n10.15 函数sigsetjmp和siglongjmp\n10.16 函数sigsuspend\n10.17 函数abort\n10.18 函数system\n10.19 函数sleep、nanosleep和clock_nanosleep\n10.20 函数sigqueue\n10.21 作业控制信号\n10.22 信号名和编号\n10.23 小结\n习题\n第11章 线程\n11.1 引言\n11.2 线程概念\n11.3 线程标识\n11.4 线程创建\n11.5 线程终止\n11.6 线程同步\n11.6.1 互斥量\n11.6.2 避免死锁\n11.6.3 函数pthread_mutex_timedlock\n11.6.4 读写锁\n11.6.5 带有超时的读写锁\n11.6.6 条件变量\n11.6.7 自旋锁\n11.6.8 屏障\n11.7 小结\n习题\n第12章 线程控制\n12.1 引言\n12.2 线程限制\n12.3 线程属性\n12.4 同步属性\n12.4.1 互斥量属性\n12.4.2 读写锁属性\n12.4.3 条件变量属性\n12.4.4 屏障属性\n12.5 重入\n12.6 线程特定数据\n12.7 取消选项\n12.8 线程和信号\n12.9 线程和fork\n12.10 线程和I/O\n12.11 小结\n习题\n第13章 守护进程\n13.1 引言\n13.2 守护进程的特征\n13.3 编程规则\n13.4 出错记录\n13.5 单实例守护进程\n13.6 守护进程的惯例\n13.7 客户进程-服务器进程模型\n13.8 小结\n习题\n第14章 高级I/O\n14.1 引言\n14.2 非阻塞I/O\n14.3 记录锁\n14.4 I/O多路转接\n14.4.1 函数select和pselect\n14.4.2 函数poll\n14.5 异步I/O\n14.5.1 System V异步I/O\n14.5.2 BSD异步I/O\n14.5.3 POSIX异步I/O\n14.6 函数readv和writev\n14.7 函数readn和writen\n14.8 存储映射I/O\n14.9 小结","pages":"812","images":{"small":"https://img1.doubanio.com/view/subject/s/public/s28284137.jpg","large":"https://img1.doubanio.com/view/subject/l/public/s28284137.jpg","medium":"https://img1.doubanio.com/view/subject/m/public/s28284137.jpg"},"alt":"https://book.douban.com/subject/25900403/","id":"25900403","publisher":"人民邮电出版社","isbn10":"7115352119","isbn13":"9787115352118","title":"UNIX环境高级编程（第3版）","url":"https://api.douban.com/v2/book/25900403","alt_title":"Advanced Programming in the UNIX Environment, Third Edition","author_intro":"作者介绍\nW. Richard Stevens，国际知名的UNIX和网络专家，备受赞誉的技术作家。生前著有多部经典的传世之作，包括《UNIX网络编程》（两卷本）、《TCP/IP详解》（三卷本）和本书第1版。\nStephen A. Rago，资深UNIX程序员，目前任NEC美国实验室存储系统集团研究员。之前是贝尔实验室的UNIX系统V版本4的开发人员之一。著有《UNIX系统V网络编程》，并曾担任本书第1版的技术审校和第2版的共同作者。\n译者介绍\n戚正伟，博士，上海交通大学软件学院副教授，微软亚洲研究院（2008）和美国CMU大学（2011-2012）访问学者。研究方向为系统软件和程序分析，著有《New Blue Pill深入理解硬件虚拟机》和《嵌入式GIS开发及应用》等书。\n张亚英，博士，同济大学电子与信息工程学院计算机系副教授，研究方向为分布与移动计算、嵌入式系统以及系统软件等。\n尤晋元，上海交通大学计算机科学及工程系教授、博士生导师。在科研方面，主要从事操作系统和分布对象计算技术方面的研究。在教学方面，长期承担操作系统及分布计算等课程的教学工作。主编和翻译了多本操作系统教材和参考书，包括《UNIX操作系统教程》、《UNIX高级编程技术》、《UNIX环境高级编程》和《操作系统：设计与实现》等。","summary":"《UNIX环境高级编程（第3版）》是被誉为UNIX编程“圣经”的Advanced Programming in the UNIX Environment一书的第3版。在本书第2版出版后的8年中，UNIX行业发生了巨大的变化，特别是影响UNIX编程接口的有关标准变化很大。本书在保持前一版风格的基础上，根据最新的标准对内容进行了修订和增补，反映了最新的技术发展。书中除了介绍UNIX文件和目录、标准I/O库、系统数据文件和信息、进程环境、进程控制、进程关系、信号、线程、线程控制、守护进程、各种I/O、进程间通信、网络IPC、伪终端等方面的内容，还在此基础上介绍了众多应用实例，包括如何创建数据库函数库以及如何与网络打印机通信等。此外，还在附录中给出了函数原型和部分习题的答案。\n《UNIX环境高级编程（第3版）》内容权威，概念清晰，阐述精辟，对于所有层次UNIX/Linux程序员都是一本不可或缺的参考书。\n适读人群 ：所有层次UNIX/Linux程序员\n20多年来，严谨的C程序员都是依靠一本书来深入了解驱动UNIX和Linux内核的编程接口的实用知识的，这本书就是W. Richard Stevens所著的《UNIX高级环境编程》。现在，Stevens的同事Steve Rago彻底更新了这本经典著作。新的第3版支持当今领先的系统平台，反映了最新技术进展和最佳实践，并且符合最新的Single UNIX Specification第4版（SUSv4）。\nRago保留了使本书前版成为经典之作的精髓和方法。他在Stevens原著的基础上，从基础的文件、目录和进程讲起，并给诸如信号处理和终端I/O之类的先进技术保留较大的篇幅。他还深入讨论了线程和多线程编程、使用套接字接口驱动进程间通信（IPC）等方面的内容。\n这一版涵盖了70多个最新版POSIX.1标准的新增接口，包括POSIX异步I/O、旋转锁、屏障（barrier）和POSIX信号量。此外，这一版删除了许多过时的接口，保留了一些广泛使用的接口。书中几乎所有实例都已经在目前最主流的4个平台上测试过，包括Solaris 10、Mac OS X 10.6.8（Darwin 10.8.0）、FressBSD 8.0、Ubuntu 12.04（基于Linux 3.2内核）。\n与前两版一样，读者仍可以通过实例学习，这些实例包括了1万多行可下载的ISO C源代码，书中通过简明但完整的程序阐述了400多个系统调用和函数，清楚地说明它们的用法、参数和返回值。为了使读者能融会贯通，书中还提供了几个贯穿整章的案例，每个案例都根据现在的技术环境进行了全面更新。\n《UNIX环境高级编程（第3版）》帮助了几代程序员写出强大、高性能、可靠的代码。第3版根据当今主流系统进行更新，更具实用价值。\n精彩书评：\n本书第1版连同Stevens所著的系列网络技术书籍，被公认为优秀的、匠心独具的名著，成为极其畅销的作品……总之，这是一本弥足珍贵的经典著作的更新版。\n——Dennis Ritchie，图灵奖得主，UNIX操作系统和C语言之父\n对任何一个严谨的、专业的UNIX系统程序员而言，本书都是不可或缺的权威参考书。Rago更新和扩展了Stevens的经典著作，并保持了原书的风貌。书中利用清晰的实例演示了API的使用过程，还提到了许多在不同UNIX系统实现上编程时需要注意的陷阱，并指出如何使用相关的标准（如POSIX 1003.1 2004版和Single UNIX Specification第3版）来避免这些错误。\n——Andrew Josey， The Open Group标准部门主管，POSIX 1003.1标准工作组主席\n绝对的UNIX编程经典之一。\n——Eric S. Raymond，《UNIX编程艺术》作者\nStephen Rago的更新版本对于使用众多UNIX及相关操作系统环境的广大专业用户来说是一个迟来的喜讯。这一版不仅删除了过时的接口，吸纳了较新的开发接口，还根据UNIX及类UNIX操作系统环境的几种主流实现发布的新版本全面更新了所有主题、实例和应用的背景。难能可贵的是，这一版本还保持了经典的第1版的风格和品位。\n——Mukesh Kacker，Pronto Networks公司联合创始人和前任CTO\n本书对于任何在UNIX系统上编写程序的开发人员来说都是非常重要的参考书。当我想要了解或者重新回顾各种系统接口时，这本书是首选的求助工具。Stephen Rago成功地修订了本书，使其与新的操作系统（如GNU/Linux和苹果的OS X）相容，并保持了第1版易读和实用的特质。它将永远摆放在我桌上随手可及的位置。\n——Benjamin Kuperman博士，斯沃斯莫尔学院\n这是每一位严谨的UNIX C程序员必备的书籍。它深入、全面、清晰的解释是无可匹敌的。\n——UniForum Monthly\n从W. Richard Stevens的这本书中可以找到更多易于理解的、详尽的UNIX系统内部细节。这本书包含了大量实际的例子，对系统编程工作非常有益。\n——RS/Magazine","price":"128.00元"},"9787111384991":{"rating":{"max":10,"numRaters":232,"average":"8.8","min":0},"subtitle":"—服务器架设篇(第三版)","author":["鸟哥"],"pubdate":"2012-7","tags":[{"count":308,"name":"Linux","title":"Linux"},{"count":141,"name":"服务器","title":"服务器"},{"count":86,"name":"计算机","title":"计算机"},{"count":76,"name":"鸟哥的Linux私房菜","title":"鸟哥的Linux私房菜"},{"count":57,"name":"服务器架设篇","title":"服务器架设篇"},{"count":56,"name":"操作系统","title":"操作系统"},{"count":44,"name":"Linux/Unix","title":"Linux/Unix"},{"count":27,"name":"鸟哥","title":"鸟哥"}],"origin_title":"","image":"https://img3.doubanio.com/view/subject/m/public/s10328185.jpg","binding":"平装","translator":[],"catalog":"目录\n《鸟哥的linux私房菜——服务器架设篇(第三版)》\n作者序\n第一篇　 服务器搭建前的进修专区\n第1章　 搭建服务器前的准备工作 2\n1.1　linux 的功能 3\n1.1.1　用 linux 搭建服务器需要的能力 3\n1.1.2　搭建服务器难不难呢 4\n1.2　搭建服务器的基本流程 5\n1.2.1　网络服务器成功连接的分析 5\n1.2.2　一个常见的服务器设置案例分析 8\n1.2.3　系统安全与备份处理 25\n1.3　自我评估是否已经具备服务器搭建的能力 27\n第2章　 网络的基本概念 29\n2.1　网络 30\n2.1.1　什么是网络 30\n2.1.2　计算机网络组成组件 32\n2.1.3　计算机网络的范围 33\n2.1.4　计算机网络协议：osi 七层协议 34\n2.1.5　计算机网络协议：tcp/ip 37\n2.2　tcp/ip 的网络接口层的相关协议 39\n.2.2.1　广域网使用的设备 39\n2.2.2　局域网使用的设备——以太网 40\n2.2.3　以太网络的传输协议：csma/cd 42\n2.2.4　mac 的封装格式 44\n2.2.5　mtu（最大传输单位） 46\n2.2.6　集线器、交换器与相关机制 47\n2.3　tcp/ip 的网络层相关数据包与数据 49\n2.3.1　ip 数据包的封装 49\n2.3.2　ip 地址的组成与分级 52\n2.3.3　ip 的种类与取得方式 55\n2.3.4　netmask、子网与 cidr（classless interdomain routing） 57\n2.3.5　路由概念 61\n2.3.6　观察主机路由：route 64\n2.3.7　ip 与 mac：网络接口层的 arp 与 rarp 协议 65\n2.3.8　icmp 协议 66\n2.4　tcp/ip 的传输层相关数据包与数据 67\n2.4.1　面向连接的可靠的 tcp 协议 67\n2.4.2　tcp 的三次握手 72\n2.4.3　无连接的 udp 协议 73\n2.4.4　网络防火墙与 osi 七层协议 74\n2.5　连上 internet 前的准备事项 75\n2.5.1　ip地址、主机名与dns系统 75\n2.5.2　连上 internet 的必要网络参数 76\n2.6　重点回顾 77\n2.7　参考数据与延伸阅读 78\n第3章　 局域网架构简介 79\n3.1　局域网的连接 80\n3.1.1　局域网的布线规划 80\n3.1.2　网络设备选购建议 84\n3.2　本书使用的内部连接网络参数与通信协议 88\n3.2.1　网络联机参数与通信协议 88\n3.2.2　windows 个人计算机网络配置范例 90\n第4章　 连接 internet 93\n4.1　linux 连接 internet 前的注意事项 94\n4.1.1　linux 的网卡 94\n4.1.2　编译网卡驱动程序（option） 96\n4.1.3　linux 网络相关配置文件 98\n4.2　连接 internet 的设置方法 100\n4.2.1　手动配置固定 ip 参数 100\n4.2.2　自动取得 ip 参数（dhcp 方法，适用 cable modem、ip 路由器的环境） 105\n4.2.3　adsl 拨号上网（适用 adsl 拨号以及光纤接入） 106\n4.3　无线网络——以笔记本电脑为例 111\n4.3.1　无线网络所需要的硬件：ap、无线网卡 111\n4.3.2　关于 ap 的设置：网络安全方面 113\n4.3.3　利用无线网卡开始连接 115\n4.4　常见问题说明 118\n4.4.1　内部网络使用某些服务（如 ftp、pop3）所遇到的连接延迟问题 118\n4.4.2　域名无法解析的问题 120\n4.4.3　默认网关的问题 120\n4.5　重点回顾 121\n4.6　参考数据与延伸阅读 121\n第5章　 linux 中常用的网络命令 122\n5.1　设置网络参数的命令 123\n5.1.1　 手动/自动配置ip 参数与启动/关闭网络接口：ifconfig、ifup、ifdown 123\n5.1.2　修改路由：route 126\n5.1.3　网络参数综合命令：ip 128\n5.1.4　无线网络：iwlist, iwconfig 134\n5.1.5　dhcp客户端命令：dhclient 134\n5.2　网络排错与查看命令 134\n5.2.1　两台主机的两点沟通：ping 134\n5.2.2　两主机间各节点分析：traceroute 137\n5.2.3　查看本机的网络连接与后门：netstat 138\n5.2.4　检测主机名与 ip 的对应：host、nslookup 141\n5.3　远程连接命令与即时通信软件 143\n5.3.1　终端机与 bbs 连接：telnet 143\n5.3.2　ftp 连接软件：ftp、lftp 144\n5.3.3　图形接口的即时通信软件：pidgin（gaim 的延伸） 147\n5.4　文字接口网页浏览 150\n5.4.1　文字浏览器：links 150\n5.4.2　文字接口下载器：wget 152\n5.5　数据包捕获功能 153\n5.5.1　文字接口数据包捕获器：tcpdump 153\n5.5.2　图形接口数据包捕获器：wireshark 157\n5.5.3　任意启动 tcp/udp 数据包的端口连接：nc、netcat 159\n5.6　重点回顾 160\n5.7　参考数据与延伸阅读 161\n第6章　 linux 网络排错 162\n6.1　无法连接网络的原因分析 163\n6.1.1　硬件问题：网线、网络设备、网络布线等 163\n6.1.2　软件问题：ip 参数设置、路由设置、服务器与防火墙设置等 165\n6.1.3　问题的处理 165\n6.2　处理流程 166\n6.2.1　步骤1：网卡工作确认 166\n6.2.2　步骤2：局域网内各项连接设备检测 167\n6.2.3　步骤3：取得正确的 ip 参数 168\n6.2.4　步骤4：确认路由表的规则 169\n6.2.5　步骤5：主机名与 ip 查询的 dns 错误 170\n6.2.6　步骤6：linux 的 nat 服务器或 ip 路由器出问题 171\n6.2.7　步骤7：internet 的问题 171\n6.2.8　步骤8：服务器的问题 171\n6.3　参考数据与延伸阅读 172\n第二篇　主机的简易安全防护措施\n第7章　 网络安全与主机基本防护：限制端口、网络升级与selinux 174\n7.1　网络数据包连接进入主机的流程 175\n7.1.1　数据包进入主机的流程 175\n7.1.2　常见的攻击手法与相关保护 177\n7.1.3　主机能执行的保护操作：软件更新、减少网络服务、 启动 selinux 182\n7.2　网络自动升级软件 184\n7.2.1　如何进行软件升级 184\n7.2.2　centos 的 yum 软件更新、镜像站点使用的原理 186\n7.2.3　yum 的功能：安装软件组、全系统更新 187\n7.2.4　挑选特定的镜像站点：修改 yum 配置文件与清除 yum 缓存 193\n7.3　限制连接端口（port） 196\n7.3.1　什么是port 197\n7.3.2　端口的查看：netstat、nmap 198\n7.3.3　端口与服务的启动/关闭及开机时状态设定 201\n7.3.4　安全性考虑——关闭网络服务端口 205\n7.4　selinux 管理原则 206\n7.4.1　selinux 的工作模式 206\n7.4.2　selinux 的启动、关闭与查看 210\n7.4.3　selinux type 的修改 212\n7.4.4　selinux 策略内的规则布尔值修订 214\n7.4.5　selinux 日志文件记录所需的服务 217\n7.5　被攻击后的主机修复工作 221\n7.5.1　网管人员应具备的技能 221\n7.5.2　主机受攻击后恢复的工作流程 223\n7.6　重点回顾 225\n7.7　参考数据与延伸阅读 225\n第8章　 路由的概念与路由器设置 226\n8.1　路由 227\n8.1.1　路由表产生的类型 227\n8.1.2　一个网卡绑多个 ip：ip alias 的测试用途 229\n8.1.3　重复路由的问题 230\n8.2　路由器配置 231\n8.2.1　什么是路由器与 ip 路由器 231\n8.2.2　何时需要路由器 233\n8.2.3　静态路由的路由器 234\n8.3　动态路由器架设 239\n8.4　特殊状况——路由器两边界面是同一个ip网段：arp proxy 245\n8.5　重点回顾 249\n8.6　参考数据与延伸阅读 250\n第9章　 防火墙与 nat 服务器 251\n9.1　认识防火墙 252\n9.1.1　关于本章的一些提醒事项 252\n9.1.2　为何需要防火墙 253\n9.1.3　linux 系统上防火墙的主要类别 253\n9.1.4　防火墙的一般网络布线示意 255\n9.1.5　 防火墙的使用限制 258\n9.2　tcp wrappers 259\n9.2.1　哪些服务有支持 259\n9.2.2　/etc/hosts.{allowdeny} 的设置方式 261\n9.3　linux 的数据包过滤软件：iptables 262\n9.3.1　不同 linux 内核版本的防火墙软件 262\n9.3.2　数据包进入流程：规则顺序的重要性 263\n9.3.3　iptables 的表格（table）与链（chain） 264\n9.3.4　本机的 iptables 语法 267\n9.3.5　ipv4 的内核管理功能：/proc/sys/net/ipv4/* 278\n9.4　设置单机防火墙的一个实例 281\n9.4.1　规则草拟 281\n9.4.2　实际设置 282\n9.5　nat 服务器的设置 286\n9.5.1　什么是 nat？ snat？ dnat？ 287\n9.5.2　最简单的 nat 服务器：ip 分享功能 290\n9.5.3　iptables 的额外内核模块功能 292\n9.5.4　在防火墙后端的网络服务器上做dnat 设置 292\n9.6　重点回顾 293\n9.7　参考数据与延伸阅读 294\n第10章　 申请合法的主机名 295\n10.1　为何需要主机名 296\n10.1.1　主机名的由来 296\n10.1.2　重点在合法授权 297\n10.1.3　申请静态还是动态 dns 主机名 298\n10.2　注册一个合法的主机名 299\n10.2.1　静态 dns 主机名注册（以 hinet 为例） 299\n10.2.2　动态 dns 主机名注册（以 no-ip 为例） 301\n10.3　重点回顾 306\n10.4　参考数据与延伸阅读 307\n第三篇　 局域网内常见服务器的搭建\n第11章　 远程连接服务器 ssh / xdmcp / vnc /xrdp 310\n11.1　远程连接服务器 311\n11.1.1　什么是远程连接服务器 311\n11.1.2　有哪些可供登录的类型 312\n11.2　文字接口连接服务器： ssh 服务器 313\n11.2.1　连接加密技术简介 314\n11.2.2　启动 ssh 服务 317\n11.2.3　 ssh 客户端连接程序——linux 用户 317\n11.2.4　 ssh 客户端连接程序——windows 用户 324\n11.2.5　 sshd 服务器详细配置 328\n11.2.6　制作不用密码可立即登录的ssh用户 332\n11.2.7　简易安全设置 335\n11.3　最原始图形接口：xdmcp服务的启用 337\n11.3.1　 x window 的 server/client 架构与各组件 338\n11.3.2　设定 gdm 的 xdmcp 服务 341\n11.3.3　用户系统为 linux 的登录方式 343\n11.3.4　用户系统为 windows 的登录方式： xming 345\n11.4　华丽的图形接口：vnc 服务器 348\n11.4.1　默认的 vnc 服务器 348\n11.4.2　 vnc 的客户端连接软件 350\n11.4.3　 vnc 搭配本机的 xdmcp 画面 352\n11.4.4　开机就启动 vnc server 的方法 354\n11.4.5　同步的 vnc ：可以通过图示同步教学 354\n11.5　仿真的远程桌面系统：xrdp 服务器 355\n11.6　 ssh 服务器的高级应用 357\n11.6.1　在非标准端口启动 ssh（非 port 22） 357\n11.6.2　以 rsync 进行同步镜像备份 359\n11.6.3　通过ssh通道加密原本无加密的服务 362\n11.6.4　以ssh通道配合 x server 传递图形界面 363\n11.7　重点回顾 367\n11.8　参考数据与延伸阅读 368\n第12章　 网络参数管理者：dhcp服务器 369\n12.1　dhcp 的工作原理 370\n12.1.1　dhcp 服务器的用途 370\n12.1.2　dhcp 协议的工作方式 371\n12.1.3　何时需要架设 dhcp 服务器 375\n12.2　dhcp 服务器端的配置 376\n12.2.1　所需软件与文件结构 376\n12.2.2　主要配置文件 /etc/dhcp/dhcpd.conf 的语法 377\n12.2.3　一个局域网的 dhcp 服务器设置案例 379\n12.2.4　dhcp 服务器的启动与观察 380\n12.2.5　内部主机的 ip 对应 382\n12.3　dhcp 客户端的设置 382\n12.3.1　客户端是 linux 382\n12.3.2　客户端是 windows 384\n12.4　dhcp 服务器端的高级查看与使用 387\n12.4.1　检查租约文件 387\n12.4.2　让大量 pc 都具有固定 ip 的脚本 387\n12.4.3　使用 ether-wake 实现远程自动开机（remote boot） 388\n12.4.4　dhcp 与 dns 的关系 389\n12.5　重点回顾 390\n12.6　参考数据与延伸阅读 391\n第13章　 文件服务器之一：nfs 服务器 392\n13.1　nfs的由来与功能 393\n13.1.1　什么是 nfs（network file system） 393\n13.1.2　什么是 rpc（remote procedure call） 394\n13.1.3　nfs 启动的 rpc daemons 395\n13.1.4　nfs 的文件访问权限 396\n13.2　nfs server 端的配置 397\n13.2.1　所需要的软件 398\n13.2.2　nfs 的软件结构 398\n13.2.3　/etc/exports 配置文件的语法与参数 399\n13.2.4　启动 nfs 404\n13.2.5　nfs 的连接查看 406\n13.2.6　nfs 的安全性 408\n13.3　nfs 客户端的设置 410\n13.3.1　手动挂载 nfs 服务器共享的资源 410\n13.3.2　客户端可处理的挂载参数与开机挂载 411\n13.3.3　无法挂载的原因分析 414\n13.3.4　自动挂载 autofs 的使用 415\n13.4　案例演练 418\n13.5　重点回顾 420\n13.6　参考数据与延伸阅读 420\n第14章　 账号管理：nis 服务器 421\n14.1　nis 的由来与功能 422\n14.1.1　nis 的主要功能：管理账号信息 422\n14.1.2　nis 的工作流程：通过 rpc 服务 423\n14.2　nis server 端的设置 425\n14.2.1　所需要的软件 425\n14.2.2　nis 服务器相关的配置文件 425\n14.2.3　一个实际操作案例 426\n14.2.4　nis server 的设置与启动 426\n14.2.5　防火墙设置 431\n14.3　nis client 端的设置 431\n14.3.1　nis client 所需的软件与软件结构 432\n14.3.2　nis client 的设置与启动 432\n14.3.3　nis client 端的验证：yptest、ypwhich、ypcat 435\n14.3.4　用户参数修改：yppasswd、ypchfn、ypchsh 437\n14.4　nis 搭配 nfs 的设置在群集计算机上的应用 438\n14.5　重点回顾 441\n14.6　参考数据与延伸阅读 442\n第15章　 时间服务器：ntp 服务器 443\n15.1　关于时区与网络校时的通信协议 444\n15.1.1　什么是时区？全球有多少时区？gmt 在哪个时区？ 444\n15.1.2　什么是夏令时（daylight saving time） 446\n15.1.3　coordinated universal time（utc）与系统时间的误差 447\n15.1.4　ntp 通信协议 447\n15.1.5　ntp 服务器的层次概念 448\n15.2　ntp 服务器的安装与设置 449\n15.2.1　所需软件与软件结构 449\n15.2.2　主要配置文件 ntp.conf 的处理 451\n15.2.3　ntp 的启动与观察 453\n15.2.4　安全性设置 455\n15.3　客户端的时间更新方式 455\n15.3.1　linux 手动校时工作：date、hwclock 455\n15.3.2　linux 的网络校时 456\n15.3.3　windows 的网络校时 457\n15.4　重点回顾 459\n15.5　参考数据与延伸阅读 459\n第16章　 文件服务器之二：samba 服务器 460\n16.1　什么是 samba 461\n16.1.1　samba 的发展历史与名称的由来 461\n16.1.2　samba 常见的应用 462\n16.1.3　samba 使用的 netbios 通信协议 463\n16.1.4　samba 使用的 daemons 464\n16.1.5　连接模式的介绍（peer/peer、domain model） 465\n16.2　samba 服务器的基础设置 467\n16.2.1　samba所需软件及其软件结构 467\n16.2.2　基础的网上邻居共享流程与 smb.conf 的常用设置项目 469\n16.2.3　不需密码的共享（security = share，纯测试） 474\n16.2.4　需账号密码才可登录的共享（security = user） 479\n16.2.5　设置成为打印机服务器（cups 系统） 486\n16.2.6　安全性的议题与管理 496\n16.2.7　主机安装时的规划与中文扇区挂载 499\n16.3　samba客户端软件功能 500\n16.3.1　windows 系统的使用 501\n16.3.2　linux 系统的使用 505\n16.4　以 pdc 服务器提供账号管理 509\n16.4.1　让 samba 管理网络用户的一个实际案例 509\n16.4.2　pdc 服务器的搭建 511\n16.4.3　wimdows xp pro. 的客户端 515\n16.4.4　windows 7 的客户端 519\n16.4.5　pdc 问题的克服 520\n16.5　服务器简单维护与管理 521\n16.5.1　服务器相关问题克服 521\n16.5.2　让用户修改samba密码同时同步更新 /etc/shadow 密码 522\n16.5.3　利用 acl 配合单一用户时的管理 523\n16.6　重点回顾 524\n16.7　参考数据与延伸阅读 524\n第17章　 局域网控制者：proxy 服务器 526\n17.1　什么是代理服务器 527\n17.1.1　什么是代理服务器 527\n17.1.2　代理服务器的工作流程 528\n17.1.3　上层代理服务器 529\n17.1.4　代理服务器与 nat 服务器的差异 531\n17.1.5　搭建代理服务器的用途与优缺点 531\n17.2　proxy 服务器的配置基础 533\n17.2.1　proxy 所需的 squid 软件及其软件结构 533\n17.2.2　centos 默认的 squid 设置 534\n17.2.3　管理信任来源（如局域网）与目标（如恶意网站）：acl 与 http_access 的使用 539\n17.2.4　其他额外的功能项目 542\n17.2.5　安全性设置：防火墙、selinux 与黑名单文件 544\n17.3　客户端的使用与测试 545\n17.3.1　浏览器的设置：firefox & ie 545\n17.3.2　测试proxy 失败的画面 548\n17.4　服务器的其他应用设定 549\n17.4.1　上层 proxy 与获取数据分流的设定 549\n17.4.2　proxy 服务放在 nat 服务器上：透明代理（transparent proxy） 551\n17.4.3　proxy 的认证设置 553\n17.4.4　末端日志分析：sarg 555\n17.5　重点回顾 557\n17.6　参考数据与延伸阅读 558\n第18章　 网络驱动器设备：iscsi 服务器 559\n18.1　网络文件系统还是网络驱动器 560\n18.1.1　nas 与 san 560\n18.1.2　iscsi接口 561\n18.1.3　各组件相关性 562\n18.2　iscsi target 的设置 564\n18.2.1　所需软件与软件结构 564\n18.2.2　iscsi target 的实际设置 565\n18.3　iscsi initiator 的设置 570\n18.3.1　所需软件与软件结构 570\n18.3.2　iscsi initiator 的实际设置 570\n18.3.3　一个测试范例 574\n18.4　重点回顾 576\n18.5　参考数据与延伸阅读 577\n第四篇　 常见因特网服务器的搭建\n第19章　 主机名控制者：dns 服务器 580\n19.1　什么是 dns 581\n19.1.1　用网络主机名取得 ip 的历史渊源 581\n19.1.2　dns 的主机名对应 ip 的查询流程 584\n19.1.3　合法 dns 的关键：申请区域查询授权 590\n19.1.4　主机名交由 isp 代管还是自己设置 dns 服务器 591\n19.1.5　dns 数据库的记录：正解、反解、zone 的意义 592\n19.1.6　dns 数据库的类型：hint、master/slave 架构 594\n19.2　client 端的设置 596\n19.2.1　相关配置文件 596\n19.2.2　dns 的正、反解查询命令：host、nslookup、dig 597\n19.2.3　查询域管理者相关信息：whois 602\n19.3　 dns 服务器的软件、种类与caching only dns服务器设置 604\n19.3.1　搭建 dns 所需要的软件 604\n19.3.2　bind 的默认路径设置与 chroot 604\n19.3.3　单纯的 cache-only dns 服务器与 forwarding 功能 605\n19.4　dns 服务器的详细设置 611\n19.4.1　正解文件记录的数据（resource record，rr） 612\n19.4.2　反解文件记录的 rr 数据 616\n19.4.3　步骤一：dns 的环境规划 617\n19.4.4　步骤二：主配置文件 /etc/named.conf 的设置 618\n19.4.5　步骤三：最上层 . (root) 数据库文件的设置 620\n19.4.6　步骤四：正解数据库文件的设置 620\n19.4.7　步骤五：反解数据库文件的设置 622\n19.4.8　步骤六：dns 的启动、查看与防火墙 623\n19.4.9　步骤七：测试与数据库更新 624\n19.5　协同工作的 dns：slave dns 及子域授权设定 626\n19.5.1　master dns 权限的开放 626\n19.5.2　slave dns 的设置与数据库权限问题 628\n19.5.3　配置子域 dns 服务器：子域授权课题 630\n19.5.4　依不同接口给予不同的 dns 主机名：view 功能的应用 632\n19.6　dns 服务器的高级设定 635\n19.6.1　架设一个合法授权的 dns 服务器 635\n19.6.2　lame server 的问题 637\n19.6.3　利用 rndc 命令管理 dns 服务器 638\n19.6.4　搭建动态 dns 服务器：让你成为 isp 642\n19.7　重点回顾 645\n19.8　参考数据与延伸阅读 646\n第20章　 www 服务器 647\n20.1　www的简史、资源以及服务器软件 648\n20.1.1　www 的简史、html 与标准制订（w3c） 648\n20.1.2　www 服务器与浏览器所提供的资源定位（url） 651\n20.1.3　 www 服务器的类型：系统、平台、数据库与程序（lamp） 653\n20.1.4　https：加密的网页数据（ssl）及第三方证书机构 655\n20.1.5　客户端常见的浏览器 656\n20.2　www（lamp）服务器基本配置 657\n20.2.1　lamp 所需软件与其结构 657\n20.2.2　apache 的基本设定 660\n20.2.3　php 的默认参数修改 668\n20.2.4　启动 www 服务与测试 php 模块 670\n20.2.5　mysql 的基本设定 672\n20.2.6　防火墙设置与 selinux规则的放行 676\n20.2.7　开始网页设计及安装架站软件，如 phpbb3 677\n20.3　apache 服务器的高级设定 678\n20.3.1　启动用户的个人网站（权限是重点） 678\n20.3.2　启动某个目录的 cgi（perl）程序执行权限 680\n20.3.3　找不到网页时的显示信息通知 681\n20.3.4　浏览权限的设定操作（order、limit） 683\n20.3.5　服务器状态说明网页 686\n20.3.6　.htaccess 与认证网页设定 687\n20.3.7　虚拟主机的设定（重要！） 691\n20.4　日志文件分析以及 php 强化模块 694\n20.4.1　php 强化模块（eaccelerator）与 apache 简易性能测试 694\n20.4.2　syslog 与 logrotate 697\n20.4.3　日志文件分析软件：webalizer 698\n20.4.4　日志文件分析软件：awstats 700\n20.5　建立连接加密网站（https）及防整站下载脚本 702\n20.5.1　ssl 所需软件与证书文件及默认的 https 702\n20.5.2　拥有自制证书的https 704\n20.5.3　将加密首页与非加密首页分离 706\n20.5.4　防整站下载软件 707\n20.6　重点回顾 708\n20.7　参考数据与延伸阅读 709\n第21章　 文件服务器之三：ftp 服务器 710\n21.1　ftp 的数据传输原理 711\n21.1.1　ftp 功能简介 711\n21.1.2　ftp 的工作流程与使用到的端口 712\n21.1.3　客户端选择被动式连接模式 714\n21.1.4　ftp 的安全性问题与替代方案 716\n21.1.5　开放什么身份的用户登录 716\n21.2　vsftpd 服务器基础设置 718\n21.2.1　为何使用 vsftpd 718\n21.2.2　所需要的软件以及软件结构 719\n21.2.3　vsftpd.conf 配置值说明 721\n21.2.4　vsftpd 启动的模式 726\n21.2.5　centos 的 vsftpd 默认值 727\n21.2.6　针对实体账号的设定 729\n21.2.7　仅有匿名登录的相关设置 734\n21.2.8　防火墙设置 738\n21.2.9　常见问题与解决之道 739\n21.3　客户端的图形接口 ftp 连接软件 740\n21.3.1　filezilla 740\n21.3.2　通过浏览器取得 ftp 连接 744\n21.4　让 vsftpd 增加 ssl 的加密功能 744\n21.5　重点回顾 747\n21.6　参考数据与延伸阅读 748\n第22章　 邮件服务器：postfix 749\n22.1　邮件服务器的功能与工作原理 750\n22.1.1　电子邮件的功能与问题 750\n22.1.2　mail server 与 dns 之间的关系 751\n22.1.3　邮件传输所需要的组件（mta、mua、mda）以及相关协议 754\n22.1.4　用户收信时服务器端所提供的相关协议： mra 757\n22.1.5　relay 与认证机制的重要性 759\n22.1.6　电子邮件的数据内容 760\n22.2　mta 服务器：postfix基础设定 761\n22.2.1　postfix 的开发 761\n22.2.2　所需要的软件与软件结构 762\n22.2.3　一个邮件服务器的设定案例 764\n22.2.4　让 postfix 可监听 internet 来收发邮件 764\n22.2.5　邮件发送流程与收信、relay 等重要概念 767\n22.2.6　设定邮件主机权限与过滤机制：/etc/postfix/access 770\n22.2.7　设定邮件别名： /etc/aliases、~/.forward 770\n22.2.8　查看邮件队列信息：postqueue、mailq 773\n22.2.9　防火墙设置 775\n22.3　mra 服务器：dovecot 设定 775\n22.3.1　基础的 pop3/imap 设定 775\n22.3.2　加密的 pop3s/imaps 设定 776\n22.3.3　防火墙设置 777\n22.4　mua 软件：客户端的收发邮件软件 777\n22.4.1　linux mail 778\n22.4.2　linux mutt 781\n22.4.3　好用的跨平台（windows/linux x）软件：thunderbird 784\n22.5　邮件服务器的高级设定 788\n22.5.1　邮件过滤一：用 postgrey 进行非正规mail server 的垃圾邮件过滤 788\n22.5.2　邮件过滤二：关于黑名单的过滤机制 792\n22.5.3　邮件过滤三：基础的邮件过滤机制 793\n22.5.4　非信任来源的 relay：开放 smtp 身份认证 795\n22.5.5　非固定 ip 邮件服务器的福音：relayhost 799\n22.5.6　其他设置小技巧 800\n22.6　重点回顾 803\n22.7　参考数据与延伸阅读 804","pages":"804","images":{"small":"https://img3.doubanio.com/view/subject/s/public/s10328185.jpg","large":"https://img3.doubanio.com/view/subject/l/public/s10328185.jpg","medium":"https://img3.doubanio.com/view/subject/m/public/s10328185.jpg"},"alt":"https://book.douban.com/subject/10794788/","id":"10794788","publisher":"机械工业出版社","isbn10":"7111384997","isbn13":"9787111384991","title":"鸟哥的Linux私房菜","url":"https://api.douban.com/v2/book/10794788","alt_title":"","author_intro":"鸟哥 “台湾成功大学”环境工程系博士，在就读期间由于研究需要，接触到Linux操作系统，又因实验室交接传承的需要而搭建了“鸟哥的Linux私房菜”网站(俗称鸟站)，因个人喜好碎碎念(琐碎重复)的特质，因此，鸟站文章风格就此成形。\n曾任台湾多家知名Linux教育中心讲师，目前于台湾昆山科技大学资讯传播系教授Linux相关课程。\n专长是Linux操作系统、网站规划与维护、网络安全，兴趣是写作与阅读，研究方向是网络整合应用。","summary":"《鸟哥的Linux私房菜:服务器架设篇(第3版)》内容简介：您已有Linux基础，想要进一步学习服务器架设？还想了解如何维护与管理您的服务器？本书是您最佳的选择。\n目前有关Linux架站的书籍大多只教导读者如何架设服务器，很少针对服务器的维护与管理，以及发生问题时的应对策略加以说明，以至于一旦服务器遭受攻击，眼见的就是一场手忙脚乱。因此，作者先从系统基础以及网络基础讲起，再谈到网络攻击与防火墙防护主机后，才进入服务器的架设。\n《鸟哥的Linux私房菜:服务器架设篇(第3版)》共分为四篇：第一篇，服务器搭建前的进修专区，主要介绍架设服务器之前必须具备的基本知识，看完这一篇，不论您的Linux是以何种方式进行Internet连接，都将不成问题；第二篇，主机的简易安全防护措施，这一篇鸟哥将告诉您如何保护您的主机，以及如何养成良好的操作习惯，使您的主机能够百毒不侵，安然渡过一次次的考验；第三篇，局域网内常见服务器的搭建，介绍内部网络经常使用的远程连接服务（SSH、VNC、XRDP），网络参数设置服务（DHCP、NTP），网络磁盘服务（Samba、NFS、iSCSI），以及代理服务器等服务。其中SSH密钥系统，对于异地备份更是相当有帮助，您绝对不能错过；第四篇，常见因特网服务器的搭建，介绍DNS、WWW、FTP及Mail Server等常见的服务。","series":{"id":"1496","title":"鸟哥的Linux私房菜"},"price":"108.00元"},"9787115226266":{"rating":{"max":10,"numRaters":2638,"average":"9.1","min":0},"subtitle":"基础学习篇","author":["鸟哥"],"pubdate":"2010-6-28","tags":[{"count":2559,"name":"Linux","title":"Linux"},{"count":1020,"name":"操作系统","title":"操作系统"},{"count":879,"name":"计算机","title":"计算机"},{"count":656,"name":"鸟哥","title":"鸟哥"},{"count":561,"name":"Linux/Unix","title":"Linux/Unix"},{"count":316,"name":"IT","title":"IT"},{"count":282,"name":"linux","title":"linux"},{"count":256,"name":"技术","title":"技术"}],"origin_title":"","image":"https://img1.doubanio.com/view/subject/m/public/s4399937.jpg","binding":"平装","translator":[],"catalog":"第一部分　Linux的规则与安装\n第0章　计算机概论　1\n0.1　计算机：辅助人脑的好工具　2\n0.1.1　计算机硬件的五大单元　2\n0.1.2　CPU的种类　3\n0.1.3　接口设备　4\n0.1.4　运作流程　4\n0.1.5　计算机分类　5\n0.1.6　计算机上面常用的计算单位(大小、速度等)　6\n0.2　个人计算机架构与接口设备　7\n0.2.1　CPU　7\n0.2.2　内存　9\n0.2.3　显卡　11\n0.2.4　硬盘与存储设备　12\n0.2.5　PCI适配卡　14\n0.2.6　主板　15\n0.2.7　电源　16\n0.2.8　选购须知　16\n0.3　数据表示方式　17\n0.3.1　数字系统　17\n.0.3.2　文字编码系统　18\n0.4　软件程序运行　18\n0.4.1　机器程序与编译程序　18\n0.4.2　操作系统　19\n0.4.3　应用程序　22\n0.5　重点回顾　22\n0.6　本章习题　23\n0.7　参考数据与扩展阅读　24\n第1章　Linux是什么　25\n1.1　Linux是什么　26\n1.1.1　Linux是什么　26\n1.1.2　Linux之前UNIX的历史　27\n1.1.3　关于GNU项目　32\n1.2　Torvalds的Linux开发　34\n1.2.1　Minix　34\n1.2.2　对386硬件的多任务测试　35\n1.2.3　初次释出Linux 0.02　36\n1.2.4　Linux的开发：虚拟团队的产生　37\n1.2.5　Linux的内核版本　38\n1.2.6　Linux distributions　39\n1.3　Linux的特色　42\n1.3.1　Linux的特色　42\n1.3.2　Linux的优缺点　43\n1.3.3　关于授权　45\n1.4　重点回顾　46\n1.5　本章习题　46\n1.6　参考数据与扩展阅读　47\n第2章　Linux如何学习　48\n2.1　Linux当前的应用角色　49\n2.1.1　企业环境的利用　49\n2.1.2　个人环境的使用　50\n2.2　鸟哥的Linux苦难经验回忆录　51\n2.2.1　鸟哥的Linux学习之路　51\n2.2.2　学习心态的分别　53\n2.2.3　X Window的学习　54\n2.3　有心向Linux操作系统学习者学习态度　55\n2.3.1　从头学习Linux基础　56\n2.3.2　选择一本易读的工具书　57\n2.3.3　实践再实践　57\n2.3.4　发生问题怎么处理..　58\n2.4　鸟哥的建议(重点在Solution的学习)　59\n2.5　重点回顾　60\n2.6　本章习题　61\n2.7　参考数据与扩展阅读　61\n第3章　主机规划与磁盘分区　62\n3.1　Linux与硬件的搭配　63\n3.1.1　认识计算机的硬件配置　63\n3.1.2　选择与Linux搭配的主机配置　64\n3.1.3　各硬件设备在Linux中的文件名　66\n3.2　磁盘分区　67\n3.2.1　磁盘连接的方式与设备文件名的关系　67\n3.2.2　磁盘的组成复习　68\n3.2.3　磁盘分区表(partition table)　69\n3.2.4　开机流程与主引导分区(MBR)　72\n3.2.5　Linux安装模式下，磁盘分区的选择(极重要)　74\n3.3　安装Linux前的规划　76\n3.3.1　选择适当的distribution　76\n3.3.2　主机的服务规划与硬件的关系　77\n3.3.3　主机硬盘的主要规划　79\n3.3.4　鸟哥说：关于练习机的安装建议　80\n3.3.5　鸟哥的两个实际案例　80\n3.3.6　大硬盘配合旧主机造成的无法开机问题　81\n3.4　重点回顾　82\n3.5　本章习题　82\n3.6　参考数据与扩展阅读　82\n第4章　安装CentOS 5.x与多重引导小技巧　83\n4.1　本练习机的规划(尤其是分区参数)　84\n4.2　开始安装CentOS 5　85\n4.2.1　调整启动媒体(BIOS)　86\n4.2.2　选择安装结构与开机　87\n4.2.3　选择语系数据　89\n4.2.4　磁盘分区　90\n4.2.5　引导装载程序、网络、时区设置与root密码　95\n4.2.6　软件选择　98\n4.2.7　其他功能：RAM testing、安装笔记本电脑的内核参数(Option)　99\n4.3　安装后的首次设置　100\n4.4　多重引导安装流程与技巧　104\n4.4.1　新主机仅有一块硬盘　104\n4.4.2　旧主机有两块以上硬盘　105\n4.4.3　旧主机只有一块硬盘　105\n4.5　关于大硬盘导致无法开机的问题　106\n4.6　重点回顾　106\n4.7　本章习题　107\n4.8　参考数据与扩展阅读　107\n第5章　首次登录与在线求助man page　108\n5.1　首次登录系统　109\n5.1.1　首次登录CentOS 5.x图形界面　109\n5.1.2　GNOME的操作与注销　110\n5.1.3　KDE的操作与注销　113\n5.1.4　X Window与命令行模式的切换　115\n5.1.5　在终端界面登录linux　116\n5.2　在命令行模式下执行命令　117\n5.2.1　开始执行命令　117\n5.2.2　基础命令的操作　118\n5.2.3　重要的热键[Tab], [ctrl]-c, [ctrl]-d　121\n5.2.4　错误信息的查看　122\n5.3　Linux系统的在线求助man page与info page　122\n5.3.1　man page　123\n5.3.2　info page　127\n5.3.3　其他有用的文件(documents)　129\n5.4　超简单文本编辑器：nano　130\n5.5　正确的关机方法　131\n5.5.1　数据同步写入磁盘：sync　132\n5.5.2　惯用的关机命令：shutdown　132\n5.5.3　重启、关机：reboot, halt, poweroff　133\n5.5.4　切换执行等级：init　133\n5.6　开机过程的问题排解　134\n5.6.1　文件系统错误的问题　134\n5.6.2　忘记root密码　135\n5.7　重点回顾　136\n5.8　本章习题　136\n5.9　参考数据与扩展阅读　137\n第二部分　Linux文件、目录与磁盘格式\n第6章　Linux的文件权限与目录配置　138\n6.1　用户与用户组　139\n6.2　Linux文件权限概念　140\n6.2.1　Linux文件属性　141\n6.2.2　如何改变文件属性与权限　144\n6.2.3　目录与文件的权限意义　147\n6.2.4　Linux文件种类与扩展名　150\n6.3　Linux目录配置　152\n6.3.1　Linux目录配置标准：FHS　152\n6.3.2　目录树(directory tree)　156\n6.3.3　绝对路径与相对路径　158\n6.3.4　CentOS的查看　159\n6.4　重点回顾　159\n6.5　本章练习　160\n6.6　参考数据与扩展阅读　160\n第7章　Linux文件与目录管理　161\n7.1　目录与路径　162\n7.1.1　相对路径与绝对路径　162\n7.1.2　目录的相关操作　162\n7.1.3　关于执行文件路径的变量：$PATH　165\n7.2　文件与目录管理　167\n7.2.1　查看文件与目录：ls　167\n7.2.2　复制、删除与移动：cp, rm, mv　169\n7.2.3　取得路径的文件名与目录名称　173\n7.3　文件内容查阅　173\n7.3.1　直接查看文件内容　173\n7.3.2　可翻页查看　175\n7.3.3　数据选取　176\n7.3.4　非纯文本文件：od　177\n7.3.5　修改文件时间或创建新文件：touch　178\n7.4　文件与目录的默认权限与隐藏权限　180\n7.4.1　文件默认权限：umask　181\n7.4.2　文件隐藏属性：chattr, lsattr　183\n7.4.3　文件特殊权限：SUID, SGID, SBIT　184\n7.4.4　查看文件类型：file　187\n7.5　命令与文件的查询　187\n7.5.1　脚本文件名的查询　187\n7.5.2　文件名的查找　188\n7.6　权限与命令间的关系(极重要)　192\n7.7　重点回顾　193\n7.8　本章习题　194\n7.9　参考数据与扩展阅读　195\n第8章　Linux磁盘与文件系统管理　196\n8.1　认识EXT2文件系统　197\n8.1.1　硬盘组成与分区的复习　197\n8.1.2　文件系统特性　197\n8.1.3　Linux的EXT2文件系统(inode)　199\n8.1.4　与目录树的关系　204\n8.1.5　EXT2/EXT3文件的访问与日志文件系统的功能　206\n8.1.6　Linux文件系统的操作　208\n8.1.7　挂载点(mount point)的意义　208\n8.1.8　其他Linux支持的文件系统 与VFS　209\n8.2　文件系统的简单操作　210\n8.2.1　磁盘与目录的容量：df, du　210\n8.2.2　连接文件：ln　213\n8.3　磁盘的分区、格式化、检验与挂载　217\n8.3.1　磁盘分区：fdisk　217\n8.3.2　磁盘格式化　223\n8.3.3　磁盘检验：fsck, badblocks　225\n8.3.4　磁盘挂载与卸载　226\n8.3.5　磁盘参数修改　231\n8.4　设置开机挂载　234\n8.4.1　开机挂载/etc/fstab及/etc/mtab　234\n8.4.2　特殊设备loop挂载(镜像文件不刻录就挂载使用)　236\n8.5　内存交换空间(swap)的构建　238\n8.5.1　使用物理分区构建swap　238\n8.5.2　使用文件构建swap　240\n8.5.3　swap使用上的限制　241\n8.6　文件系统的特殊查看与操作　241\n8.6.1　boot sector与superblock的关系　241\n8.6.2　磁盘空间的浪费问题　243\n8.6.3　利用GNU的parted进行分区行为　243\n8.7　重点回顾　245\n8.8　本章习题　245\n8.9　参考数据与扩展阅读　246\n第9章　文件与文件系统的压缩与打包　248\n9.1　压缩文件的用途与技术　249\n9.2　Linux系统常见的压缩命令　250\n9.2.1　Compress　250\n9.2.2　gzip, zcat　252\n9.2.3　bzip2, bzcat　253\n9.3　打包命令：tar　253\n9.3.1　tar　254\n9.4　完整备份工具：dump　259\n9.4.1　dump　259\n9.4.2　restore　262\n9.5　光盘写入工具　265\n9.5.1　mkisofs：新建镜像文件　265\n9.5.2　Cdrecord：光盘刻录工具　267\n9.6　其他常见的压缩与备份工具　269\n9.6.1　dd　269\n9.6.2　Cpio　270\n9.7　重点回顾　272\n9.8　本章习题　272\n9.9　参考数据与扩展阅读　273\n第三部分　学习shell与shell script\n第10章　vim程序编辑器　274\n10.1　vi与vim　275\n10.1.1　为何要学vim　275\n10.2　vi的使用　276\n10.2.1　简单执行范例　277\n10.2.2　按键说明　278\n10.2.3　一个案例练习　281\n10.2.4　vim的保存文件、恢复与打开时的警告信息　282\n10.3　vim的功能　284\n10.3.1　块选择(Visual Block)　285\n10.3.2　多文件编辑　286\n10.3.3　多窗口功能　286\n10.3.4　vim环境设置与记录：～/.vimrc, ～/.viminfo　287\n10.3.5　vim常用命令示意图　289\n10.4　其他vim使用注意事项　289\n10.4.1　中文编码的问题　289\n10.4.2　DOS与Linux的断行字符　290\n10.4.3　语系编码转换　290\n10.5　重点回顾　291\n10.6　本章练习　291\n10.7　参考数据与扩展阅读　292\n第11章　认识与学习bash　293\n11.1　认识bash这个shell　294\n11.1.1　硬件、内核与shell　294\n11.1.2　为何要学命令行界面的shell　295\n11.1.3　系统的合法shell与/etc/shells功能　295\n11.1.4　bash shell的功能　296\n11.1.5　bash shell的内置命令：type　298\n11.1.6　命令的执行　298\n11.2　shell的变量功能　299\n11.2.1　什么是变量　299\n11.2.2　变量的显示与设置：echo, unset　300\n11.2.3　环境变量的功能　304\n11.2.4　影响显示结果的语系变量(locale)　308\n11.2.5　变量的有效范围　309\n11.2.6　变量键盘读取、数组与声明：read，array，declare　310\n11.2.7　与文件系统及程序的限制关系：ulimit　312\n11.2.8　变量内容的删除、替代与替换　313\n11.3　命令别名与历史命令　317\n11.3.1　命令别名设置：alias，unalias　317\n11.3.2　历史命令：history　318\n11.4　Bash Shell的操作环境　320\n11.4.1　路径与命令查找顺序　320\n11.4.2　bash的登录与欢迎信息：/etc/issue, /etc/motd　320\n11.4.3　bash 的环境配置文件　321\n11.4.4　终端机的环境设置：stty, set　325\n11.4.5　通配符与特殊符号　327\n11.5　数据流重定向　328\n11.5.1　什么是数据流重定向　329\n11.5.2　命令执行的判断依据：","pages":"778","images":{"small":"https://img1.doubanio.com/view/subject/s/public/s4399937.jpg","large":"https://img1.doubanio.com/view/subject/l/public/s4399937.jpg","medium":"https://img1.doubanio.com/view/subject/m/public/s4399937.jpg"},"alt":"https://book.douban.com/subject/4889838/","id":"4889838","publisher":"人民邮电出版社","isbn10":"7115226261","isbn13":"9787115226266","title":"鸟哥的Linux私房菜","url":"https://api.douban.com/v2/book/4889838","alt_title":"","author_intro":"鸟哥 台湾成功大学环境工程系博士，就学期间由于研究需要接触到Linux操作系统，又因实验室交接需求而建立“鸟哥的Linux私房菜”网站。因个人喜好“絮叨”，网站文章风格就此成形。\n曾任台湾多家知名Linux教育中心讲师，目前于昆山科技大学资讯传播系教授Linux相关课程。专长是Linux 操作系统、网站规划与维护、网络安全，兴趣是写作与阅读，研究方向是网络应用整合。","summary":"本书是最具知名度的Linux入门书《鸟哥的Linux私房菜基础学习篇》的最新版，全面而详细地介绍了Linux操作系统。全书分为5个部分：第一部分着重说明Linux的起源及功能，如何规划和安装Linux主机；第二部分介绍Linux的文件系统、文件、目录与磁盘的管理；第三部分介绍文字模式接口 shell和管理系统的好帮手shell脚本，另外还介绍了文字编辑器vi和vim的使用方法；第四部分介绍了对于系统安全非常重要的Linux账号的管理，以及主机系统与程序的管理，如查看进程、任务分配和作业管理；第五部分介绍了系统管理员(root)的管理事项，如了解系统运行状况、系统服务，针对登录文件进行解析，对系统进行备份以及核心的管理等。\n本书内容丰富全面，基本概念的讲解非常细致，深入浅出。各种功能和命令的介绍，都配以大量的实例操作和详尽的解析。本书是初学者学习Linux不可多得的一本入门好书。","series":{"id":"1496","title":"鸟哥的Linux私房菜"},"price":"88.00元"},"9787302392644":{"rating":{"max":10,"numRaters":205,"average":"8.3","min":0},"subtitle":"软件工程师经典读本 不可错过的名著","author":["(美) 布鲁克斯(Brooks, F. P.)  著"],"pubdate":"2015-4-1","tags":[{"count":136,"name":"软件工程","title":"软件工程"},{"count":87,"name":"计算机","title":"计算机"},{"count":85,"name":"项目管理","title":"项目管理"},{"count":37,"name":"产品经理","title":"产品经理"},{"count":35,"name":"经典","title":"经典"},{"count":32,"name":"管理","title":"管理"},{"count":31,"name":"软件开发","title":"软件开发"},{"count":29,"name":"人月神话","title":"人月神话"}],"origin_title":"(美) 布鲁克斯(Brooks, F. P.)  著","image":"https://img3.doubanio.com/view/subject/m/public/s28040623.jpg","binding":"平装","translator":["UML China翻译组，汪颖 译"],"catalog":"第1章  焦油坑\t1\n编程系统产品\t4\n职业的乐趣\t6\n职业的苦恼\t8\n第2章  人月神话\t11\n乐观主义\t14\n人月\t16\n系统测试\t19\n空泛的估算\t21\n重复产生的进度灾难\t22\n第3章  外科手术队伍\t27\n问题\t30\nMills的建议\t32\n如何运作\t35\n团队的扩建\t36\n第4章  贵族专制、民主政治和系统设计\t39\n概念的完整性\t42\n获得概念的完整性\t43\n贵族专制统治和民主政治\t44\n在等待时，实现人员应该做什么\t47\n第5章  画蛇添足\t51\n结构师的交互准则和机制\t54\n自律—— 开发第二个系统所带来的后果\t55\n第6章  贯彻执行\t59\n文档化的规格说明—— 手册\t62\n形式化定义\t63\n直接整合\t66\n会议和大会\t66\n多重实现\t68\n电话日志\t68\n产品测试\t69\n第7章  为什么巴比伦塔会失败\t71\n巴比伦塔的管理教训\t75\n大型编程项目中的交流\t76\n项目工作手册\t76\n大型编程项目的组织架构\t80\n第8章  胸有成竹\t85\nPortman的数据\t89\nAron的数据\t90\nHarr的数据\t90\nOS/360的数据\t92\nCorbató的数据\t93\n第9章  削足适履\t95\n作为成本的程序空间\t98\n规模控制\t99\n空间技能\t100\n数据的表现形式是编程的根本\t102\n第10章  提纲挈领\t105\n计算机产品的文档\t108\n大学科系的文档\t110\n软件项目的文档\t110\n为什么要有正式的文档\t111\n第11章  未雨绸缪\t113\n试验性工厂和增大规模\t116\n唯一不变的就是变化本身\t117\n为变更设计系统\t117\n为变更计划组织架构\t118\n前进两步，后退一步\t120\n前进一步，后退一步\t122\n第12章  干将莫邪\t125\n目标机器\t129\n辅助机器和数据服务\t131\n高级语言和交互式编程\t134\n第13章  整体部分\t139\n剔除bug的设计\t142\n构件单元调试\t144\n系统集成调试\t147\n第14章  祸起萧墙\t153\n里程碑还是沉重的负担\t156\n“其他的部分反正会落后”\t158\n地毯的下面\t159\n第15章  另外一面\t165\n需要什么样的文档\t169\n流程图\t171\n自文档化的程序\t175\n第16章  没有银弹\t181\n摘要\t184\n介绍\t184\n根本困难\t185\n以往解决次要困难的一些突破\t190\n银弹的希望\t192\n针对概念上根本问题的颇具前途的方法\t200\n第17章  再论“没有银弹”\t209\n人狼和其他恐怖传说\t212\n存在着银弹—— 就在这里\t212\n含糊的表达将会导致误解\t213\nHarel的分析\t216\nJones的观点—— 质量带来生产率\t221\n那么，生产率的情形如何\t222\n面向对象编程—— 这颗铜质子弹可以吗\t223\n重用的情况怎样\t225\n学习大量的词汇—— 对软件重用的一个可预见但还没有被预言的问题\t228\n子弹的本质—— 形势没有发生改变\t229\n第18章  《人月神话》的观点：是与非\t231\n第1章  焦油坑\t234\n第2章  人月神话\t235\n第3章  外科手术队伍\t236\n第4章  贵族专制、民主政治和系统设计\t237\n第5章  画蛇添足\t238\n第6章  贯彻执行\t239\n第7章  为什么巴比伦塔会失败\t240\n第8章  胸有成竹\t242\n第9章  削足适履\t243\n第10章  提纲挈领\t245\n第11章  未雨绸缪\t246\n第12章  干将莫邪\t249\n第13章  整体部分\t251\n第14章  祸起萧墙\t253\n第15章  另外一面\t255\n第1版结束语\t256\n第19章  20年后的《人月神话》\t257\n为什么要出版20周年纪念版本\t260\n核心观点—— 概念完整性和结构师\t261\n开发第二个系统所引起的后果—— 盲目的功能和频率猜测\t263\n图形界面的成功\t265\n没有构建舍弃原型—— 瀑布模型是错误的\t269\n增量开发模型更佳—— 渐进地精化\t272\n关于信息隐藏，Parnas是正确的，我是错误的\t276\n人月到底有多少神话色彩？Boehm的模型和数据\t278\n人就是一切(或者说，几乎是一切)\t280\n放弃权力的力量\t281\n最令人惊讶的新事物是什么？数百万的计算机\t283\n全新的软件产业—— 塑料薄膜包装的成品软件\t286\n买来开发—— 使用塑料包装的成品软件包作为构件\t288\n软件工程的状态和未来\t290\n结束语：令人向往、激动人心和充满乐趣的50年\t293\n注解与参考文献\t295\n附录：人月落地实战体验\t315\n一、名家谈人月\t317\n1. 年金\t317\n2. 《人月神话》与实践\t318\n3. Frank Chance评人月\t327\n4. 软件尚方宝剑(Silver Bullet)何在\t330\n二、名著评人月\t339\n三、读者感言\t351\n1. 读书有感——人月神话\t351\n2. 我这几天很烦(产品概念完整性)\t353\n3. 关于我们的思考——“项目开发”及读《人月神话》有感\t355\n4. 我的“人月神话”\t358\n5. 《人月神话》软玉生香\t360","pages":"392","images":{"small":"https://img3.doubanio.com/view/subject/s/public/s28040623.jpg","large":"https://img3.doubanio.com/view/subject/l/public/s28040623.jpg","medium":"https://img3.doubanio.com/view/subject/m/public/s28040623.jpg"},"alt":"https://book.douban.com/subject/26358448/","id":"26358448","publisher":"清华大学出版社","isbn10":"7302392641","isbn13":"9787302392644","title":"人月神话(40周年中文纪念版)","url":"https://api.douban.com/v2/book/26358448","alt_title":"(美) 布鲁克斯(Brooks, F. P.)  著","author_intro":"小弗雷德里克•布鲁克斯曾获得美国计算机领域最具声望的图灵奖(A. M. Turing Award)。美国计算机协会(ACM)称赞他“对计算机体系结构、操作系统和软件工程做出了里程碑式的贡献”。\n布鲁克斯博士1956年开始任职于IBM公司，早期担任Stretch 和Harvest计算机的体系建构师。他被认为是“IBM 360系统之父”，曾担任360系统的项目经理。凭借在此项目中的杰出贡献，他与Bob Evans和Erich Bloch在1985年获得了美国国家技术奖(National Medal of Technology)。\n布鲁克斯博士创立了北卡罗来纳大学的计算机科学系，并于1965-1985年担任系主任。他还曾任职于美国国家科技局和国防科学技术委员会。目前其仍活跃于从事虚拟环境和科学可视化等方面的研究工作，2010年获得虚拟现实事业奖(IEEE Virtual Reality Career Award)。","summary":"在软件领域，很少能有像《人月神话》一样具有深远影响力和畅销不衰的著作。Brooks博士为人们管理复杂项目提供了最具洞察力的见解，既有很多发人深省的观点，又有大量软件工程的实践。本书内容来自Brooks博士在IBM公司SYSTEM／360家族和OS／360中的项目管理经验，该项目堪称软件开发项目管理的典范。该书英文原版一经面世，即引起业内人士的强烈反响，后又译为德、法、日、俄、中、韩等多种文字，全球销售数百万册。确立了其在行业内的经典地位。\n在本书第一次出版40年后的今天，我们重新整理了Brooks博士的经典内容，并将国内软件开发领域先行者们对《人月神话》中的实践及系统理论的使用经验和心得集结成册免费赠与大家共享，更使本书成为国内从业者的必读经典之一。\n本书读者包括：软件开发人员、软件项目经理、系统分析师等IT从业者。","price":"68.00元"},"9787115221704":{"rating":{"max":10,"numRaters":1530,"average":"9.1","min":0},"subtitle":"改善既有代码的设计","author":["Martin Fowler"],"pubdate":"2010","tags":[{"count":1354,"name":"重构","title":"重构"},{"count":837,"name":"软件工程","title":"软件工程"},{"count":709,"name":"代码优化","title":"代码优化"},{"count":654,"name":"编程","title":"编程"},{"count":464,"name":"计算机","title":"计算机"},{"count":444,"name":"软件开发","title":"软件开发"},{"count":258,"name":"经典","title":"经典"},{"count":238,"name":"架构","title":"架构"}],"origin_title":"Refactoring: Improving the Design of Existing Code","image":"https://img3.doubanio.com/view/subject/m/public/s4157180.jpg","binding":"平装","translator":["熊节"],"catalog":"第1章 重构，第一个案例1\n1.1 起点1\n1.2 重构的第一步7\n1.3 分解并重组statement()8\n1.4 运用多态取代与价格相关的条件逻辑34\n1.5 结语52\n第2章 重构原则53\n2.1 何谓重构53\n2.2 为何重构55\n2.3 何时重构57\n2.4 怎么对经理说60\n2.5 重构的难题62\n2.6 重构与设计66\n2.7 重构与性能69\n2.8 重构起源何处71\n第3章 代码的坏味道75\n3.1 DuplicatedCode（重复代码）76\n3.2 LongMethod（过长函数）76\n3.3 LargeClass（过大的类）78\n3.4 LongParameterList（过长参数列）78\n3.5 DivergentChange（发散式变化）79\n3.6 ShotgunSurgery（霰弹式修改）80\n3.7 FeatureEnvy（依恋情结）80\n3.8 DataClumps（数据泥团）81\n3.9 PrimitiveObsession（基本类型偏执）81\n3.10 SwitchStatements（switch惊悚现身）82\n3.11 ParallelInheritanceHierarchies（平行继承体系）83\n3.12 LazyClass（冗赘类）83\n3.13 SpeculativeGenerality（夸夸其谈未来性）83\n3.14 TemporaryField（令人迷惑的暂时字段）84\n3.15 MessageChains（过度耦合的消息链）84\n3.16 MiddleMan（中间人）85\n3.17 InappropriateIntimacy（狎昵关系）85\n3.18 AlternativeClasseswithDifferentInterfaces（异曲同工的类）85\n3.19 IncompleteLibraryClass（不完美的库类）86\n3.20 DataClass（纯稚的数据类）86\n3.21 RefusedBequest（被拒绝的遗赠）87\n3.22 Comments（过多的注释）87\n第4章 构筑测试体系89\n4.1 自测试代码的价值89\n4.2 JUnit测试框架91\n4.3 添加更多测试97\n第5章 重构列表103\n5.1 重构的记录格式103\n5.2 寻找引用点105\n5.3 这些重构手法有多成熟106\n第6章 重新组织函数109\n6.1 ExtractMethod（提炼函数）110\n6.2 InlineMethod（内联函数）117\n6.3 InlineTemp（内联临时变量）119\n6.4 ReplaceTempwithQuery（以查询取代临时变量）120\n6.5 IntroduceExplainingVariable（引入解释性变量）124\n6.6 SplitTemporaryVariable（分解临时变量）128\n6.7 RemoveAssignmentstoParameters（移除对参数的赋值）131\n6.8 ReplaceMethodwithMethodObject（以函数对象取代函数）135\n6.9 SubstituteAlgorithm（替换算法）139\n第7章 在对象之间搬移特性141\n7.1 MoveMethod（搬移函数）142\n7.2 MoveField（搬移字段）146\n7.3 ExtractClass（提炼类）149\n7.4 InlineClass（将类内联化）154\n7.5 HideDelegate（隐藏“委托关系”）157\n7.6 RemoveMiddleMan（移除中间人）160\n7.7 IntroduceForeignMethod（引入外加函数）162\n7.8 IntroduceLocalExtension（引入本地扩展）164\n第8章 重新组织数据169\n8.1 SelfEncapsulateField（自封装字段）171\n8.2 ReplaceDataValuewithObject（以对象取代数据值）175\n8.3 ChangeValuetoReference（将值对象改为引用对象）179\n8.4 ChangeReferencetoValue（将引用对象改为值对象）183\n8.5 ReplaceArraywithObject（以对象取代数组）186\n8.6 DuplicateObservedData（复制“被监视数据”）189\n8.7 ChangeUnidirectionalAssociationtoBidirectional（将单向关联改为双向关联）197\n8.8 ChangeBidirectionalAssociationtoUnidirectional（将双向关联改为单向关联）200\n8.9 ReplaceMagicNumberwithSymbolicConstant（以字面常量取代魔法数）204\n8.10 EncapsulateField（封装字段）206\n8.11 EncapsulateCollection（封装集合）208\n8.12 ReplaceRecordwithDataClass（以数据类取代记录）217\n8.13 ReplaceTypeCodewithClass（以类取代类型码）218\n8.14 ReplaceTypeCodewithSubclasses（以子类取代类型码）223\n8.15 ReplaceTypeCodewithState/Strategy（以State/Strategy取代类型码）227\n8.16 ReplaceSubclasswithFields（以字段取代子类）232\n第9章 简化条件表达式237\n9.1 DecomposeConditional（分解条件表达式）238\n9.2 ConsolidateConditionalExpression（合并条件表达式）240\n9.3 ConsolidateDuplicateConditionalFragments（合并重复的条件片段）243\n9.4 RemoveControlFlag（移除控制标记）245\n9.5 ReplaceNestedConditionalwithGuardClauses（以卫语句取代嵌套条件表达式）250\n9.6 ReplaceConditionalwithPolymorphism（以多态取代条件表达式）255\n9.7 IntroduceNullObject（引入Null对象）260\n9.8 IntroduceAssertion（引入断言）267\n第10章 简化函数调用271\n10.1 RenameMethod（函数改名）273\n10.2 AddParameter（添加参数）275\n10.3 RemoveParameter（移除参数）277\n10.4 SeparateQueryfromModifier（将查询函数和修改函数分离）279\n10.5 ParameterizeMethod（令函数携带参数）283\n10.6 ReplaceParameterwithExplicitMethods（以明确函数取代参数）285\n10.7 PreserveWholeObject（保持对象完整）288\n10.8 ReplaceParameterwithMethods（以函数取代参数）292\n10.9 IntroduceParameterObject（引入参数对象）295\n10.10 RemoveSettingMethod（移除设值函数）300\n10.11 HideMethod（隐藏函数）303\n10.12 ReplaceConstructorwithFactoryMethod（以工厂函数取代构造函数）304\n10.13 EncapsulateDowncast（封装向下转型）308\n10.14 ReplaceErrorCodewithException（以异常取代错误码）310\n10.15 ReplaceExceptionwithTest（以测试取代异常）315\n第11章 处理概括关系319\n11.1 PullUpField（字段上移）320\n11.2 PullUpMethod（函数上移）322\n11.3 PullUpConstructorBody（构造函数本体上移）325\n11.4 PushDownMethod（函数下移）328\n11.5 PushDownField（字段下移）329\n11.6 ExtractSubclass（提炼子类）330\n……\n第12章 大型重构359\n第13章 重构，复用与现实379\n第14章 重构工具401\n第15章 总结409\n参考书目413\n要点列表417\n索引419","pages":"428","images":{"small":"https://img3.doubanio.com/view/subject/s/public/s4157180.jpg","large":"https://img3.doubanio.com/view/subject/l/public/s4157180.jpg","medium":"https://img3.doubanio.com/view/subject/m/public/s4157180.jpg"},"alt":"https://book.douban.com/subject/4262627/","id":"4262627","publisher":"人民邮电出版社","isbn10":"7115221707","isbn13":"9787115221704","title":"重构","url":"https://api.douban.com/v2/book/4262627","alt_title":"Refactoring: Improving the Design of Existing Code","author_intro":"Martin Fowler  世界软件开发大师，在面向对象分析设计、UML、模式、XP和重构等领域都有卓越贡献，现为著名软件开发咨询公司ThoughtWorks的首席科学家。他的多部著作《分析模式》、《UML精粹》和《企业应用架构模式》等都已经成为脍炙人口的经典。\n其他参编者——\nKent Beck 软件开发方法学的泰斗，极限编程的创始人。他是Three Rivers Institute公司总裁，也是Agitar Software的成员。\nJohn Brant和Don Roberts The Refactory公司的创始人，Refactoring Browser （http://st-www.cs.illinois.edu/users/brant/Refactory/）的开发者，多年来一直从事研究重构的实践与理论。\nWilliam Opdyke  目前在朗讯贝尔实验室工作，他写的关于面向对象框架的博士论文是重构方面的第一篇著名文章。","summary":"重构，一言以蔽之，就是在不改变外部行为的前提下，有条不紊地改善代码。多年前，正是本书原版的出版，使重构终于从编程高手们的小圈子走出，成为众多普通程序员日常开发工作中不可或缺的一部分。本书也因此成为与《设计模式》齐名的经典著作，被译为中、德、俄、日等众多语言，在世界范围内畅销不衰。\n本书凝聚了软件开发社区专家多年摸索而获得的宝贵经验，拥有不因时光流逝而磨灭的价值。今天，无论是重构本身，业界对重构的理解，还是开发工具对重构的支持力度，都与本书最初出版时不可同日而语，但书中所蕴涵的意味和精华，依然值得反复咀嚼，而且往往能够常读常新。","series":{"id":"660","title":"图灵程序设计丛书"},"price":"69.00元"},"9787115238870":{"rating":{"max":10,"numRaters":147,"average":"9.1","min":0},"subtitle":"软件核心复杂性应对之道","author":["埃文斯"],"pubdate":"2010-11","tags":[{"count":255,"name":"领域驱动设计","title":"领域驱动设计"},{"count":145,"name":"软件工程","title":"软件工程"},{"count":136,"name":"软件架构","title":"软件架构"},{"count":88,"name":"架构","title":"架构"},{"count":84,"name":"程序设计","title":"程序设计"},{"count":83,"name":"软件开发","title":"软件开发"},{"count":64,"name":"领域驱动","title":"领域驱动"},{"count":63,"name":"计算机","title":"计算机"}],"origin_title":"","image":"https://img3.doubanio.com/view/subject/m/public/s27608362.jpg","binding":"平装","translator":["赵俐","盛海艳","刘霞"],"catalog":"第一部分 让领域模型发挥作用\n第1章 消化知识\n1.1 有效建模的要素\n1.2 知识消化\n1.3 持续学习\n1.4 知识丰富的设计\n1.5 深层模型\n第2章 语言的交流和使用\n2.1 模式：UBIQUITOUS LANGUAGE\n2.2 “大声地”建模\n2.3 一个团队，一种语言\n2.4 文档和图\n2.4.1 书面设计文档\n2.4.2 完全依赖可执行代码的情况\n2.5 解释性模型\n第3章 绑定模型和实现\n3.1 模式：MODEL-DRIVEN DESIGN\n3.2 建模范式和工具支持\n3.3 揭示主旨：为什么模型对用户至关重要\n3.4 模式：HANDS-ON MODELER\n第二部分 模型驱动设计的构造块\n第4章 分离领域\n4.1 模式：LAYERED ARCHITECTURE\n4.1.1 将各层关联起来\n4.1.2 架构框架\n4.2 模型属于领域层\n4.3 模式：THE SMART UI“ANTI-PATTERN”\n4.4 其他分离方式\n第5章 软件中所表示的模型\n5.1 关联\n5.2 模式：ENTITY（又称为REFERENCE OBJECT）\n5.2.1 ENTITY建模\n5.2.2 设计标识操作\n5.3 模式：VALUE OBJECT\n5.3.1 设计VALUE OBJECT\n5.3.2 设计包含VALUE OBJECT的关联\n5.4 模式：SERVICE\n5.4.1 SERVICE与孤立的领域层\n5.4.2 粒度\n5.4.3 对SERVICE的访问\n5.5 模式：ＭODULE（也称为PACKAGE）\n5.5.1 敏捷的MODULE\n5.5.2 基础设施驱动的打包存在的隐患\n5.6 建模范式\n5.6.1 对象范式流行的原因\n5.6.2 对象世界中的非对象\n5.6.3 在混合范式中坚持使用MODEL-DRIVEN DESIGN\n第6章 领域对象的生命周期\n6.1 模式：AGGREGATE\n6.2 模式：FACTORY\n6.2.1 选择FACTORY及其应用位置\n6.2.2 有些情况下只需使用构造函数\n6.2.3 接口的设计\n6.2.4 固定规则的逻辑应放置在哪里\n6.2.5 ENTITY FACTORY与VALUE OBJECT FACTORY\n6.2.6 重建已存储的对象\n6.3 模式：REPOSITORY\n6.3.1 REPOSITORY的查询\n6.3.2 客户代码可以忽略REPOSITORY的实现，但开发人员不能忽略\n6.3.3 REPOSITORY的实现\n6.3.4 在框架内工作\n6.3.5 REPOSITORY与FACTORY的关系\n6.4 为关系数据库设计对象\n第7章 使用语言：一个扩展的示例\n7.1 货物运输系统简介\n7.2 隔离领域：应用程序的引入\n7.3 将ENTITY和VALUE OBJECT区别开\n7.4 设计运输系统中的关联\n7.5 AGGREGATE边界\n7.6 选择REPOSITORY\n7.7 场景走查\n7.7.1 应用程序特性举例：更改Cargo的目的地\n7.7.2 应用程序特性举例：重复业务\n7.8 对象的创建\n7.8.1 Cargo的FACTORY和构造函数\n7.8.2 添加一个Handling Event\n7.9 停下来重构：Cargo AGGREGATE的另一种设计\n7.10 运输模型中的ＭODULE\n7.11 引入新特性：配额检查\n7.11.1 连接两个系统\n7.11.2 进一步完善模型：划分业务\n7.11.3 性能优化\n7.12 小结\n第三部分 通过重构来加深理解\n第8章 突破\n8.1 一个突破的故事\n8.1.1 华而不实的模型\n8.1.2 突破\n8.1.3 更深层模型\n8.1.4 冷静决策\n8.1.5 成果\n8.2 机遇\n8.3 关注根本\n8.4 后记：越来越多的新理解\n第9章 将隐式概念转变为显式概念\n9.1 概念挖掘\n9.1.1 倾听语言\n9.1.2 检查不足之处\n9.1.3 思考矛盾之处\n9.1.4 查阅书籍\n9.1.5 尝试，再尝试\n9.2 如何为那些不太明显的概念建模\n9.2.1 显式的约束\n9.2.2 作为领域对象的过程\n9.2.3 模式：SPECIFICATION\n9.2.4 SPECIFICATION的应用和实现\n第10章 柔 性 设 计\n10.1 模式：INTENTION-REVEALING INTERFACES\n10.2 模式：SIDE-EFFECT-FREE FUNCTION\n10.3 模式：ASSERTION\n10.4 模式：CONCEPTUAL CONTOUR\n10.5 模式：STANDALONE CLASS\n10.6 模式：CLOSURE OF OPERATION\n10.7 声明式设计\n10.8 声明式设计风格\n10.9 切入问题的角度\n10.9.1 分割子领域\n10.9.2 尽可能利用已有的形式\n第11章 分析模式的应用\n第12章 将设计模式应用于模型\n12.1 模式：STRATEGY（也称为POLICY）\n12.2 模式：COMPOSITE\n12.3 为什么没有介绍FLYWEIGHT\n第13章 通过重构得到更深层的理解\n13.1 开始重构\n13.2 探索团队\n13.3 借鉴先前的经验\n13.4 针对开发人员的设计\n13.5 重构的时机\n13.6 危机就是机遇\n第四部分 战略设计\n第14章 保持模型的完整性\n14.1 模式：BOUNDED CONTEXT\n14.2 模式：CONTINUOUS INTEGRATION\n14.3 模式：CONTEXT MAP\n14.3.1 测试CONTEXT的边界\n14.3.2 CONTEXT MAP的组织和文档化\n14.4 BOUNDED CONTEXT之间的关系\n14.5 模式：SHARED KERNEL\n14.6 模式：CUSTOMER/SUPPLIERDEVELOPMENT TEAM\n14.7 模式：CONFORMIST\n14.8 模式：ANTICORRUPTION LAYER\n14.8.1 设计ANTICORRUPTION LAYER的接口\n14.8.2 实现ANTICORRUPTION LAYER\n14.8.3 一个关于防御的故事\n14.9 模式：SEPARATE WAY\n14.10 模式：OPEN HOST SERVICE\n14.11 模式：PUBLISHED LANGUAGE\n14.12 “大象”的统一\n14.13 选择你的模型上下文策略\n14.13.1 制定团队决策或更高层的决策\n14.13.2 在上下文中工作\n14.13.3 转换边界\n14.13.4 接受那些我们无法更改的事物：描述外部系统\n14.13.5 与外部系统的关系\n14.13.6 正在设计的系统\n14.13.7 满足不同模型的特殊需要\n14.13.8 部署\n14.13.9 权衡\n14.13.10 当项目正在进行时\n14.14 转换\n14.14.1 合并CONTEXT：SEPARATE WAY →SHARED KERNEL\n14.14.2 合并CONTEXT：SHARED KERNEL→CONTINUOUS INTEGRATION\n14.14.3 逐步淘汰遗留系统\n14.14.4 OPEN HOST SERVICE→PUBLISHED LANGUAGE\n第15章 精炼\n15.1 模式：CORE DOMAIN\n15.1.1 选择核心\n15.1.2 工作的分配\n15.2 精炼的逐步提升\n15.3 模式：GENERIC SUBDOMAIN\n15.3.1 通用不等于可以重用\n15.3.2 项目风险管理\n15.4 模式：DOMAIN VISION STATEMENT\n15.5 模式：HIGHLIGHTED CORE\n15.5.1 精炼文档\n15.5.2 标明CORE\n15.5.3 把精炼文档作为过程工具\n15.6 模式：COHESIVE MECHANISM\n15.6.1 GENERIC SUBDOMAIN与COHE-SIVE MECHANISM的比较\n15.6.2 MECHANISM是CORE DOMAIN一部分\n15.7 通过精炼得到声明式风格\n15.8 模式：SEGREGATED CORE\n15.8.1 创建SEGREGATED CORE的代价\n15.8.2 不断发展演变的团队决策\n15.9 模式：ABSTRACT CORE\n15.10 深层模型精炼\n15.11 选择重构目标\n第16章 大比例结构\n16.1 模式：EVOLVING ORDER\n16.2 模式：SYSTEM METAPHOR\n16.3 模式：RESPONSIBILITY LAYER\n16.4 模式：KNOWLEDGE LEVEL\n16.5 模式：PLUGGABLE COMPONENT FRAMEWORK\n16.6 结构应该有一种什么样的约束\n16.7 通过重构得到更适当的结构\n16.7.1 最小化\n16.7.2 沟通和自律\n16.7.3 通过重构得到柔性设计\n16.7.4 通过精炼可以减轻负担\n第17章 领域驱动设计的综合运用\n17.1 把大比例结构与BOUNDED CONTEXT结合起来使用\n17.2 将大比例结构与精炼结合起来使用\n17.3 首先评估\n17.4 由谁制定策略\n17.4.1 从应用程序开发自动得出的结构\n17.4.2 以客户为中心的架构团队\n17.5 制定战略设计决策的6个要点\n17.5.1 技术框架同样如此\n17.5.2 注意总体规划\n结束语\n附录\n术语表\n参考文献\n图片说明\n索引","pages":"369","images":{"small":"https://img3.doubanio.com/view/subject/s/public/s27608362.jpg","large":"https://img3.doubanio.com/view/subject/l/public/s27608362.jpg","medium":"https://img3.doubanio.com/view/subject/m/public/s27608362.jpg"},"alt":"https://book.douban.com/subject/5344973/","id":"5344973","publisher":"人民邮电出版社","isbn10":"7115238871","isbn13":"9787115238870","title":"领域驱动设计","url":"https://api.douban.com/v2/book/5344973","alt_title":"","author_intro":"","summary":"《领域驱动设计:软件核心复杂性应对之道》是领域驱动设计方面的经典之作。全书围绕着设计和开发实践，结合若干真实的项目案例，向读者阐述如何在真实的软件开发中应用领域驱动设计。书中给出了领域驱动设计的系统化方法，并将人们普遍接受的一些最佳实践综合到一起，融入了作者的见解和经验，展现了一些可扩展的设计最佳实践、已验证过的技术以及便于应对复杂领域的软件项目开发的基本原则。《领域驱动设计:软件核心复杂性应对之道》适合各层次的面向对象软件开发人员、系统分析员阅读。","price":"69.00元"},"9787115330246":{"rating":{"max":10,"numRaters":324,"average":"8.2","min":0},"subtitle":"像google一样进行软件测试","author":["James A. Whittaker","Jason Arbon","Jeff Carollo"],"pubdate":"2013-10","tags":[{"count":506,"name":"软件测试","title":"软件测试"},{"count":201,"name":"测试","title":"测试"},{"count":156,"name":"Google","title":"Google"},{"count":114,"name":"测试方法","title":"测试方法"},{"count":95,"name":"软件工程","title":"软件工程"},{"count":90,"name":"计算机","title":"计算机"},{"count":66,"name":"软件开发","title":"软件开发"},{"count":42,"name":"计算机科学","title":"计算机科学"}],"origin_title":"How Google Tests Software","image":"https://img3.doubanio.com/view/subject/m/public/s27082506.jpg","binding":"平装","translator":["黄利","李中杰","薛明"],"catalog":"《google软件测试之道》\n第1章　google软件测试介绍　1\n1.1　质量不等于测试　5\n1.2　角色　6\n1.2.1　软件开发工程师(swe)　7\n1.2.2　软件测试开发工程师(set)　7\n1.2.3　测试工程师(te)　8\n1.3　组织结构　9\n1.4　爬、走、跑　10\n1.5　测试类型　12\n第2章　软件测试开发工程师　15\n2.1　set的工作　17\n2.1.1　开发和测试流程　17\n2.1.2　set究竟是谁　21\n2.1.3　项目的早期阶段　22\n2.1.4　团队结构　23\n2.1.5　设计文档　24\n2.1.6　接口与协议　26\n2.1.7　自动化计划　27\n2.1.8　可测试性　28\n.2.1.9　set的工作流程：一个实例　31\n2.1.10　测试执行　41\n2.1.11　测试大小的定义　42\n2.1.12　测试规模在共享测试平台中的使用　45\n2.1.13　测试规模的益处　46\n2.1.14　测试运行要求　48\n2.2　测试认证　54\n2.3　set的招聘　62\n2.4　与工具开发工程师ted mao的访谈　68\n2.5　与web driver的创建者simon stewart的对话　70\n第3章　测试工程师　75\n3.1　一种面向用户的测试角色　75\n3.2　测试工程师的工作　76\n3.2.1　测试计划　79\n3.2.2　风险　94\n3.2.3　测试用例的生命周期　104\n3.2.4　bug的生命周期　109\n3.2.5　te的招聘　121\n3.2.6　google的测试领导和管理工作　128\n3.2.7　维护模式的测试(maintenance mode testing)　131\n3.2.8　质量机器人(quality bot)实验　134\n3.2.9　bite实验　145\n3.2.10　google test analytics　154\n3.2.11　零成本测试流程　159\n3.2.12　外部供应商　163\n3.3　与google docs测试工程师林赛·韦伯斯特(lindsay webster)的访谈　165\n3.4　与youtube测试工程师安普·周(apple chow)的访谈　170\n第4章　测试工程经理　177\n4.1　测试工程经理的工作　177\n4.2　获得项目和人员　179\n4.3　影响力　180\n4.4　gmail测试工程经理ankit mehta的访谈　182\n4.5　android测试工程经理hung dang的访谈　188\n4.6　chrome测试工程经理joel hynoski的访谈　192\n4.7　测试总监　197\n4.8　搜索和地理信息测试总监shelton mar的访谈　198\n4.9　工程工具总监ashish kumar的访谈　201\n4.10　印度google测试总监sujaysahni访谈　205\n4.11　工程经理brad green访谈　209\n4.12　james whittaker访谈　212\n第5章　google软件测试改进　219\n5.1　google流程中的致命缺陷　219\n5.2　set的未来　221\n5.3　te的未来　222\n5.4　测试总监和经理的未来　223\n5.5　未来的测试基础设施　224\n5.6　结论　225\n附录a　chrome os测试计划　227\na.1　测试主题概述　227\na.2　风险分析　228\na.3　每次构建版本的基线测试　228\na.4　最新可测试版本(last known good，lkg)的每日测试　229\na.5　发布版本测试　229\na.6　手工测试与自动化测试　229\na.7　开发和测试的质量关注点　230\na.8　发布通道　230\na.9　用户输入　230\na.10　测试用例库　231\na.11　测试仪表盘　231\na.12　虚拟化　231\na.13　性能　231\na.14　压力、长时运行和稳定性测试　231\na.15　测试执行框架(autotest)　232\na.16　oem厂商　232\na.17　硬件实验田　232\na.18　端到端测试自动化集群　232\na.19　测试浏览器的应用管理器　232\na.20　浏览器的可测试性　233\na.21　硬件　234\na.22　时间线　234\na.23　主要的测试驱动力　236\na.24　相关文档　236\n附录b　chrome的漫游测试　239\nb.1　购物漫游　239\nb.2　学生漫游　240\nb.3　国际长途电话漫游　241\nb.4　地标漫游　241\nb.5　通宵漫游　242\nb.6　公务漫游测试　243\nb.7　危险地带漫游　243\nb.8　个性化漫游　244\n附录c　有关工具和代码的博客文章　245\nc.1　使用bite从bug和冗余的工作中解脱出来　245\nc.2　发布qualitybot　247\nc.3　rpf：google的录制回放框架　249\nc.4　google测试分析系统(google test analytics)——现在开源了　251\n附录d　术语表　257","pages":"258","images":{"small":"https://img3.doubanio.com/view/subject/s/public/s27082506.jpg","large":"https://img3.doubanio.com/view/subject/l/public/s27082506.jpg","medium":"https://img3.doubanio.com/view/subject/m/public/s27082506.jpg"},"alt":"https://book.douban.com/subject/25742200/","id":"25742200","publisher":"人民邮电出版社","isbn10":"7115330247","isbn13":"9787115330246","title":"Google软件测试之道","url":"https://api.douban.com/v2/book/25742200","alt_title":"How Google Tests Software","author_intro":"james whittaker 是google的工程总监 ，负责部分google产品的测试，包括chrome、地图、google web apps。在加盟google之前，james在microsoft工作，再之前是一名大学教授。james在全球测试领域闻名遐迩。\njason arbon 是google的一名测试工程师te ，曾参与负责google桌面、chrome和chrome os的测试。同时jason也是一系列开源测试工具和个性化实验的开发负责人。在加入google之前，他也曾在microsoft工作过。\njeff carollo 是google的一名测试开发工程师set，曾参与负责google voice、工具框、chrome、chrome os产品 的测试。jeff为许多google内部的开发团队提供咨询服务，帮助提升这些团队初期的代码质量。之后在2010年，jeff转岗为软件开发工程师（se），并领导负责google+ apis的开发。在加入google之前，jeff也曾经在microsoft工作过。","summary":"每天，google都要测试和发布数百万个源文件、亿万行的代码。数以亿计的构建动作会触发几百万次的自动化测试，并在好几十万个浏览器实例上执行。面对这些看似不可能完成的任务，谷歌是如何测试的呢？\n《google软件测试之道》从内部视角告诉你这个世界上知名的互联网公司是如何应对21世纪软件测试的独特挑战的。《google软件测试之道》抓住了google做测试的本质，抓住了google测试这个时代最复杂软件的精华。《google软件测试之道》描述了测试解决方案，揭示了测试架构是如何设计、实现和运行的，介绍了软件测试工程师的角色；讲解了技术测试人员应该具有的技术技能；阐述了测试工程师在产品生命周期中的职责；讲述了测试管理及在google的测试历史或在主要产品上发挥了重要作用的工程师的访谈，这对那些试图建立类似google的测试流程或团队的人受益很大。\n最后，《google软件测试之道》还介绍了作者对于google测试如何继续演进的见解、google乃至整个业界的测试方向的一些预言，相信很多读者都会感受到其中的洞察力，甚至感到震惊。本书可以作为任何从事软件测试人员到达目标的指南。\n《google软件测试之道》适合开发人员、测试人员、测试管理人员使用，也适合大中专院校相关专业师生的学习用书，以及培训学校的教材。","price":"59.00元"},"9787111173199":{"rating":{"max":10,"numRaters":194,"average":"8.4","min":0},"subtitle":"","author":["梅尔斯"],"pubdate":"2006年01月","tags":[{"count":413,"name":"软件测试","title":"软件测试"},{"count":124,"name":"测试","title":"测试"},{"count":123,"name":"软件测试的艺术","title":"软件测试的艺术"},{"count":81,"name":"计算机","title":"计算机"},{"count":61,"name":"软件工程","title":"软件工程"},{"count":48,"name":"IT","title":"IT"},{"count":45,"name":"编程","title":"编程"},{"count":42,"name":"Test","title":"Test"}],"origin_title":"","image":"https://img3.doubanio.com/view/subject/m/public/s1694970.jpg","binding":"平装","translator":[],"catalog":"","pages":"122 页","images":{"small":"https://img3.doubanio.com/view/subject/s/public/s1694970.jpg","large":"https://img3.doubanio.com/view/subject/l/public/s1694970.jpg","medium":"https://img3.doubanio.com/view/subject/m/public/s1694970.jpg"},"alt":"https://book.douban.com/subject/1445661/","id":"1445661","publisher":"机械工业出版社","isbn10":"7111173198","isbn13":"9787111173199","title":"软件测试的艺术","url":"https://api.douban.com/v2/book/1445661","alt_title":"","author_intro":"","summary":"《软件测试的艺术》(原书第2版)成功、有效地进行软件测试的实用策略和技术：\n　　 基本的测试原理和策略　　　　　 验收测试\n　　 程序检查和走查 　　　　　　　  安装测试\n　　 代码检查　　　　　　　　　　　 模块（单元）测试\n　　 错误列表　　　　　　　　　　　 测试规划与控制\n　　 同行评分　　　　　　　　　　　 独立测试机构\n　　 黑盒、白盒测试　　　　　　　　 调试原理\n　　 错误猜测　　　　　　　　　　　 错误分析\n　　 自顶向下与自底向上测试　　　　 极限测试\n　　 高级测试　　　　　　　　　　　 测试因特网应用系统\n　　 功能和系统测试 　　　　　　　  电子商务体系结构的高级测试","series":{"id":"9870","title":"华章·软件工程技术丛书"},"price":"22.0"},"9787121315787":{"rating":{"max":10,"numRaters":46,"average":"7.2","min":0},"subtitle":"","author":["李艳鹏","杨彪"],"pubdate":"2017-8","tags":[{"count":63,"name":"分布式","title":"分布式"},{"count":54,"name":"架构","title":"架构"},{"count":28,"name":"微服务","title":"微服务"},{"count":21,"name":"软件架构","title":"软件架构"},{"count":20,"name":"软件开发","title":"软件开发"},{"count":11,"name":"计算机","title":"计算机"},{"count":9,"name":"Java","title":"Java"},{"count":6,"name":"互联网","title":"互联网"}],"origin_title":"","image":"https://img3.doubanio.com/view/subject/m/public/s29496866.jpg","binding":"平装","translator":[],"catalog":"第1章  分布式微服务架构设计原理\t1\n1.1  从传统单体架构到服务化架构\t2\n1.1.1  JEE架构\t2\n1.1.2  SSH架构\t5\n1.1.3  服务化架构\t8\n1.2  从服务化到微服务\t11\n1.2.1  微服务架构的产生\t12\n1.2.2  微服务架构与传统单体架构的对比\t13\n1.2.3  微服务架构与SOA服务化的对比\t15\n1.3  微服务架构的核心要点和实现原理\t16\n1.3.1  微服务架构中职能团队的划分\t16\n1.3.2  微服务的去中心化治理\t18\n1.3.3  微服务的交互模式\t18\n1.3.4  微服务的分解和组合模式\t22\n1.3.5  微服务的容错模式\t35\n1.3.6  微服务的粒度\t41\n1.4  Java平台微服务架构的项目组织形式\t42\n1.4.1  微服务项目的依赖关系\t42\n1.4.2  微服务项目的层级结构\t43\n1.4.3  微服务项目的持续发布\t45\n1.5  服务化管理和治理框架的技术选型\t45\n1.5.1  RPC\t46\n1.5.2  服务化\t47\n1.5.3  微服务\t49\n1.6  本章小结\t52\n第2章  彻底解决分布式系统一致性的问题\t54\n2.1  什么是一致性\t55\n2.2  一致性问题\t56\n2.3  解决一致性问题的模式和思路\t57\n2.3.1  酸碱平衡理论\t58\n2.3.2  分布式一致性协议\t61\n2.3.3  保证最终一致性的模式\t67\n2.4  超时处理模式\t75\n2.4.1  微服务的交互模式\t76\n2.4.2  同步与异步的抉择\t77\n2.4.3  交互模式下超时问题的解决方案\t78\n2.4.4  超时补偿的原则\t85\n2.5  迁移开关的设计\t87\n2.6  本章小结\t88\n第3章  服务化系统容量评估和性能保障\t89\n3.1  架构设计与非功能质量\t90\n3.2  全面的非功能质量需求\t91\n3.2.1  非功能质量需求的概述\t91\n3.2.2  非功能质量需求的具体指标\t92\n3.3  典型的技术评审提纲\t97\n3.3.1  现状\t97\n3.3.2  需求\t98\n3.3.3  方案描述\t98\n3.3.4  方案对比\t99\n3.3.5  风险评估\t100\n3.3.6  工作量评估\t100\n3.4  性能和容量评估经典案例\t100\n3.4.1  背景\t100\n3.4.2  目标数据量级\t101\n3.4.3  量级评估标准\t101\n3.4.4  方案\t102\n3.4.5  小结\t107\n3.5  性能评估参考标准\t108\n3.5.1  常用的应用层性能指标参考标准\t108\n3.5.2  常用的系统层性能指标参考标准\t109\n3.6  性能测试方案的设计和最佳实践\t112\n3.6.1  明确压测目标\t112\n3.6.2  压测场景设计和压测方案制定\t114\n3.6.3  准备压测环境\t121\n3.6.4  压测的执行\t122\n3.6.5  问题修复和系统优化\t123\n3.7  有用的压测工具\t123\n3.7.1  ab\t123\n3.7.2  jmeter\t125\n3.7.3  mysqlslap\t125\n3.7.4  sysbench\t129\n3.7.5  dd\t134\n3.7.6  LoadRunner\t135\n3.7.7  hprof\t136\n3.8  本章小结\t138\n第4章  大数据日志系统的构建\t140\n4.1  开源日志框架的原理分析与应用实践\t142\n4.1.1  JDK Logger\t142\n4.1.2  Apache Commons Logging\t143\n4.1.3  Apache Log4j\t147\n4.1.4  Slf4j\t156\n4.1.5  Logback\t160\n4.1.6  Apache Log4j 2\t164\n4.2  日志系统的优化和最佳实践\t168\n4.2.1  开发人员的日志意识\t168\n4.2.2  日志级别的设置\t168\n4.2.3  日志的数量和大小\t169\n4.2.4  切割方式\t170\n4.2.5  日志格式的配置\t170\n4.2.6  一行日志导致的线上事故\t177\n4.3  大数据日志系统的原理与设计\t178\n4.3.1  通用架构和设计\t179\n4.3.2  日志采集器\t180\n4.3.3  日志缓冲队列\t186\n4.3.4  日志解析器\t187\n4.3.5  日志存储和搜索\t187\n4.3.6  日志展示系统\t188\n4.3.7  监控和报警\t188\n4.3.8  日志系统的容量和性能评估\t188\n4.4  ELK系统的构建与使用\t190\n4.4.1  Elasticsearch\t191\n4.4.2  Logstash\t193\n4.4.3  Kibana\t196\n4.5  本章小结\t198\n第5章  基于调用链的服务治理系统的设计与实现\t199\n5.1  APM系统简介\t200\n5.1.1  优秀的开源APM系统\t200\n5.1.2  国内商业APM产品的介绍\t202\n5.2  调用链跟踪的原理\t203\n5.2.1  分布式系统的远程调用过程\t204\n5.2.2  TraceID\t207\n5.2.3  SpanID\t208\n5.2.4  业务链\t210\n5.3  调用链跟踪系统的设计与实现\t211\n5.3.1  整体架构\t211\n5.3.2  TraceID和SpanID在服务间的传递\t213\n5.3.3  采集器的设计与实现\t217\n5.3.4  处理器的设计与实现\t222\n5.3.5  调用链系统的展示\t225\n5.4  本章小结\t226\n第6章  Java服务的线上应急和技术攻关\t227\n6.1  海恩法则和墨菲定律\t227\n6.2  线上应急的目标、原则和方法\t229\n6.2.1  应急目标\t229\n6.2.2  应急原则\t229\n6.2.3  线上应急的方法和流程\t230\n6.3  技术攻关的方法论\t233\n6.4  环境搭建和示例服务启动\t236\n6.5  高效的服务化治理脚本\t240\n6.5.1  show-busiest-java-threads\t240\n6.5.2  find-in-jar\t243\n6.5.3  grep-in-jar\t244\n6.5.4  jar-conflict-detect\t245\n6.5.5  http-spy\t247\n6.5.6  show-mysql-qps\t248\n6.5.7  小结\t249\n6.6  JVM提供的监控命令\t249\n6.6.1  jad\t249\n6.6.2  btrace\t250\n6.6.3  jmap\t252\n6.6.4  jstat\t255\n6.6.5  jstack\t256\n6.6.6  jinfo\t258\n6.6.7  其他命令\t258\n6.6.8  小结\t259\n6.7  重要的Linux基础命令\t260\n6.7.1  必不可少的基础命令和工具\t260\n6.7.2  查看活动进程的命令\t268\n6.7.3  窥探内存的命令\t270\n6.7.4  针对CPU使用情况的监控命令\t272\n6.7.5  监控磁盘I/O的命令\t273\n6.7.6  查看网络信息和网络监控命令\t275\n6.7.7  Linux系统的高级工具\t287\n6.7.8  /proc文件系统\t288\n6.7.9  摘要命令\t288\n6.7.10  小结\t290\n6.8  现实中的应急和攻关案例\t291\n6.8.1  一次OOM事故的分析和定位\t291\n6.8.2  一次CPU 100%的线上事故排查\t301\n6.9  本章小结\t304\n第7章  服务的容器化过程\t306\n7.1  容器vs虚拟机\t306\n7.1.1  什么是虚拟机\t306\n7.1.2  什么是容器\t306\n7.1.3  容器和虚拟机的区别\t307\n7.1.4  容器主要解决的问题\t307\n7.1.5  Docker的优势\t310\n7.2  Docker实战\t311\n7.2.1  Docker的架构\t311\n7.2.2  Docker的安装\t315\n7.2.3  Docker初体验\t319\n7.2.4  Docker后台服务的管理\t322\n7.2.5  Docker的客户端命令\t328\n7.2.6  Docker Compose编排工具的使用\t372\n7.3  容器化项目\t379\n7.3.1  传统的应用部署\t380\n7.3.2  将应用程序部署在虚拟机上\t380\n7.3.3  容器化部署应用\t381\n7.3.4  Docker实现的应用容器化示例\t382\n7.4  本章小结\t384\n第8章  敏捷开发2.0的自动化工具\t385\n8.1  什么是敏捷开发2.0\t385\n8.1.1  常用的4种开发模式\t385\n8.1.2  什么是DevOps\t390\n8.1.3  敏捷开发2.0解决的问题\t392\n8.2  敏捷开发的自动化流程\t393\n8.2.1  持续集成\t393\n8.2.2  持续交付和持续部署\t397\n8.3  敏捷开发的常用自动化工具\t400\n8.3.1  分布式版本控制工具Git\t400\n8.3.2  持续集成和持续交付工具Jenkins\t410\n8.3.3  基础平台管理工具SaltStack\t418\n8.3.4  Docker容器化工具\t421\n8.4  本章小结\t422","ebook_url":"https://read.douban.com/ebook/49567191/","pages":"400","images":{"small":"https://img3.doubanio.com/view/subject/s/public/s29496866.jpg","large":"https://img3.doubanio.com/view/subject/l/public/s29496866.jpg","medium":"https://img3.doubanio.com/view/subject/m/public/s29496866.jpg"},"alt":"https://book.douban.com/subject/27091029/","id":"27091029","publisher":"电子工业出版社","isbn10":"7121315785","isbn13":"9787121315787","title":"分布式服务架构：原理、设计与实战","url":"https://api.douban.com/v2/book/27091029","alt_title":"","author_intro":"李艳鹏\n现任易宝支付产品中心首席架构师，曾在花旗银行、甲骨文、路透社、新浪微博等大型IT互联网公司担任技术负责人和架构师，现专注于大规模、高并发的线上和线下支付平台的应用架构和技术架构的规划与落地，负责交易、支付、渠道、出款、风控、对账等核心支付系统的设计与实现，对移动支付、聚合支付、合规账户、扫码支付、标记化支付等业务场景有产品应用架构规划与落地的实践经验。\n杨 彪\n现任某创业公司技术总监及合伙人，在互联网和游戏行业有近10年工作经验，曾在酷我音乐盒、人人游戏和掌趣科技等上市公司担任核心研发职位，在互联网公司做过日活跃用户量达千万的项目，也在游戏公司做过多款月流水千万以上的游戏。喜欢研究问题，追求前沿技术，学无止境。","summary":"《分布式服务架构：原理、设计与实战》全面介绍了分布式服务架构的原理与设计，并结合作者在实施微服务架构过程中的实践经验，总结了保障线上服务健康、可靠的最佳方案，是一本架构级、实战型的重量级著作。\n《分布式服务架构：原理、设计与实战》以分布式服务架构的设计与实现为主线，由浅入深地介绍了分布式服务架构的方方面面，主要包括理论和实践两部分。理论上，首先介绍了服务架构的背景，以及从服务化架构到微服务架构的演化；然后提出了保证分布式服务系统架构一致性的方案和模式，并介绍了互联网架构评审的方法论；最后给出了一个简要的非功能质量的技术评审提纲。实践上，首先提供了一个互联网项目的性能和容量评估的真实案例，介绍了压测的方案设计和最佳实践，这些技术能够全面保证大规模、高并发项目的一致性、可用性和高并发性；然后讲解了大规模服务的日志系统的原理、设计与实践，包括ELK等框架的特点和使用方式等，并介绍了当前流行的APM系统的设计与实现，主要包括调用链和业务链的跟踪与恢复，涵盖了线上应急和技术攻关的流程及重点，也结合服务化系统线上应急过程进行分析并总结了其中需要用到的Java虚拟机、Linux和定制化脚本等命令，这些命令都是每个开发人员都会用到的解决线上问题的利器；最后，阐述了系统服务的容器化过程，并详细介绍了敏捷开发流程和实现自动化的常用工具等，让读者既能学到架构设计的基础理论，也能结合书中的原理、设计与方法论来解决大规模、高并发互联网项目中的现实问题。\n无论是对于软件工程师、测试工程师、运维工程师、软件架构师、技术经理、技术总监，还是对于资深IT人士来说，《分布式服务架构：原理、设计与实战》都有很强的借鉴性和参考价值。","ebook_price":"53.40","price":"89.00"},"9787121271649":{"rating":{"max":10,"numRaters":78,"average":"7.1","min":0},"subtitle":"高效部署分布式消息队列","author":["Alvaro Videla","Jason J. W. Williams"],"pubdate":"2015-10","tags":[{"count":83,"name":"消息队列","title":"消息队列"},{"count":50,"name":"rabbitmq","title":"rabbitmq"},{"count":43,"name":"分布式","title":"分布式"},{"count":24,"name":"RabbitMQ","title":"RabbitMQ"},{"count":15,"name":"Erlang","title":"Erlang"},{"count":13,"name":"架构","title":"架构"},{"count":9,"name":"计算机","title":"计算机"},{"count":9,"name":"编程","title":"编程"}],"origin_title":"RabbitMQ in Action : Distributed Messaging for Everyone","image":"https://img3.doubanio.com/view/subject/m/public/s28324884.jpg","binding":"平装","translator":["汪佳南"],"catalog":"第1章 天降奇兵 1\n1.1 住在别人的地下城堡 3\n1.2 救世主AMQP 5\n1.3 RabbitMQ简史 5\n1.4 百里挑一 8\n1.5 在UNIX系统上安装RabbitMQ 8\n1.5.1 为什么环境很重要--生活在Erlang 的世界里 9\n1.5.2 获取安装包 9\n1.5.3 设置文件夹结构 9\n1.5.4 首次运行Rabbit 10\n1.6 总结 12\n第2章 理解消息通信13\n2.1 消费者和生产者（这可不是经济学课程哦） 14\n2.2 从底部开始构造：队列 17\n2.3 联合起来：交换器和绑定 22\n2.4 多租户模式：虚拟主机和隔离 27\n2.5 我的消息去哪儿了呢？持久化和你的策略 28\n2.6 把所有内容结合起来：一条消息的一生 32\n2.7 使用发送方确认模式来确认投递 37\n2.8 总结 40\n第3章 运行和管理Rabbit 42\n3.1 服务器管理 43\n3.1.1 启动节点 43\n3.1.2 停止节点 45\n3.1.3 关闭和重启应用程序：有何差别 46\n3.1.4 Rabbit 配置文件 46\n3.2 请求许可 48\n3.2.1 管理用户 49\n3.2.2 Rabbit 的权限系统 50\n3.3 检查 54\n3.3.1 查看数据统计 54\n3.3.2 理解RabbitMQ 日志 59\n3.4 修复Rabbit：疑难解答 63\n由badrpc、nodedown 和其他Erlang 引起的问题 63\n3.5 总结 68\n第4章 解决Rabbit相关问题：编码与模式69\n4.1 解耦风雨路：谁将我们推向消息通信 70\n4.1.1 异步状态思维（分离请求和动作） 70\n4.1.2 提供扩展性：没有负载均衡器的世界 73\n4.1.3 零成本API ：语言不应成为枷锁 73\n4.2 发后即忘模型 74\n4.2.1 发送告警 75\n4.2.2 并行处理 84\n4.3 别忘了：用RabbitMQ实现RPC并等待响应 92\n4.3.1 私有队列和发送确认 93\n4.3.2 使用reply_to 来实现简单的JSON RPC 93\n4.4 总结 98\n第5章 集群并处理失败99\n5.1 开足马力：RabbitMQ集群 100\n5.2 集群架构 101\n5.2.1 集群中的队列 101\n5.2.2 分布交换器 103\n5.2.3 是内存节点还是磁盘节点 104\n5.3 在你的笔记本电脑上设置集群 106\n5.4 将节点分布到更多的机器上 110\n5.5 升级集群节点 114\n5.6 镜像队列和保留消息 115\n5.6.1 声明并使用镜像队列 115\n5.6.2 镜像队列工作原理 118\n5.7 总结 120\n第6章 从故障中恢复121\n6.1 为Rabbit做负载均衡 122\n6.1.1 安装HAProxy 124\n6.1.2 配置HAProxy 125\n6.2 连接丢失和故障转移 127\n6.3 总结 134\n第7章 warren和Shovel：故障转移和复制 135\n7.1 warren：另一种集群方式 136\n7.2 设定负载均衡器--基于主/从的集群 138\n7.3 远距离通信和复制 142\n7.3.1 给Rabbit 装备Shovel ：Shovel 插件介绍 142\n7.3.2 安装Shovel 145\n7.3.3 配置并运行Shovel 146\n7.4 总结 152\n第8章 从Web端管理RabbitMQ 154\n8.1 超越rabbitmqctl：RabbitMQ Management插件 155\n8.1.1 为何需要Management 插件 155\n8.1.2 Management 插件功能 155\n8.1.3 启用Management 插件 156\n8.2 从Web控制台来管理RabbitMQ 158\n8.2.1 监控Erlang VM 158\n8.2.2 从JSON 文件导入配置 159\n8.3 从Web控制台管理用户 160\n8.3.1 创建用户 161\n8.3.2 管理用户的权限 162\n8.4 从Web控制台管理交换器和队列 163\n8.4.1 列出队列信息 165\n8.4.2 创建队列 166\n8.5 回到命令行 168\n8.5.1 为什么需要另一个CLI 168\n8.5.2 CLI 管理：一种更简单的方式 170\n8.5.3 安装rabbitmqadmin 脚本 170\n8.5.4 清空队列、创建交换器等 171\n8.6 总结 172\n第9章 使用REST API控制Rabbit 173\n9.1 能用RabbitMQ REST API做什么 175\n9.2 对客户端授权访问 177\n9.3 访问数据统计 178\n9.4 自动化vhost和用户配置 181\n9.5 总结 .186\n第10章 监控187\n10.1 监控RabbitMQ：密切关注你的warren 188\n10.1.1 为Nagios 编写健康检测 188\n10.1.2 使用AMQP 模拟检测来确认RabbitMQ 是否运行 190\n10.1.3 使用REST API 来检测 193\n10.1.4 监控配置文件修改 196\n10.1.5 监控集群状态 201\n10.2 确保消费者正常工作 206\n10.2.1 通过AMQP 监控队列等级 208\n10.2.2 使用REST API 来监控队列级别 212\n10.2.3 建立队列的消息计数基准经验法则 215\n10.3 总结216\n第11章 提升性能，保障安全217\n11.1 对速度的需求 218\n11.1.1 消息持久化 218\n11.1.2 消息确认 219\n11.1.3 路由算法和绑定规则 219\n11.1.4 投递消息 221\n11.2 内存使用率和进程限制 223\n11.2.1 内存使用率 223\n11.2.2 Erlang 进程计数 226\n11.3 SSL连接 ..227\n11.3.1 SSL 证书.228\n11.3.2 设置证书颁发机构 ..229\n11.3.3 生成根证书 233\n11.3.4 生成服务器端证书 234\n11.3.5 生成客户端证书 235\n11.3.6 启用RabbitMQ 的SSL 监听器 236\n11.3.7 测试你的RabbitMQ SSL 设置 237\n11.4 总结 239\n第12章 聪明的Rabbit：扩展RabbitMQ241\n12.1 RabbitMQ插件 242\n12.1.1 你可以用插件做什么 242\n12.1.2 在哪里可以找到插件 244\n12.1.3 安装插件 244\n12.1.4 移除插件 245\n12.2 制作你自己的插件 247\n12.2.1 获取RabbitMQ Public Umbrella 248\n12.2.2 设置文件夹结构 249\n12.2.3 包含插件构建系统 250\n12.2.4 创建Erlang 应用文件 250\n12.3 创建自定义交换器模块 252\n12.3.1 将交换器注册到RabbitMQ 254\n12.3.2 实现交换器behaviour 257\n12.3.3 编译自定义交换器 264\n12.3.4 测试你的插件 267\n12.4 总结 271\n附录A 在Java和.NET上使用Rabbit 273\n附录B 在线资源302\n附录C 在Windows上安装RabbitMQ 307","pages":"332","images":{"small":"https://img3.doubanio.com/view/subject/s/public/s28324884.jpg","large":"https://img3.doubanio.com/view/subject/l/public/s28324884.jpg","medium":"https://img3.doubanio.com/view/subject/m/public/s28324884.jpg"},"alt":"https://book.douban.com/subject/26649178/","id":"26649178","publisher":"电子工业出版社","isbn10":"7121271648","isbn13":"9787121271649","title":"RabbitMQ实战","url":"https://api.douban.com/v2/book/26649178","alt_title":"RabbitMQ in Action : Distributed Messaging for Everyone","author_intro":"Alvaro Videla是一名专门从事基于MQ应用程序的开发者和架构师。\nJason J.W. Williams是消息通信服务供应商DigiTar公司的CTO，他领导着设计与开发工作。","summary":"本书对RabbitMQ做了全面、翔实的讲解，体现了两位专家的真知灼见。本书首先介绍了有关MQ的历史，然后从基本的消息通信原理讲起，带领读者一路探索RabbitMQ的消息通信世界。这当中不仅包含了针对单台RabbitMQ服务器和RabbitMQ集群的讲解，还教导读者如何使用各种工具来进行监控。\n本书内容浅显易懂，文笔风趣幽默。书中包含了丰富的、可以运行的示例程序源代码，读者可以自行下载并运行，这种亲身实践有助于加深对相关主题的理解。对于初学者来说，这样的编排非常适用。对于那些有一定RabbitMQ使用经验的读者来说，本书不仅可以巩固消息通信基本原理，同时也可加深对RabbitMQ高级特性的理解，譬如如何编写RabbitMQ插件。相信处于RabbitMQ探索之旅不同阶段的读者都能从本书获益。\n本书适合有一定工作经验的开发者或者架构师阅读，也可以作为RabbitMQ运维工作的参考手册。","price":"75.00元"},"9780596521998":{"rating":{"max":10,"numRaters":266,"average":"8.3","min":0},"subtitle":"MapReduce for the Cloud","author":["Tom White"],"pubdate":"2009","tags":[{"count":316,"name":"hadoop","title":"hadoop"},{"count":177,"name":"MapReduce","title":"MapReduce"},{"count":151,"name":"分布式","title":"分布式"},{"count":60,"name":"Cloud","title":"Cloud"},{"count":41,"name":"计算机","title":"计算机"},{"count":40,"name":"架构","title":"架构"},{"count":36,"name":"Hadoop","title":"Hadoop"},{"count":26,"name":"技术","title":"技术"}],"origin_title":"","image":"https://img3.doubanio.com/view/subject/m/public/s3810946.jpg","binding":"pap","translator":[],"catalog":"","pages":"250","images":{"small":"https://img3.doubanio.com/view/subject/s/public/s3810946.jpg","large":"https://img3.doubanio.com/view/subject/l/public/s3810946.jpg","medium":"https://img3.doubanio.com/view/subject/m/public/s3810946.jpg"},"alt":"https://book.douban.com/subject/3220004/","id":"3220004","publisher":"O'Reilly Media, Inc.","isbn10":"0596521995","isbn13":"9780596521998","title":"Hadoop: The Definitive Guide","url":"https://api.douban.com/v2/book/3220004","alt_title":"","author_intro":"","summary":"Apache Hadoop is ideal for organizations with a growing need to store and process massive application datasets. Hadoop: The Definitive Guide is a comprehensive resource for using Hadoop to build reliable, scalable, distributed systems. Programmers will find details for analyzing large datasets with Hadoop, and administrators will learn how to set up and run Hadoop clusters. The book includes case studies that illustrate how Hadoop solves specific problems.\nOrganizations large and small are adopting Apache Hadoop to deal with huge application datasets. Hadoop: The Definitive Guide provides you with the key for unlocking the wealth this data holds. Hadoop is ideal for storing and processing massive amounts of data, but until now, information on this open-source project has been lacking -- especially with regard to best practices. This comprehensive resource demonstrates how to use Hadoop to build reliable, scalable, distributed systems. Programmers will find details for analyzing large datasets with Hadoop, and administrators will learn how to set up and run Hadoop clusters.\nWith case studies that illustrate how Hadoop solves specific problems, this book helps you:\n* Learn the Hadoop Distributed File System (HDFS), including ways to use its many APIs to transfer data\n* Write distributed computations with MapReduce, Hadoop's most vital component\n* Become familiar with Hadoop's data and IO building blocks for compression, data integrity, serialization, and persistence\n* Learn the common pitfalls and advanced features for writing real-world MapReduce programs\n* Design, build, and administer a dedicated Hadoop cluster\n* Use HBase, Hadoop's database for structured and semi-structured data\nAnd more. Hadoop: The Definitive Guide is still in progress, but you can get started on this technology with the Rough Cuts edition, which lets you read the book online or download it in PDF format as the manuscript evolves.","price":"44.99"},"9787121249679":{"rating":{"max":10,"numRaters":294,"average":"7.8","min":0},"subtitle":"分布式一致性原理与实践","author":["倪超"],"pubdate":"2015-2-1","tags":[{"count":325,"name":"分布式","title":"分布式"},{"count":282,"name":"ZooKeeper","title":"ZooKeeper"},{"count":128,"name":"Paxos","title":"Paxos"},{"count":121,"name":"分布式一致性","title":"分布式一致性"},{"count":61,"name":"计算机","title":"计算机"},{"count":53,"name":"zookeeper","title":"zookeeper"},{"count":45,"name":"软件架构","title":"软件架构"},{"count":40,"name":"Java","title":"Java"}],"origin_title":"","image":"https://img1.doubanio.com/view/subject/m/public/s28377338.jpg","binding":"平装","translator":[],"catalog":"第1章分布式架构\t1\n1.1  从集中式到分布式\t1\n1.1.1  集中式的特点\t2\n1.1.2  分布式的特点\t2\n1.1.3  分布式环境的各种问题\t4\n1.2  从ACID到CAP/BASE\t5\n1.2.1  ACID\t5\n1.2.2  分布式事务\t8\n1.2.3  CAP和BASE理论\t9\n小结\t15\n第2章一致性协议\t17\n2.1  2PC与3PC\t17\n2.1.1  2PC\t17\n2.1.2  3PC\t21\n2.2  Paxos算法\t24\n2.2.1  追本溯源\t25\n2.2.2  Paxos理论的诞生\t26\n2.2.3  Paxos算法详解\t27\n小结\t37\n第3章Paxos的工程实践\t39\n3.1  Chubby\t39\n3.1.1  概述\t39\n3.1.2  应用场景\t40\n3.1.3  设计目标\t40\n3.1.4  Chubby技术架构\t43\n3.1.5  Paxos协议实现\t52\n3.2  Hypertable\t55\n3.2.1  概述\t55\n3.2.2  算法实现\t57\n小结\t58\n第4章ZooKeeper与Paxos\t59\n4.1  初识ZooKeeper\t59\n4.1.1  ZooKeeper介绍\t59\n4.1.2  ZooKeeper从何而来\t62\n4.1.3  ZooKeeper的基本概念\t62\n4.1.4  为什么选择ZooKeeper\t64\n4.2  ZooKeeper的ZAB协议\t65\n4.2.1  ZAB协议\t65\n4.2.2  协议介绍\t66\n4.2.3  深入ZAB协议\t71\n4.2.4  ZAB与Paxos算法的联系与区别\t77\n小结\t78\n第5章使用ZooKeeper\t79\n5.1  部署与运行\t79\n5.1.1  系统环境\t79\n5.1.2  集群与单机\t80\n5.1.3  运行服务\t84\n5.2  客户端脚本\t88\n5.2.1  创建\t88\n5.2.2  读取\t89\n5.2.3  更新\t90\n5.2.4  删除\t91\n5.3  Java客户端API使用\t91\n5.3.1  创建会话\t91\n5.3.2  创建节点\t95\n5.3.3  删除节点\t99\n5.3.4  读取数据\t100\n5.3.5  更新数据\t109\n5.3.6  检测节点是否存在\t113\n5.3.7  权限控制\t115\n5.4  开源客户端\t120\n5.4.1  ZkClient\t120\n5.4.2  Curator\t130\n小结\t162\n第6章ZooKeeper的典型应用场景\t163\n6.1  典型应用场景及实现注\t163\n6.1.1  数据发布/订阅\t164\n6.1.2  负载均衡\t166\n6.1.3  命名服务\t170\n6.1.4  分布式协调/通知\t173\n6.1.5  集群管理\t179\n6.1.6  Master选举\t185\n6.1.7  分布式锁\t188\n6.1.8  分布式队列\t194\n小结\t197\n6.2  ZooKeeper在大型分布式系统中的应用\t197\n6.2.1  Hadoop\t198\n6.2.2  HBase\t203\n6.2.3  Kafka\t207\n6.3  ZooKeeper在阿里巴巴的实践与应用\t213\n6.3.1  案例一消息中间件：Metamorphosis\t213\n6.3.2  案例二  RPC服务框架：Dubbo\t217\n6.3.3  案例三基于MySQL Binlog的增量订阅和消费组件：Canal\t219\n6.3.4  案例四分布式数据库同步系统：Otter\t223\n6.3.5  案例五轻量级分布式通用搜索平台：终搜\t226\n6.3.6  案例六实时计算引擎：JStorm\t238\n小结\t242\n第7章ZooKeeper技术内幕\t243\n7.1  系统模型\t243\n7.1.1  数据模型\t243\n7.1.2  节点特性\t244\n7.1.3  版本——保证分布式数据原子性操作\t246\n7.1.4  Watcher——数据变更的通知\t249\n7.1.5  ACL——保障数据的安全\t265\n7.2  序列化与协议\t272\n7.2.1  Jute介绍\t272\n7.2.2  使用Jute进行序列化\t273\n7.2.3  深入Jute\t275\n7.2.4  通信协议\t277\n7.3  客户端\t284\n7.3.1  一次会话的创建过程\t286\n7.3.2  服务器地址列表\t289\n7.3.3  ClientCnxn：网络I/O\t295\n7.4  会话\t298\n7.4.1  会话状态\t298\n7.4.2  会话创建\t299\n7.4.3  会话管理\t304\n7.4.4  会话清理\t307\n7.4.5  重连\t309\n7.5  服务器启动\t311\n7.5.1  单机版服务器启动\t312\n7.5.2  集群版服务器启动\t315\n7.6  Leader选举\t321\n7.6.1  Leader选举概述\t321\n7.6.2  Leader选举的算法分析\t323\n7.6.3  Leader选举的实现细节\t328\n7.7  各服务器角色介绍\t335\n7.7.1  Leader\t335\n7.7.2  Follower\t338\n7.7.3  Observer\t339\n7.7.4  集群间消息通信\t339\n7.8  请求处理\t342\n7.8.1  会话创建请求\t343\n7.8.2  SetData请求\t351\n7.8.3  事务请求转发\t354\n7.8.4  GetData请求\t355\n7.9  数据与存储\t356\n7.9.1  内存数据\t356\n7.9.2  事务日志\t358\n7.9.3  snapshot——数据快照\t364\n7.9.4  初始化\t368\n7.9.5  数据同步\t372\n小结\t376\n第8章ZooKeeper运维\t379\n8.1  配置详解\t379\n8.1.1  基本配置\t379\n8.1.2  高级配置\t380\n8.2  四字命令\t384\n8.3  JMX\t390\n8.3.1  开启远程JMX\t390\n8.3.2  通过JConsole连接ZooKeeper\t391\n8.4  监控\t397\n8.4.1  实时监控\t397\n8.4.2  数据统计\t398\n8.5  构建一个高可用的集群\t398\n8.5.1  集群组成\t398\n8.5.2  容灾\t399\n8.5.3  扩容与缩容\t402\n8.6  日常运维\t402\n8.6.1  数据与日志管理\t402\n8.6.2  Too many connections\t404\n8.6.3  磁盘管理\t405\n小结\t405\n附录AWindows平台上部署ZooKeeper\t406\n附录B从源代码开始构建\t409\n附录C各发行版本重大更新记录\t414\n附录DZooKeeper源代码阅读指引\t418","pages":"422","images":{"small":"https://img1.doubanio.com/view/subject/s/public/s28377338.jpg","large":"https://img1.doubanio.com/view/subject/l/public/s28377338.jpg","medium":"https://img1.doubanio.com/view/subject/m/public/s28377338.jpg"},"alt":"https://book.douban.com/subject/26292004/","id":"26292004","publisher":"电子工业出版社","isbn10":"7121249677","isbn13":"9787121249679","title":"从Paxos到Zookeeper","url":"https://api.douban.com/v2/book/26292004","alt_title":"","author_intro":"倪超，阿里巴巴集团高级研发工程师，国家认证系统分析师，毕业于杭州电子科技大学计算机系。2010年加入阿里巴巴中间件团队担任研发实习岗位，一直从事ZooKeeper的开发与运维工作，从中学习与总结了不少分布式一致性相关的理论与实践经验，尤其对ZooKeeper及其相关技术有非常深入的研究。目前在中间件团队专家组任职产品经理，负责分布式产品的产品化和云计算化改造工作。\n新浪微博：@ni掌柜","summary":"《Paxos到Zookeeper：分布式一致性原理与实践》从分布式一致性的理论出发，向读者简要介绍几种典型的分布式一致性协议，以及解决分布式一致性问题的思路，其中重点讲解了Paxos和ZAB协议。同时，本书深入介绍了分布式一致性问题的工业解决方案——ZooKeeper，并着重向读者展示这一分布式协调框架的使用方法、内部实现及运维技巧，旨在帮助读者全面了解ZooKeeper，并更好地使用和运维ZooKeeper。全书共8章，分为五部分：第一部分（第1章）主要介绍了计算机系统从集中式向分布式系统演变过程中面临的挑战，并简要介绍了ACID、CAP和BASE等经典分布式理论；第二部分（第2～4章）介绍了2PC、3PC和Paxos三种分布式一致性协议，并着重讲解了ZooKeeper中使用的一致性协议——ZAB协议；第三部分（第5～6章）介绍了ZooKeeper的使用方法，包括客户端API的使用以及对ZooKeeper服务的部署与运行，并结合真实的分布式应用场景，总结了ZooKeeper使用的最佳实践；第四部分（第7章）对ZooKeeper的架构设计和实现原理进行了深入分析，包含系统模型、Leader选举、客户端与服务端的工作原理、请求处理，以及服务器角色的工作流程和数据存储等；第五部分（第8章）介绍了ZooKeeper的运维实践，包括配置详解和监控管理等，重点讲解了如何构建一个高可用的ZooKeeper服务。","price":"75.00元"},"9787121212000":{"rating":{"max":10,"numRaters":1329,"average":"7.9","min":0},"subtitle":"核心原理与案例分析","author":["李智慧"],"pubdate":"2013-9-1","tags":[{"count":1183,"name":"架构","title":"架构"},{"count":606,"name":"互联网","title":"互联网"},{"count":443,"name":"Web","title":"Web"},{"count":328,"name":"计算机","title":"计算机"},{"count":266,"name":"网站","title":"网站"},{"count":197,"name":"服务器","title":"服务器"},{"count":192,"name":"Web开发","title":"Web开发"},{"count":159,"name":"软件开发","title":"软件开发"}],"origin_title":"","image":"https://img3.doubanio.com/view/subject/m/public/s27250675.jpg","binding":"平装","translator":[],"catalog":"第1篇  概述\n1      大型网站架构演化\t2\n1.1  大型网站软件系统的特点\t3\n1.2  大型网站架构演化发展历程\t4\n1.2.1  初始阶段的网站架构\t4\n1.2.2  应用服务和数据服务分离\t4\n1.2.3  使用缓存改善网站性能\t5\n1.2.4  使用应用服务器集群改善网站的并发处理能力\t6\n1.2.5  数据库读写分离\t7\n1.2.6  使用反向代理和CDN加速网站响应\t8\n1.2.7  使用分布式文件系统和分布式数据库系统\t9\n1.2.8  使用NoSQL和搜索引擎\t10\n1.2.9  业务拆分\t11\n1.2.10  分布式服务\t11\n1.3  大型网站架构演化的价值观\t13\n1.3.1  大型网站架构技术的核心价值是随网站所需灵活应对\t13\n1.3.2  驱动大型网站技术发展的主要力量是网站的业务发展\t13\n1.4  网站架构设计误区\t14\n1.4.1  一味追随大公司的解决方案\t14\n1.4.2  为了技术而技术\t14\n1.4.3  企图用技术解决所有问题\t14\n1.5  小结\t15\n2      大型网站架构模式\t16\n2.1  网站架构模式\t16\n2.1.1  分层\t17\n2.1.2  分割\t18\n2.1.3  分布式\t18\n2.1.4  集群\t19\n2.1.5  缓存\t20\n2.1.6  异步\t20\n2.1.7  冗余\t21\n2.1.8  自动化\t22\n2.1.9  安全\t23\n2.2  架构模式在新浪微博的应用\t23\n2.3  小结\t25\n3      大型网站核心架构要素\t26\n3.1  性能\t27\n3.2  可用性\t28\n3.3  伸缩性\t29\n3.4  扩展性\t30\n3.5  安全性\t30\n3.6  小结\t31\n第2篇  架构\n4      瞬时响应：网站的高性能架构\t34\n4.1  网站性能测试\t35\n4.1.1  不同视角下的网站性能\t35\n4.1.2  性能测试指标\t36\n4.1.3  性能测试方法\t39\n4.1.4  性能测试报告\t41\n4.1.5  性能优化策略\t41\n4.2  Web前端性能优化\t42\n4.2.1  浏览器访问优化\t42\n4.2.2  CDN加速\t43\n4.2.3  反向代理\t44\n4.3  应用服务器性能优化\t45\n4.3.1  分布式缓存\t45\n4.3.2  异步操作\t52\n4.3.3  使用集群\t53\n4.3.4  代码优化\t54\n4.4  存储性能优化\t58\n4.4.1  机械硬盘vs. 固态硬盘\t58\n4.4.2  B+树vs. LSM树\t59\n4.4.3  RAID vs. HDFS\t61\n4.5  小结\t64\n5      万无一失：网站的高可用架构\t66\n5.1  网站可用性的度量与考核\t67\n5.1.1  网站可用性度量\t67\n5.1.2  网站可用性考核\t67\n5.2  高可用的网站架构\t69\n5.3  高可用的应用\t71\n5.3.1  通过负载均衡进行无状态服务的失效转移\t72\n5.3.2  应用服务器集群的Session管理\t73\n5.4  高可用的服务\t76\n5.5  高可用的数据\t78\n5.5.1  CAP原理\t79\n5.5.2  数据备份\t82\n5.5.3  失效转移\t84\n5.6  高可用网站的软件质量保证\t85\n5.6.1  网站发布\t85\n5.6.2  自动化测试\t86\n5.6.3  预发布验证\t87\n5.6.4  代码控制\t88\n5.6.5  自动化发布\t90\n5.6.6  灰度发布\t91\n5.7  网站运行监控\t91\n5.7.1  监控数据采集\t92\n5.7.2  监控管理\t93\n5.8  小结\t94\n6      永无止境：网站的伸缩性架构\t95\n6.1  网站架构的伸缩性设计\t97\n6.1.1  不同功能进行物理分离实现伸缩\t97\n6.1.2  单一功能通过集群规模实现伸缩\t98\n6.2  应用服务器集群的伸缩性设计\t99\n6.2.1  HTTP重定向负载均衡\t100\n6.2.2  DNS域名解析负载均衡\t101\n6.2.3  反向代理负载均衡\t102\n6.2.4  IP负载均衡\t103\n6.2.5  数据链路层负载均衡\t104\n6.2.6  负载均衡算法\t105\n6.3  分布式缓存集群的伸缩性设计\t106\n6.3.1  Memcached分布式缓存集群的访问模型\t107\n6.3.2  Memcached分布式缓存集群的伸缩性挑战\t107\n6.3.3  分布式缓存的一致性Hash算法\t109\n6.4  数据存储服务器集群的伸缩性设计\t112\n6.4.1  关系数据库集群的伸缩性设计\t113\n6.4.2  NoSQL数据库的伸缩性设计\t117\n6.5  小结\t119\n7      随需应变：网站的可扩展架构\t121\n7.1  构建可扩展的网站架构\t122\n7.2  利用分布式消息队列降低系统耦合性\t123\n7.2.1  事件驱动架构\t123\n7.2.2  分布式消息队列\t124\n7.3  利用分布式服务打造可复用的业务平台\t126\n7.3.1  Web Service与企业级分布式服务\t128\n7.3.2  大型网站分布式服务的需求与特点\t129\n7.3.3  分布式服务框架设计\t130\n7.4  可扩展的数据结构\t131\n7.5  利用开放平台建设网站生态圈\t132\n7.6  小结\t134\n8      固若金汤：网站的安全架构\t135\n8.1  道高一尺魔高一丈的网站应用攻击与防御\t136\n8.1.1  XSS攻击\t136\n8.1.2  注入攻击\t138\n8.1.3  CSRF攻击\t139\n8.1.4  其他攻击和漏洞\t140\n8.1.5  Web应用防火墙\t141\n8.1.6  网站安全漏洞扫描\t142\n8.2  信息加密技术及密钥安全管理\t142\n8.2.1  单向散列加密\t143\n8.2.2  对称加密\t144\n8.2.3  非对称加密\t144\n8.2.4  密钥安全管理\t145\n8.3  信息过滤与反垃圾\t146\n8.3.1  文本匹配\t147\n8.3.2  分类算法\t148\n8.3.3  黑名单\t149\n8.4  电子商务风险控制\t150\n8.4.1  风险\t151\n8.4.2  风控\t151\n8.5  小结\t153\n第3篇  案例\n9      淘宝网的架构演化案例分析\t156\n9.1  淘宝网的业务发展历程\t157\n9.2  淘宝网技术架构演化\t158\n9.3  小结\t162\n10     维基百科的高性能架构设计分析\t163\n10.1  Wikipedia网站整体架构\t163\n10.2  Wikipedia性能优化策略\t165\n10.2.1  Wikipedia前端性能优化\t165\n10.2.2  Wikipedia服务端性能优化\t166\n10.2.3  Wikipedia后端性能优化\t167\n11     海量分布式存储系统Doris的高可用架构设计分析\t169\n11.1  分布式存储系统的高可用架构\t170\n11.2  不同故障情况下的高可用解决方案\t171\n11.2.1  分布式存储系统的故障分类\t172\n11.2.2  正常情况下系统访问结构\t172\n11.2.3  瞬时故障的高可用解决方案\t173\n11.2.4  临时故障的高可用解决方案\t174\n11.2.5  永久故障的高可用解决方案\t175\n12     网购秒杀系统架构设计案例分析\t176\n12.1  秒杀活动的技术挑战\t177\n12.2  秒杀系统的应对策略\t177\n12.3  秒杀系统架构设计\t178\n12.4  小结\t182\n13     大型网站典型故障案例分析\t183\n13.1  写日志也会引发故障\t184\n13.2  高并发访问数据库引发的故障\t184\n13.3  高并发情况下锁引发的故障\t185\n13.4  缓存引发的故障\t185\n13.5  应用启动不同步引发的故障\t186\n13.6  大文件读写独占磁盘引发的故障\t186\n13.7  滥用生产环境引发的故障\t187\n13.8  不规范的流程引发的故障\t187\n13.9  不好的编程习惯引发的故障\t188\n13.10  小结\t188\n第4篇  架构师\n14     架构师领导艺术\t190\n14.1  关注人而不是产品\t191\n14.2  发掘人的优秀\t191\n14.3  共享美好蓝图\t192\n14.4  共同参与架构\t193\n14.5  学会妥协\t194\n14.6  成就他人\t194\n15     网站架构师职场攻略\t196\n15.1  发现问题，寻找突破\t197\n15.2  提出问题，寻求支持\t199\n15.3  解决问题，达成绩效\t201\n16     漫话网站架构师\t203\n16.1  按作用划分架构师\t203\n16.2  按效果划分架构师\t204\n16.3  按职责角色划分架构师\t205\n16.4  按关注层次划分架构师\t205\n16.5  按口碑划分架构师\t206\n16.6  非主流方式划分架构师\t207\n附录A  大型网站架构技术一览\t208\n附录B  Web开发技术发展历程\t215\n后记\t218","ebook_url":"https://read.douban.com/ebook/35648299/","pages":"218","images":{"small":"https://img3.doubanio.com/view/subject/s/public/s27250675.jpg","large":"https://img3.doubanio.com/view/subject/l/public/s27250675.jpg","medium":"https://img3.doubanio.com/view/subject/m/public/s27250675.jpg"},"alt":"https://book.douban.com/subject/25723064/","id":"25723064","publisher":"电子工业出版社","isbn10":"7121212005","isbn13":"9787121212000","title":"大型网站技术架构","url":"https://api.douban.com/v2/book/25723064","alt_title":"","author_intro":"李智慧\n曾在阿里巴巴担任技术专家，参与阿里巴巴基础技术平台开发和www.alibaba.com架构设计。\n目前就职英特尔亚太研发中心从事云计算与大数据方面的研发工作。","summary":"《大型网站技术架构：核心原理与案例分析》通过梳理大型网站技术发展历程，剖析大型网站技术架构模式，深入讲述大型互联网架构设计的核心原理，并通过一组典型网站技术架构设计案例，为读者呈现一幅包括技术选型、架构设计、性能优化、Web 安全、系统发布、运维监控等在内的大型网站开发全景视图。\n《大型网站技术架构：核心原理与案例分析》不仅适用于指导网站工程师、架构师进行网站技术架构设计，也可用于指导产品经理、项目经理、测试运维人员等了解网站技术架构的基础概念；还可供包括企业系统开发人员在内的各类软件开发从业人员借鉴，了解大型网站的解决方案和开发理念。","ebook_price":"23.99","price":"59.00元"},"9787111430520":{"rating":{"max":10,"numRaters":381,"average":"7.9","min":0},"subtitle":"原理解析与架构实战","author":["杨传辉"],"pubdate":"2013-9-1","tags":[{"count":749,"name":"分布式","title":"分布式"},{"count":444,"name":"存储","title":"存储"},{"count":289,"name":"大数据","title":"大数据"},{"count":246,"name":"架构","title":"架构"},{"count":139,"name":"计算机","title":"计算机"},{"count":96,"name":"软件架构","title":"软件架构"},{"count":74,"name":"distributed-system","title":"distributed-system"},{"count":40,"name":"编程","title":"编程"}],"origin_title":"","image":"https://img3.doubanio.com/view/subject/m/public/s27043456.jpg","binding":"平装","translator":[],"catalog":"前言\n第1章　概述\n1.1　分布式存储概念\n1.2　分布式存储分类\n第一篇　基础篇\n第2章　单机存储系统\n2.1　硬件基础\n2.1.1　CPU架构\n2.1.2　IO总线\n2.1.3　网络拓扑\n2.1.4　性能参数\n2.1.5　存储层次架构\n2.2　单机存储引擎\n2.2.1　哈希存储引擎\n2.2.2　B树存储引擎\n2.2.3　LSM树存储引擎\n2.3　数据模型\n2.3.1　文件模型\n2.3.2　关系模型\n2.3.3　键值模型\n2.3.4　SQL与NoSQL\n2.4　事务与并发控制\n2.4.1　事务\n2.4.2　并发控制\n2.5　故障恢复\n2.5.1　操作日志\n2.5.2　重做日志\n2.5.3　优化手段\n2.6　数据压缩\n2.6.1　压缩算法\n2.6.2　列式存储\n第3章　分布式系统\n3.1　基本概念\n3.1.1　异常\n3.1.2　一致性\n3.1.3　衡量指标\n3.2　性能分析\n3.3　数据分布\n3.3.1　哈希分布\n3.3.2　顺序分布\n3.3.3　负载均衡\n3.4　复制\n3.4.1　复制的概述\n3.4.2　一致性与可用性\n3.5　容错\n3.5.1　常见故障\n3.5.2　故障检测\n3.5.3　故障恢复\n3.6　可扩展性\n3.6.1　总控节点\n3.6.2　数据库扩容\n3.6.3　异构系统\n3.7　分布式协议\n3.7.1　两阶段提交协议\n3.7.2　Paxos协议\n3.7.3　Paxos与2PC\n3.8　跨机房部署\n第二篇　范型篇\n第4章　分布式文件系统\n4.1　Google文件系统\n4.1.1　系统架构\n4.1.2　关键问题\n4.1.3　Master设计\n4.1.4　ChunkServer设计\n4.1.5　讨论\n4.2　Taobao File System\n4.2.1　系统架构\n4.2.2　讨论\n4.3　Facebook Haystack\n4.3.1　系统架构\n4.3.2　讨论\n4.4　内容分发网络\n4.4.1　CDN架构\n4.4.2　讨论\n第5章　分布式键值系统\n5.1　Amazon Dynamo\n5.1.1　数据分布\n5.1.2　一致性与复制\n5.1.3　容错\n5.1.4　负载均衡\n5.1.5　读写流程\n5.1.6　单机实现\n5.1.7　讨论\n5.2　淘宝Tair\n5.2.1　系统架构\n5.2.2　关键问题\n5.2.3　讨论\n第6章　分布式表格系统\n6.1　Google Bigtable\n6.1.1　架构\n6.1.2　数据分布\n6.1.3　复制与一致性\n6.1.4　容错\n6.1.5　负载均衡\n6.1.6　分裂与合并\n6.1.7　单机存储\n6.1.8　垃圾回收\n6.1.9　讨论\n6.2　Google Megastore\n6.2.1　系统架构\n6.2.2　实体组\n6.2.3　并发控制\n6.2.4　复制\n6.2.5　索引\n6.2.6　协调者\n6.2.7　读取流程\n6.2.8　写入流程\n6.2.9　讨论\n6.3　Windows Azure Storage\n6.3.1　整体架构\n6.3.2　文件流层\n6.3.3　分区层\n6.3.4　讨论\n第7章　分布式数据库\n7.1　数据库中间层\n7.1.1　架构\n7.1.2　扩容\n7.1.3　讨论\n7.2　Microsoft SQL Azure\n7.2.1　数据模型\n7.2.2　架构\n7.2.3　复制与一致性\n7.2.4　容错\n7.2.5　负载均衡\n7.2.6　多租户\n7.2.7　讨论\n7.3　Google Spanner\n7.3.1　数据模型\n7.3.2　架构\n7.3.3　复制与一致性\n7.3.4　TrueTime\n7.3.5　并发控制\n7.3.6　数据迁移\n7.3.7　讨论\n第三篇　实践篇\n第8章　OceanBase架构初探\n8.1　背景简介\n8.2　设计思路\n8.3　系统架构\n8.3.1　整体架构图\n8.3.2　客户端\n8.3.3　RootServer\n8.3.4　MergeServer\n8.3.5　ChunkServer\n8.3.6　UpdateServer\n8.3.7　定期合并&数据分发\n8.4　架构剖析\n8.4.1　一致性选择\n8.4.2　数据结构\n8.4.3　可靠性与可用性\n8.4.4　读写事务\n8.4.5　单点性能\n8.4.6　SSD支持\n8.4.7　数据正确性\n8.4.8　分层结构\n第9章　分布式存储引擎\n9.1　公共模块\n9.1.1　内存管理\n9.1.2　基础数据结构\n9.1.3　锁\n9.1.4　任务队列\n9.1.5　网络框架\n9.1.6　压缩与解压缩\n9.2　RootServer实现机制\n9.2.1　数据结构\n9.2.2　子表复制与负载均衡\n9.2.3　子表分裂与合并\n9.2.4　UpdateServer选主\n9.2.5　RootServer主备\n9.3　UpdateServer实现机制\n9.3.1　存储引擎\n9.3.2　任务模型\n9.3.3　主备同步\n9.4　ChunkServer实现机制\n9.4.1　子表管理\n9.4.2　SSTable\n9.4.3　缓存实现\n9.4.4　IO实现\n9.4.5　定期合并&数据分发\n9.4.6　定期合并限速\n9.5　消除更新瓶颈\n9.5.1　读写优化回顾\n9.5.2　数据旁路导入\n9.5.3　数据分区\n第10章　数据库功能\n10.1　整体结构\n10.2　只读事务\n10.2.1　物理操作符接口\n10.2.2　单表操作\n10.2.3　多表操作\n10.2.4　SQL执行本地化\n10.3　写事务\n10.3.1　写事务执行流程\n10.3.2　多版本并发控制\n10.4　OLAP业务支持\n10.4.1　并发查询\n10.4.2　列式存储\n10.5　特色功能\n10.5.1　大表左连接\n10.5.2　数据过期与批量删除\n第11章　质量保证、运维及实践\n11.1　质量保证\n11.1.1　RD开发\n11.1.2　QA测试\n11.1.3　试运行\n11.2　使用与运维\n11.2.1　使用\n11.2.2　运维\n11.3　应用\n11.3.1　收藏夹\n11.3.2　天猫评价\n11.3.3　直通车报表\n11.4　最佳实践\n11.4.1　系统发展路径\n11.4.2　人员成长\n11.4.3　系统设计\n11.4.4　系统实现\n11.4.5　使用与运维\n11.4.6　工程现象\n11.4.7　经验法则\n第四篇　专题篇\n第12章　云存储\n12.1　云存储的概念\n12.2　云存储的产品形态\n12.3　云存储技术\n12.4　云存储的核心优势\n12.5　云平台整体架构\n12.5.1　Amazon云平台\n12.5.2　Google云平台\n12.5.3　Microsoft云平台\n12.5.4　云平台架构\n12.6　云存储技术体系\n12.7　云存储安全\n第13章　大数据\n13.1　大数据的概念\n13.2　MapReduce\n13.3　MapReduce扩展\n13.3.1　Google Tenzing\n13.3.2　Microsoft Dryad\n13.3.3　Google Pregel\n13.4　流式计算\n13.4.1　原理\n13.4.2　Yahoo S4\n13.4.3　Twitter Storm\n13.5　实时分析\n13.5.1　MPP架构\n13.5.2　EMC Greenplum\n13.5.3　HP Vertica\n13.5.4　Google Dremel\n参考资料","ebook_url":"https://read.douban.com/ebook/10179010/","pages":"293","images":{"small":"https://img3.doubanio.com/view/subject/s/public/s27043456.jpg","large":"https://img3.doubanio.com/view/subject/l/public/s27043456.jpg","medium":"https://img3.doubanio.com/view/subject/m/public/s27043456.jpg"},"alt":"https://book.douban.com/subject/25723658/","id":"25723658","publisher":"机械工业出版社","isbn10":"7111430522","isbn13":"9787111430520","title":"大规模分布式存储系统","url":"https://api.douban.com/v2/book/25723658","alt_title":"","author_intro":"杨传辉，阿里巴巴高级技术专家，花名日照，OceanBase核心开发人员，对分布式系统的理论和工程实践有深刻理解。曾在百度作为核心成员参与类MapReduce系统、类Bigtable系统和百度分布式消息队列等底层基础设施架构工作。热衷于分布式存储和计算系统设计，乐于分享，有技术博客NosqlNotes。","summary":"《大规模分布式存储系统：原理解析与架构实战》是分布式系统领域的经典著作，由阿里巴巴高级技术专家“阿里日照”（OceanBase核心开发人员）撰写，阳振坤、章文嵩、杨卫华、汪源、余锋（褚霸）、赖春波等来自阿里、新浪、网易和百度的资深技术专家联袂推荐。理论方面，不仅讲解了大规模分布式存储系统的核心技术和基本原理，而且对谷歌、亚马逊、微软和阿里巴巴等国际型大互联网公司的大规模分布式存储系统进行了分析；实战方面，首先通过对阿里巴巴的分布式数据库OceanBase的实现细节的深入剖析完整地展示了大规模分布式存储系统的架构与设计过程，然后讲解了大规模分布式存储技术在云计算和大数据领域的实践与应用。\n《大规模分布式存储系统：原理解析与架构实战》内容分为四个部分：基础篇——分布式存储系统的基础知识，包含单机存储系统的知识，如数据模型、事务与并发控制、故障恢复、存储引擎、压缩/解压缩等；分布式系统的数据分布、复制、一致性、容错、可扩展性等。范型篇——介绍谷歌、亚马逊、微软、阿里巴巴等著名互联网公司的大规模分布式存储系统架构，涉及分布式文件系统、分布式键值系统、分布式表格系统以及分布式数据库技术等。实践篇——以阿里巴巴的分布式数据库OceanBase为例，详细介绍分布式数据库内部实现，以及实践过程中的经验。专题篇——介绍分布式系统的主要应用：云存储和大数据，这些是近年来的热门领域，本书介绍了云存储平台、技术与安全，以及大数据的概念、流式计算、实时分析等。","ebook_price":"25.00","series":{"id":"19432","title":"大数据技术丛书"},"price":"59"},"9787115420268":{"rating":{"max":10,"numRaters":502,"average":"8.2","min":0},"subtitle":"","author":["[英] Sam Newman"],"pubdate":"2016-5","tags":[{"count":493,"name":"微服务","title":"微服务"},{"count":329,"name":"架构","title":"架构"},{"count":233,"name":"软件架构","title":"软件架构"},{"count":145,"name":"计算机","title":"计算机"},{"count":107,"name":"软件工程","title":"软件工程"},{"count":82,"name":"编程","title":"编程"},{"count":76,"name":"技术","title":"技术"},{"count":75,"name":"互联网","title":"互联网"}],"origin_title":"","image":"https://img1.doubanio.com/view/subject/m/public/s28626997.jpg","binding":"平装","translator":["崔力强","张　骏"],"catalog":"前言　　xiv\n第1章　微服务　　1\n1.1　什么是微服务　　2\n1.1.1　很小，专注于做好一件事　　2\n1.1.2　自治性　　3\n1.2　主要好处　　3\n1.2.1　技术异构性　　3\n1.2.2　弹性　　4\n1.2.3　扩展　　5\n1.2.4　简化部署　　5\n1.2.5　与组织结构相匹配　　6\n1.2.6　可组合性　　6\n1.2.7　对可替代性的优化　　6\n1.3　面向服务的架构　　7\n1.4　其他分解技术　　7\n1.4.1　共享库　　8\n1.4.2　模块　　8\n1.5　没有银弹　　9\n1.6　小结　　10\n第2章　演化式架构师　　11\n2.1　不准确的比较　　11\n2.2　架构师的演化视角　　12\n2.3　分区　　14\n2.4　一个原则性的方法　　15\n2.4.1　战略目标　　15\n2.4.2　原则　　15\n2.4.3　实践　　16\n2.4.4　将原则和实践相结合　　16\n2.4.5　真实世界的例子　　16\n2.5　要求的标准　　17\n2.5.1　监控　　18\n2.5.2　接口　　18\n2.5.3　架构安全性　　18\n2.6　代码治理　　18\n2.6.1　范例　　19\n2.6.2　裁剪服务代码模板　　19\n2.7　技术债务　　20\n2.8　例外管理　　21\n2.9　集中治理和领导　　21\n2.10　建设团队　　22\n2.11　小结　　23\n第3章　如何建模服务　　24\n3.1　MusicCorp简介　　24\n3.2　什么样的服务是好服务　　25\n3.2.1　松耦合　　25\n3.2.2　高内聚　　25\n3.3　限界上下文　　26\n3.3.1　共享的隐藏模型　　26\n3.3.2　模块和服务　　27\n3.3.3　过早划分　　28\n3.4　业务功能　　28\n3.5　逐步划分上下文　　29\n3.6　关于业务概念的沟通　　30\n3.7　技术边界　　30\n3.8　小结　　31\n第4章　集成　　32\n4.1　寻找理想的集成技术　　32\n4.1.1　避免破坏性修改　　32\n4.1.2　保证API的技术无关性　　32\n4.1.3　使你的服务易于消费方使用　　33\n4.1.4　隐藏内部实现细节　　33\n4.2　为用户创建接口　　33\n4.3　共享数据库　　33\n4.4　同步与异步　　35\n4.5　编排与协同　　35\n4.6　远程过程调用　　38\n4.6.1　技术的耦合　　38\n4.6.2　本地调用和远程调用并不相同　　39\n4.6.3　脆弱性　　39\n4.6.4　RPC很糟糕吗　　40\n4.7　REST　　41\n4.7.1　REST和HTTP　　41\n4.7.2　超媒体作为程序状态的引擎　　42\n4.7.3　JSON、XML还是其他　　44\n4.7.4　留心过多的约定　　44\n4.7.5　基于HTTP的REST的缺点　　45\n4.8　实现基于事件的异步协作方式　　46\n4.8.1　技术选择　　46\n4.8.2　异步架构的复杂性　　47\n4.9　服务即状态机　　48\n4.10　响应式扩展　　48\n4.11　微服务世界中的DRY和代码重用的危险　　49\n4.12　按引用访问　　50\n4.13　版本管理　　51\n4.13.1　尽可能推迟　　51\n4.13.2　及早发现破坏性修改　　52\n4.13.3　使用语义化的版本管理　　53\n4.13.4　不同的接口共存　　53\n4.13.5　同时使用多个版本的服务　　54\n4.14　用户界面　　55\n4.14.1　走向数字化　　56\n4.14.2　约束　　56\n4.14.3　API组合　　57\n4.14.4　UI片段的组合　　57\n4.14.5　为前端服务的后端　　59\n4.14.6　一种混合方式　　60\n4.15　与第三方软件集成　　61\n4.15.1　缺乏控制　　61\n4.15.2　定制化　　62\n4.15.3　意大利面式的集成　　62\n4.15.4　在自己可控的平台进行定制化　　62\n4.15.5　绞杀者模式　　64\n4.16　小结　　65\n第5章　分解单块系统　　66\n5.1　关键是接缝　　66\n5.2　分解MusicCorp　　67\n5.3　分解单块系统的原因　　68\n5.3.1　改变的速度　　68\n5.3.2　团队结构　　68\n5.3.3　安全　　68\n5.3.4　技术　　68\n5.4　杂乱的依赖　　69\n5.5　数据库　　69\n5.6　找到问题的关键　　69\n5.7　例子：打破外键关系　　70\n5.8　例子：共享静态数据　　71\n5.9　例子：共享数据　　72\n5.10　例子：共享表　　73\n5.11　重构数据库　　74\n5.12　事务边界　　75\n5.12.1　再试一次　　76\n5.12.2　终止整个操作　　77\n5.12.3　分布式事务　　77\n5.12.4　应该怎么办呢　　78\n5.13　报告　　78\n5.14　报告数据库　　78\n5.15　通过服务调用来获取数据　　80\n5.16　数据导出　　81\n5.17　事件数据导出　　82\n5.18　数据导出的备份　　83\n5.19　走向实时　　84\n5.20　修改的代价　　84\n5.21　理解根本原因　　84\n5.22　小结　　85\n第6章　部署　　86\n6.1　持续集成简介　　86\n6.2　把持续集成映射到微服务　　87\n6.3　构建流水线和持续交付　　90\n6.4　平台特定的构建物　　91\n6.5　操作系统构建物　　92\n6.6　定制化镜像　　93\n6.6.1　将镜像作为构建物　　94\n6.6.2　不可变服务器　　95\n6.7　环境　　95\n6.8　服务配置　　96\n6.9　服务与主机之间的映射　　97\n6.9.1　单主机多服务　　97\n6.9.2　应用程序容器　　99\n6.9.3　每个主机一个服务　　100\n6.9.4　平台即服务　　101\n6.10　自动化　　101\n6.11　从物理机到虚拟机　　102\n6.11.1　传统的虚拟化技术　　103\n6.11.2　Vagrant　　104\n6.11.3　Linux容器　　104\n6.11.4　Docker　　106\n6.12　一个部署接口　　107\n6.13　小结　　109\n第7章　测试　　110\n7.1　测试类型　　110\n7.2　测试范围　　111\n7.2.1　单元测试　　112\n7.2.2　服务测试　　113\n7.2.3　端到端测试　　114\n7.2.4　权衡　　114\n7.2.5　比例　　115\n7.3　实现服务测试　　115\n7.3.1　mock还是打桩　　115\n7.3.2　智能的打桩服务　　116\n7.4　微妙的端到端测试　　117\n7.5　端到端测试的缺点　　118\n7.6　脆弱的测试　　118\n7.6.1　谁来写这些测试　　119\n7.6.2　测试多长时间　　119\n7.6.3　大量的堆积　　120\n7.6.4　元版本　　120\n7.7　测试场景，而不是故事　　121\n7.8　拯救消费者驱动的测试　　121\n7.8.1　Pact　　123\n7.8.2　关于沟通　　124\n7.9　还应该使用端到端测试吗　　124\n7.10　部署后再测试　　125\n7.10.1　区分部署和上线　　125\n7.10.2　金丝雀发布　　126\n7.10.3　平均修复时间胜过平均故障间隔时间　　127\n7.11　跨功能的测试　　128\n7.12　小结　　129\n第8章　监控　　131\n8.1　单一服务，单一服务器　　132\n8.2　单一服务，多个服务器　　132\n8.3　多个服务，多个服务器　　133\n8.4　日志，日志，更多的日志　　134\n8.5　多个服务的指标跟踪　　135\n8.6　服务指标　　135\n8.7　综合监控　　136\n8.8　关联标识　　137\n8.9　级联　　139\n8.10　标准化　　139\n8.11　考虑受众　　140\n8.12　未来　　140\n8.13　小结　　141\n第9章　安全　　143\n9.1　身份验证和授权　　143\n9.1.1　常见的单点登录实现　　144\n9.1.2　单点登录网关　　145\n9.1.3　细粒度的授权　　146\n9.2　服务间的身份验证和授权　　146\n9.2.1　在边界内允许一切　　146\n9.2.2　HTTP(S) 基本身份验证　　147\n9.2.3　使用SAML或OpenID Connect　　148\n9.2.4　客户端证书　　148\n9.2.5　HTTP之上的HMAC　　149\n9.2.6　API密钥　　149\n9.2.7　代理问题　　150\n9.3　静态数据的安全　　152\n9.3.1　使用众所周知的加密算法　　152\n9.3.2　一切皆与密钥相关　　153\n9.3.3　选择你的目标　　153\n9.3.4　按需解密　　153\n9.3.5　加密备份　　153\n9.4　深度防御　　154\n9.4.1　防火墙　　154\n9.4.2　日志　　154\n9.4.3　入侵检测（和预防）系统　　154\n9.4.4　网络隔离　　155\n9.4.5　操作系统　　155\n9.5　一个示例　　156\n9.6　保持节俭　　158\n9.7　人的因素　　158\n9.8　黄金法则　　158\n9.9　内建安全　　159\n9.10　外部验证　　159\n9.11　小结　　159\n第10章　康威定律和系统设计　　161\n10.1　证据　　161\n10.1.1　松耦合组织和紧耦合组织　　162\n10.1.2　Windows Vista　　162\n10.2　Netflix和Amazon　　162\n10.3　我们可以做什么　　163\n10.4　适应沟通途径　　163\n10.5　服务所有权　　164\n10.6　共享服务的原因　　164\n10.6.1　难以分割　　164\n10.6.2　特性团队　　164\n10.6.3　交付瓶颈　　165\n10.7　内部开源　　166\n10.7.1　守护者的角色　　166\n10.7.2　成熟　　166\n10.7.3　工具　　167\n10.8　限界上下文和团队结构　　167\n10.9　孤儿服务　　167\n10.10　案例研究：RealEstate.com.au　　168\n10.11　反向的康威定律　　169\n10.12　人　　170\n10.13　小结　　170\n第11章　规模化微服务　　171\n11.1　故障无处不在　　171\n11.2　多少是太多　　172\n11.3　功能降级　　173\n11.4　架构性安全措施　　174\n11.5　反脆弱的组织　　175\n11.5.1　超时　　176\n11.5.2　断路器　　176\n11.5.3　舱壁　　178\n11.5.4　隔离　　179\n11.6　幂等　　179\n11.7　扩展　　180\n11.7.1　更强大的主机　　181\n11.7.2　拆分负载　　181\n11.7.3　分散风险　　181\n11.7.4　负载均衡　　182\n11.7.5　基于worker的系统　　184\n11.7.6　重新设计　　184\n11.8　扩展数据库　　185\n11.8.1　服务的可用性和数据的持久性　　185\n11.8.2　扩展读取　　185\n11.8.3　扩展写操作　　186\n11.8.4　共享数据库基础设施　　187\n11.8.5　CQRS　　187\n11.9　缓存　　188\n11.9.1　客户端、 代理和服务器端缓存　　188\n11.9.2　HTTP缓存　　189\n11.9.3　为写使用缓存　　190\n11.9.4　为弹性使用缓存　　190\n11.9.5　隐藏源服务　　191\n11.9.6　保持简单　　191\n11.9.7　缓存中毒：一个警示　　192\n11.10　自动伸缩　　192\n11.11　CAP定理　　193\n11.11.1　牺牲一致性　　194\n11.11.2　牺牲可用性　　195\n11.11.3　牺牲分区容忍性　　195\n11.11.4　AP还是CP　　196\n11.11.5　这不是全部或全不　　196\n11.11.6　真实世界　　197\n11.12　服务发现　　197\n11.13　动态服务注册　　199\n11.13.1　Zookeeper　　199\n11.13.2　Consul　　200\n11.13.4　构造你自己的系统　　201\n11.13.5　别忘了人　　201\n11.14　文档服务　　201\n11.14.1　Swagger　　202\n11.14.2　HAL 和HAL浏览器　　202\n11.15　自描述系统　　203\n11.16　小结　　203\n第12章　总结　　204\n12.1　微服务的原则　　204\n12.1.1　围绕业务概念建模　　205\n12.1.2　接受自动化文化　　205\n12.1.3　隐藏内部实现细节　　205\n12.1.4　让一切都去中心化　　206\n12.1.5　可独立部署　　206\n12.1.6　隔离失败　　206\n12.1.7　高度可观察　　207\n12.2　什么时候你不应该使用微服务　　207\n12.3　临别赠言　　208\n关于作者　　209\n关于封面　　209","ebook_url":"https://read.douban.com/ebook/52188224/","pages":"228","images":{"small":"https://img1.doubanio.com/view/subject/s/public/s28626997.jpg","large":"https://img1.doubanio.com/view/subject/l/public/s28626997.jpg","medium":"https://img1.doubanio.com/view/subject/m/public/s28626997.jpg"},"alt":"https://book.douban.com/subject/26772677/","id":"26772677","publisher":"人民邮电出版社","isbn10":"7115420262","isbn13":"9787115420268","title":"微服务设计","url":"https://api.douban.com/v2/book/26772677","alt_title":"","author_intro":"作者简介：\nSam Newman\n是ThoughtWorks公司的技术专家、ThoughtWorks内部系统架构师，同时还为全球的客户提供咨询服务。他在开发和IT运维方面与全球多个领域的公司有过合作。\n译者简介：\n崔力强\n阿里巴巴技术专家，目前专注于持续交付相关的产品开发。曾在ThoughtWorks任职多年，从事软件定制开发、敏捷软件开发的相关咨询等工作，帮助过数个团队和项目进行精益需求管理、软件设计、自动化测试和持续集成等实践。微信号：blade_1986\n张骏\n2010年加入ThoughtWorks公司。作为开发人员、项目经理、资深敏捷教练和资深咨询师，在金融、电信和能源服务行业的大型复杂业务系统的设计、开发、管理、咨询等方面有丰富的经验。曾为国内外诸多客户提供软件设计、开发以及咨询服务。拥有10年工作经验，在Scrum、看板、规模化敏捷等方法论，以及精益需求管理、自动化测试、持续集成、领域驱动设计、微服务等具体实践方面都有丰富的积累。微信号：zhangjun695339","summary":"本书全面介绍了微服务的建模、集成、测试、部署和监控，通过一个虚构的公司讲解了如何建立微服务架构。主要内容包括认识微服务在保证系统设计与组织目标统一上的重要性，学会把服务集成到已有系统中，采用递增手段拆分单块大型应用，通过持续集成部署微服务，等等。","ebook_price":"29.99","price":"69.00元"},"9787111526285":{"rating":{"max":10,"numRaters":58,"average":"9.3","min":0},"subtitle":"","author":["艾伦A.A.多诺万 (Alan A.A.Donovan)","布莱恩W.柯尼汉 (Brian W.Kemighan)"],"pubdate":"2016-1-1","tags":[{"count":48,"name":"Go","title":"Go"},{"count":38,"name":"golang","title":"golang"},{"count":25,"name":"编程","title":"编程"},{"count":19,"name":"计算机","title":"计算机"},{"count":19,"name":"编程语言","title":"编程语言"},{"count":13,"name":"软件开发","title":"软件开发"},{"count":7,"name":"Programming","title":"Programming"},{"count":6,"name":"程序设计","title":"程序设计"}],"origin_title":"","image":"https://img3.doubanio.com/view/subject/m/public/s29140891.jpg","binding":"平装","translator":[],"catalog":"","pages":"366","images":{"small":"https://img3.doubanio.com/view/subject/s/public/s29140891.jpg","large":"https://img3.doubanio.com/view/subject/l/public/s29140891.jpg","medium":"https://img3.doubanio.com/view/subject/m/public/s29140891.jpg"},"alt":"https://book.douban.com/subject/26859123/","id":"26859123","publisher":"机械工业出版社","isbn10":"7111526287","isbn13":"9787111526285","title":"Go程序设计语言(英文版)","url":"https://api.douban.com/v2/book/26859123","alt_title":"","author_intro":"","summary":"","price":"CNY 79.00"},"9787115445353":{"rating":{"max":10,"numRaters":172,"average":"7.7","min":0},"subtitle":"","author":["威廉·肯尼迪 (William Kennedy)","布赖恩·克特森 (Brian Ketelsen)","埃里克·圣马丁 (Erik St.Martin)"],"pubdate":"2017-3-1","tags":[{"count":94,"name":"Go","title":"Go"},{"count":80,"name":"Golang","title":"Golang"},{"count":54,"name":"编程","title":"编程"},{"count":40,"name":"编程语言","title":"编程语言"},{"count":31,"name":"计算机","title":"计算机"},{"count":22,"name":"计算机科学","title":"计算机科学"},{"count":22,"name":"Programming","title":"Programming"},{"count":16,"name":"开发","title":"开发"}],"origin_title":"","image":"https://img3.doubanio.com/view/subject/m/public/s29439084.jpg","binding":"平装","translator":["李兆海"],"catalog":"第1章　关于Go语言的介绍　1\n1．1　用Go解决现代编程难题　2\n1．1．1　开发速度　2\n1．1．2　并发　3\n1．1．3　Go语言的类型系统　5\n1．1．4　内存管理　7\n1．2　你好，Go　7\n1．3　小结　8\n第2章　快速开始一个Go程序　9\n2．1　程序架构　9\n2．2　main包　11\n2．3　search包　13\n2．3．1　search．go　13\n2．3．2　feed．go　21\n2．3．3　match．go default．go　24\n2．4　RSS匹配器　30\n2．5　小结　36\n第3章　打包和工具链　37\n3．1　包　37\n3．1．1　包名惯例　38\n3．1．2　main包　38\n3．2　导入　39\n3．2．1　远程导入　40\n3．2．2　命名导入　40\n3．3　函数init　41\n3．4　使用Go的工具　42\n3．5　进一步介绍Go开发工具　44\n3．5．1　go vet　44\n3．5．2　Go代码格式化　45\n3．5．3　Go语言的文档　45\n3．6　与其他Go开发者合作　48\n3．7　依赖管理　48\n3．7．1　第三方依赖　49\n3．7．2　对gb的介绍　50\n3．8　小结　52\n第4章　数组、切片和映射　53\n4．1　数组的内部实现和基础功能　53\n4．1．1　内部实现　53\n4．1．2　声明和初始化　54\n4．1．3　使用数组　55\n4．1．4　多维数组　58\n4．1．5　在函数间传递数组　59\n4．2　切片的内部实现和基础功能　60\n4．2．1　内部实现　60\n4．2．2　创建和初始化　61\n4．2．3　使用切片　63\n4．2．4　多维切片　74\n4．2．5　在函数间传递切片　75\n4．3　映射的内部实现和基础功能　76\n4．3．1　内部实现　76\n4．3．2　创建和初始化　78\n4．3．3　使用映射　79\n4．3．4　在函数间传递映射　81\n4．4　小结　82\n第5章　Go语言的类型系统　83\n5．1　用户定义的类型　83\n5．2　方法　87\n5．3　类型的本质　90\n5．3．1　内置类型　91\n5．3．2　引用类型　91\n5．3．3　结构类型　93\n5．4　接口　95\n5．4．1　标准库　96\n5．4．2　实现　98\n5．4．3　方法集　99\n5．4．4　多态　103\n5．5　嵌入类型　105\n5．6　公开或未公开的标识符　113\n5．7　小结　121\n第6章　并发　122\n6．1　并发与并行　122\n6．2　goroutine　125\n6．3　竞争状态　132\n6．4　锁住共享资源　135\n6．4．1　原子函数　135\n6．4．2　互斥锁　138\n6．5　通道　140\n6．5．1　无缓冲的通道　141\n6．5．2　有缓冲的通道　146\n6．6　小结　149\n第7章　并发模式　150\n7．1　runner　150\n7．2　pool　158\n7．3　work　168\n7．4　小结　174\n第8章　标准库　176\n8．1　文档与源代码　177\n8．2　记录日志　178\n8．2．1　log包　179\n8．2．2　定制的日志记录器　182\n8．2．3　结论　186\n8．3　编码 解码　187\n8．3．1　解码JSON　187\n8．3．2　编码JSON　192\n8．3．3　结论　193\n8．4　输入和输出　193\n8．4．1　Writer和Reader接口　194\n8．4．2　整合并完成工作　195\n8．4．3　简单的curl　199\n8．4．4　结论　200\n8．5　小结　200\n第9章　测试和性能　201\n9．1　单元测试　201\n9．1．1　基础单元测试　202\n9．1．2　表组测试　205\n9．1．3　模仿调用　208\n9．1．4　测试服务端点　212\n9．2　示例　217\n9．3　基准测试　220\n9．4　小结　224","pages":"224","images":{"small":"https://img3.doubanio.com/view/subject/s/public/s29439084.jpg","large":"https://img3.doubanio.com/view/subject/l/public/s29439084.jpg","medium":"https://img3.doubanio.com/view/subject/m/public/s29439084.jpg"},"alt":"https://book.douban.com/subject/27015617/","id":"27015617","publisher":"人民邮电出版社","isbn10":"7115445354","isbn13":"9787115445353","title":"Go语言实战","url":"https://api.douban.com/v2/book/27015617","alt_title":"","author_intro":"William Kennedy，是一位熟练的软件开发者，也是博客GoingGo.Net的作者。\nBrian Ketelsen和Erik St. Martin是全球Go语言大会GopherCon的组织者，也是Go语言框架Skynet的联合作者。\n李兆海，多年专注于后端分布式网络服务开发，曾使用过多个流行后端技术和相关架构实践，是Go语言和Docker的早期使用者和推广者，《第1本Docker书》的译者。作为项目技术负责人，成功开发了百万用户级直播系统。","summary":"Go语言结合了底层系统语言的能力以及现代语言的高级特性，旨在降低构建简单、可靠、高效软件的门槛。本书向读者提供一个专注、全面且符合语言习惯的视角。Go语言实战同时关注语言的规范和实现，涉及的内容包括语法、类型系统、并发、管道、测试，以及其他一些主题。","price":"CNY 59.00"},"9787121328428":{"rating":{"max":10,"numRaters":29,"average":"9.4","min":0},"subtitle":"","author":["【德】Martin Odersky（马丁.奥德斯基）","【美】Lex Spoon（莱·斯彭）","【美】Bill Venners（比尔·凡纳斯）"],"pubdate":"2018-1-1","tags":[{"count":30,"name":"Scala","title":"Scala"},{"count":13,"name":"计算机","title":"计算机"},{"count":12,"name":"编程","title":"编程"},{"count":8,"name":"程序设计","title":"程序设计"},{"count":6,"name":"FP","title":"FP"},{"count":2,"name":"思维","title":"思维"},{"count":1,"name":"软件设计","title":"软件设计"},{"count":1,"name":"软件开发","title":"软件开发"}],"origin_title":"","image":"https://img3.doubanio.com/view/subject/m/public/s29620622.jpg","binding":"平装","translator":["高宇翔"],"catalog":"序.XXIV\n致谢.XXVI\n引言.XXIX\n第1章　一门可伸缩的语言.1\n1.1　一门按需伸缩的语言 2\n1.2　是什么让Scala能屈能伸？ 7\n1.3　为什么要用Scala？.11\n1.4　Scala寻根 17\n1.5　结语 19\n第2章　Scala入门 20\n第1步　使用Scala解释器 21\n第2步　定义变量 22\n第3步　定义函数 24\n第4步　编写Scala脚本 26\n第5步　用while做循环；用if做判断 27\n第6步　用foreach和for遍历 30\n结语 32\n第3章　Scala入门（续）.33\n第7步　用类型参数化数组 33\n第8步　使用列表 38\n第9步　使用元组 42\n第10步使用集和映射 43\n第11步　识别函数式编程风格 48\n第12步　从文件读取文本行 51\n结语 55\n第4章　类和对象.56\n4.1　类、字段和方法 56\n4.2　分号推断 61\n4.3　单例对象 62\n4.4　Scala应用程序 65\n4.5　App特质 68\n4.6　结语 68\n第5章　基础类型和操作69\n5.1　一些基础类型 69\n5.2　字面量 70\n5.3　字符串插值 77\n5.4　操作符即方法 78\n5.5　算术操作 81\n5.6　关系和逻辑操作 83\n5.7　位运算操作 85\n5.8　对象相等性 86\n5.9　操作符优先级和结合性 88\n5.10　富包装类 91\n5.11　结语 91\n第6章　函数式对象.93\n6.1　Rational类的规格定义 93\n6.2　构建Rational 94\n6.3　重新实现toString方法 96\n6.4　检查前置条件 97\n6.5　添加字段 98\n6.6　自引用.100\n6.7　辅助构造方法.101\n6.8　私有字段和方法.102\n6.9　定义操作符 104\n6.10　Scala中的标识符.106\n6.11　方法重载.108\n6.12　隐式转换.111\n6.13　注意事项.112\n6.14　结语 112\n第7章　内建的控制结构 114\n7.1　if表达式.115\n7.2　while循环 116\n7.3　for表达式 119\n7.4　用try表达式实现异常处理125\n7.5　match表达式129\n7.6　没有break和continue的日子.131\n7.7　变量作用域 134\n7.8　对指令式代码进行重构.137\n7.9　结语.139\n第8章　函数和闭包 140\n8.1　方法.140\n8.2　局部函数142\n8.3　一等函数144\n8.4　函数字面量的简写形式.147\n8.5　占位符语法 147\n8.6　部分应用的函数.149\n8.7　闭包.152\n8.8　特殊的函数调用形式 156\n8.9　尾递归.159\n8.10　结语 163\n第9章　控制抽象 164\n9.1　减少代码重复.164\n9.2　简化调用方代码.169\n9.3　柯里化.170\n9.4　编写新的控制结构173\n9.5　传名参数176\n9.6　结语.178\n第10章　组合和继承179\n10.1　一个二维的布局类库179\n10.2　抽象类 180\n10.3　定义无参方法 182\n10.4　扩展类 184\n10.5　重写方法和字段 186\n10.6　定义参数化字段 188\n10.7　调用超类构造方法.189\n10.8　使用override修饰符 190\n10.9　多态和动态绑定 192\n10.10　声明final成员.195\n10.11　使用组合和继承196\n10.12　实现above、beside和toString.198\n10.13　定义工厂对象.201\n10.14　增高和增宽.204\n10.15　放在一起 206\n10.16　结语207\n第11章　Scala的继承关系208\n11.1　Scala的类继承关系208\n11.2　基本类型的实现机制212\n11.3　底类型（bottom types）.215\n11.4　定义自己的值类型.216\n11.5　结语219\n第12章　特质.220\n12.1　特质如何工作 220\n12.2　瘦接口和富接口 224\n12.3　示例：矩形对象 225\n12.4　Ordered特质 227\n12.5　作为可叠加修改的特质229\n12.6　为什么不用多重继承？234\n12.7　要特质还是不要特质？238\n12.8　结语 238\n第13章　包和引入240\n13.1　将代码放进包里 240\n13.2　对相关代码的精简访问242\n13.3　引入 246\n13.4　隐式引入.249\n13.5　访问修饰符250\n13.6　包对象 256\n13.7　结语 257\n第14章　断言和测试258\n14.1　断言 258\n14.2　用Scala写测试 260\n14.3　翔实的失败报告 262\n14.4　作为规格说明的测试263\n14.5　基于性质的测试 267\n14.6　组织和运行测试 268\n14.7　结语 270\n第15章　样例类和模式匹配.271\n15.1　一个简单的例子 271\n15.2　模式的种类276\n15.3　模式守卫.286\n15.4　模式重叠.287\n15.5　密封类 289\n15.6　Option类型.291\n15.7　到处都是模式 293\n15.8　一个复杂的例子 298\n15.9　结语 306\n第16章　使用列表307\n16.1　List字面量 307\n16.2　List类型 308\n16.3　构建列表.309\n16.4　列表的基本操作 309\n16.5　列表模式.310\n16.6　List类的初阶方法 312\n16.7　List类的高阶方法 324\n16.8　List对象的方法333\n16.9　同时处理多个列表.335\n16.10　理解Scala的类型推断算法 336\n16.11　结语.339\n第17章　使用其他集合类 340\n17.1　序列 340\n17.2　集和映射.344\n17.3　在可变和不可变集合类之间选择352\n17.4　初始化集合355\n17.5　元组 358\n17.6　结语 361\n第18章　可变对象362\n18.1　什么样的对象是可变的？ 362\n18.2　可被重新赋值的变量和属性.365\n18.3　案例分析：离散事件模拟 368\n18.4　用于描述数字电路的语言 369\n18.5　Simulation API.372\n18.6　电路模拟.376\n18.7　结语 384\n第19章　类型参数化385\n19.1　函数式队列385\n19.2　信息隐藏.389\n19.3　型变注解.392\n19.4　检查型变注解 397\n19.5　下界 400\n19.6　逆变 402\n19.7　对象私有数据 405\n19.8　上界 407\n19.9　结语 410\n第20章　抽象成员 411\n20.1　抽象成员概览 411\n20.2　类型成员.412\n20.3　抽象的val413\n20.4　抽象的var414\n20.5　初始化抽象的val.415\n20.6　抽象类型.423\n20.7　路径依赖类型 425\n20.8　改良类型.428\n20.9　枚举 429\n20.10　案例分析：货币431\n20.11 结语.441\n第21章　隐式转换和隐式参数.442\n21.1　隐式转换.442\n21.2　隐式规则.445\n21.3　隐式转换到一个预期的类型.448\n21.4　转换接收端450\n21.5　隐式参数.454\n21.6　上下文界定460\n21.7　当有多个转换可选时463\n21.8　调试 465\n21.9　结语 467\n第22章　实现列表468\n22.1　List类的原理.468\n22.2　ListBuffer类 475\n22.3　List类的实践.476\n22.4　外部可见的函数式.479\n22.5　结语 480\n第23章　重访for表达式 481\n23.1　for表达式483\n23.2　N皇后问题.484\n23.3　用for推导式进行查询 487\n23.4　用for推导式进行翻译 489\n23.5　反过来 494\n23.6　泛化for表达式 495\n23.7　结语 497\n第24章　深入集合类498\n24.1　可变和不可变集合.499\n24.2　集合的一致性 501\n24.3　Traversable特质 503\n24.4　Iterable特质508\n24.5　序列型特质Seq、IndexedSeq和LinearSeq.512\n24.6　集517\n24.7　映射 521\n24.8　具体的不可变集合类525\n24.9　具体的可变集合类.532\n24.10　数组539\n24.11　字符串544\n24.12　性能特征 545\n24.13　相等性547\n24.14　视图548\n24.15　迭代器554\n24.16　从头创建集合.561\n24.17　Java和Scala集合互转.563\n24.18　结语564\n第25章　Scala集合架构565\n25.1　集合构建器565\n25.2　抽取公共操作 567\n25.3　集成新的集合 572\n25.4　结语 588\n第26章　提取器589\n26.1　示例：提取电子邮箱地址 589\n26.2　提取器 591\n26.3　提取0或1个变量的模式 594\n26.4　提取可变长度参数的模式 596\n26.5　提取器和序列模式.598\n26.6　提取器和样例类的对比599\n26.7　正则表达式601\n26.8　结语 604\n第27章　注解.606\n27.1　为什么要有注解？.606\n27.2　注解的语法607\n27.3　标准注解.609\n27.4　结语 613\n第28章　使用XML614\n28.1　半结构化数据 614\n28.2　XML概览615\n28.3　XML字面量 616\n28.4　序列化 618\n28.5　拆解XML620\n28.6　反序列化.622\n28.7　加载和保存623\n28.8　对XML做模式匹配624\n28.9　结语 628\n第29章　用对象实现模块化编程.629\n29.1　问题描述.630\n29.2　食谱应用程序 631\n29.3　抽象 634\n29.4　将模块拆分成特质.638\n29.5　运行时链接640\n29.6　跟踪模块实例 642\n29.7　结语 643\n第30章　对象相等性645\n30.1　Scala中的相等性.645\n30.2　编写相等性方法 646\n30.3　为参数化类型定义相等性 660\n30.4　如何编写equals和hashCode方法.664\n30.5　结语 668\n第31章　结合Scala和Java 669\n31.1　从Java使用Scala.669\n31.2　注解 672\n31.3　通配类型.678\n31.4　同时编译Scala和Java680\n31.5　基于Scala 2.12特性的Java 8集成681\n31.6　结语 685\n第32章　Future和并发编程 686\n32.1　天堂里的烦恼 687\n32.2　异步执行和Try.688\n32.3　使用Future.690\n32.4　测试Future.705\n32.5　结语 708\n第33章　组合子解析709\n33.1　示例：算术表达式.710\n33.2　运行你的解析器 712\n33.3　基本的正则表达式解析器 713\n33.4　另一个示例：JSON 714\n33.5　解析器输出717\n33.6　实现组合子解析器.723\n33.7　字符串字面量和正则表达式.732\n33.8　词法分析和解析 733\n33.9　错误报告.734\n33.10　回溯和LL(1)736\n33.11　结语.737\n第34章　GUI编程.740\n34.1　第一个Swing应用程序.740\n34.2　面板和布局743\n34.3　处理事件.745\n34.4　示例：摄氏/华氏转换器.748\n34.5　结语 750\n第35章　SCells试算表 752\n35.1　可视化框架752\n35.2　将数据录入和显示分开755\n35.3　公式 758\n35.4　解析公式.760\n35.5　求值 765\n35.6　操作类库.768\n35.7　变更通知.771\n35.8　结语 775\n附录A　Unix和Windows环境的Scala脚本.777\n关于作者 798","pages":"832页","images":{"small":"https://img3.doubanio.com/view/subject/s/public/s29620622.jpg","large":"https://img3.doubanio.com/view/subject/l/public/s29620622.jpg","medium":"https://img3.doubanio.com/view/subject/m/public/s29620622.jpg"},"alt":"https://book.douban.com/subject/27591387/","id":"27591387","publisher":"电子工业出版社","isbn10":"7121328429","isbn13":"9787121328428","title":"Scala编程（第3版）","url":"https://api.douban.com/v2/book/27591387","alt_title":"","author_intro":"Martin Odersky 是Scala 编程语言的缔造者。他是瑞士洛桑理工学院（EPFL）的教授，同时也是Typesafe, Inc.（已更名为Lightbend）的创始人。他的研究方向是编程语言和系统，更具体地说，就是如何将面向对象和函数式编程风格有机地结合在一起。自2001 年起，他的主要精力集中在设计、实现和改进Scala 上。在此之前，他作为Java 泛型的合作设计者参与了Java 编程语言的开发，同时也是当前javac 参考实现的作者。他还是ACM 院士。\nLex Spoon是Semmle Ltd 的一名软件工程师。他在EPFL 作为博士后围绕着Scala 开展了两年的工作。他拥有Georgia Tech 的博士学位，在那里他的主攻方向是动态编程语言的静态分析。除Scala 外，他还帮助开发了各类编程语言，包括动态语言Smalltalk、科学计算语言X10，以及支撑Semmle 的逻辑编程语言。他和他的夫人一起生活在Atlanta，他们有两只猫和一只吉娃娃。\nBill Venners 是Artima Inc 的主席，Artima 开发者网站（ww.artima.com）的发行人，以及Escalate Software, LLC 的联合创始人。他著有《Inside theJava Virtual Machine》，这是一本面向程序员讲解Java 平台架构和内部实现原理的书。他在《JavaWorld》杂志上的专栏很受欢迎，主题涵盖Java 内部实现、面向对象的设计和Jini。Bill 从Jini 社区创立之初便十分活跃，领导了Jini 社区的ServiceUI 项目，其API 成为Jini 服务事实上的UI 标准。他还是ScalaTest 的主要开发者和设计者，一个面向Scala 和Java 开发者的开源测试工具。\n译者简介\n高宇翔，资深软件开发工程师和系统架构师，同时也是Scala在国内的早期布道者和实践者，曾译有《快学Scala（第2版）》、《快学Scala》（第1版）和《Scala编程》（第1版）等专业书籍。","summary":"《Scala编程（第3版）》由直接参与Scala开发的一线人员编写，因而对原理的解读和应用的把握更加值得信赖。《Scala编程（第3版）》面向具有一定编程经验的开发者，目标是让读者能够全面了解和掌握Scala编程语言的核心特性，并能够深入理解Scala这门语言在设计取舍背后的动因。即便是不直接使用Scala或从事一线编程工作的读者，也能从《Scala编程（第3版）》学到大量关于函数式和面向对象的编程概念和技巧。","price":"144.00元"},"9787115394095":{"rating":{"max":10,"numRaters":335,"average":"8.0","min":0},"subtitle":"","author":["[日] 大塚弘记"],"pubdate":"2015-7","tags":[{"count":451,"name":"GitHub","title":"GitHub"},{"count":200,"name":"编程","title":"编程"},{"count":182,"name":"计算机","title":"计算机"},{"count":102,"name":"软件开发","title":"软件开发"},{"count":93,"name":"IT","title":"IT"},{"count":89,"name":"github","title":"github"},{"count":80,"name":"软件工程","title":"软件工程"},{"count":76,"name":"版本控制","title":"版本控制"}],"origin_title":"GitHub実践入門","image":"https://img3.doubanio.com/view/subject/m/public/s28147406.jpg","binding":"平装","translator":["支鹏浩","刘斌"],"catalog":"第1章　欢迎来到GitHub的世界　　1\n1.1　什么是GitHub　　2\nGitHub公司与octocat　　2\n并不只是Git仓库的托管服务　　3\nGitHub的使用情况　　3\nColumn 专栏：GitHub与Git的区别　　4\n1.2　使用GitHub会带来哪些变化　　4\n协作形式变化　　4\n在开发者之间引发化学反应的Pull Request　　5\n对特定用户进行评论　　6\nGitHub Flavored Markdown　　7\nColumn 专栏：还可以这样写!!　　7\n能看到更多其他团队的软件　　7\n与开源软件相同的开发模式　　8\n1.3　社会化编程　　9\n1.4　为什么需要社会化编程　　10\n不要闭目塞听，要接触不同的文化　　10\n会写代码的程序员更受青睐　　11\nGitHub最大的特征是“面向人”　　11\n1.5　GitHub提供的主要功能　　12\nGit仓库　　12\nOrganization　　12\nIssue　　13\nWiki　　13\nPull Request　　13\nColumn 专栏：GitHub上受到瞩目的软件　　14\n1.6　小结　　14\n参考资料　　14\n第2章　Git的导入　　17\n2.1　诞生背景　　18\n2.2　什么是版本管理　　18\n集中型与分散型　　19\n集中型　　19\n分散型　　19\n集中型与分散型哪个更好　　20\n2.3　安装　　21\nMac与Linux　　21\nWindows　　21\n组件的选择　　22\n设置环境变量　　22\n换行符的处理　　23\nGit Bash　　23\n本书所用的环境　　24\n2.4　初始设置　　24\n设置姓名和邮箱地址　　24\n提高命令输出的可读性　　25\n2.5　小结　　25\n第3章　使用GitHub的前期准备　　27\n3.1　使用前的准备　　28\n创建账户　　28\n设置头像　　29\n设置SSH Key　　29\n添加公开密钥　　30\n使用社区功能　　31\n3.2　实际动手使用　　31\n创建仓库　　31\nRepository name　　32\nDescription　　32\nPublic、Private　　32\nInitialize this repository with a README　　32\nAdd .gitignore　　33\nAdd a license　　33\n连接仓库　　33\nREADME.md　　33\nGitHub Flavored Markdown　　34\n公开代码　　34\nclone已有仓库　　34\n编写代码　　35\n提交　　36\nColumn 专栏：公开时的许可协议　　37\n进行push　　37\n3.3　小结　　38\n第4章　通过实际操作学习Git　　39\n4.1　基本操作　　40\ngit init——初始化仓库　　40\ngit status——查看仓库的状态　　40\ngit add——向暂存区中添加文件　　41\ngit commit——保存仓库的历史记录　　42\n记述一行提交信息　　42\n记述详细提交信息　　42\n中止提交　　43\n查看提交后的状态　　43\ngit log——查看提交日志　　43\n只显示提交信息的第一行　　44\n只显示指定目录、文件的日志　　44\n显示文件的改动　　45\ngit diff——查看更改前后的差别　　45\n查看工作树和暂存区的差别　　45\n查看工作树和最新提交的差别　　46\n4.2　分支的操作　　47\ngit branch——显示分支一览表　　48\ngit checkout -b——创建、切换分支　　48\n切换到feature-A分支并进行提交　　48\n切换到master分支　　49\n切换回上一个分支　　50\n特性分支　　50\n主干分支　　51\ngit merge——合并分支　　51\ngit log --graph——以图表形式查看分支　　52\n4.3　更改提交的操作　　53\ngit reset——回溯历史版本　　53\n回溯到创建feature-A分支前　　53\n创建fix-B分支　　54\n推进至feature-A分支合并后的状态　　55\n消除冲突　　56\n查看冲突部分并将其解决　　57\n提交解决后的结果　　57\ngit commit --amend——修改提交信息　　58\ngit rebase -i——压缩历史　　59\n创建feature-C分支　　59\n修正拼写错误　　60\n更改历史　　61\n合并至master分支　　63\n4.4　推送至远程仓库　　63\ngit remote add——添加远程仓库　　64\ngit push——推送至远程仓库　　64\n推送至master分支　　64\n推送至master以外的分支　　65\n4.5　从远程仓库获取　　65\ngit clone——获取远程仓库　　65\n获取远程仓库　　65\n获取远程的feature-D分支　　66\n向本地的feature-D分支提交更改　　67\n推送feature-D分支　　67\ngit pull——获取最新的远程仓库分支　　67\n4.6　帮助大家深入理解Git的资料　　68\nPro Git　　68\nLearnGitBranching　　69\ntryGit　　69\n4.7　小结　　70\n第5章　详细解说GitHub的功能　　71\n5.1　键盘快捷键　　72\n5.2　工具栏　　73\n关于UI　　73\n1LOGO　　73\n2Notifications　　73\n3 搜索窗口　　73\n4Explore　　73\n5Gist　　74\n6Blog　　74\n7Help　　74\n8 头像、用户名　　74\n9 Create a new　　74\nAccount settings　　75\nSign out　　75\n5.3　控制面板　　75\n关于UI　　75\n①News Feed　　76\n②Pull Requests　　76\n③Issues　　76\n④Stars　　76\n⑤Broadcast　　76\n⑥Repositories you contribute to　　76\n⑦Your Repositories　　76\n5.4　个人信息　　77\n关于UI　　77\n1 用户信息　　77\n2Popular Repositories　　78\n3Repositories contributed to　　78\n4Public contributions　　78\n5Contribution Activity　　78\n6Repositories　　78\n7Public Activity　　79\n5.5　仓库　　80\n关于UI　　80\n①用户名（组织名）/仓库名　　80\n②Watch/Star/Fork　　80\n③Code　　81\n④Issue　　81\n⑤Pull Requests　　81\n⑥Wiki　　82\n⑦Pulse　　82\n⑧Graphs　　82\n⑨Network　　82\n⑩Settings　　82\n⑪SSH clone URL　　82\n⑫Clone in Desktop　　82\n⑬Download ZIP　　83\nacommits　　83\nbbranches　　83\ncreleases　　83\ndcontributors　　83\neCompare & review　　83\nfbranch　　83\ngpath　　84\nhFork this project and Create a new file　　84\nifiles　　84\n文件的相关操作　　84\nColumn专栏：通过部分名称搜索文件　　85\n查看差别　　85\n查看分支间的差别　　85\n查看与几天前的差别　　86\n查看与指定日期之间的差别　　87\n5.6　Issue　　87\n简洁且表现力丰富的描述方法　　88\n语法高亮　　89\n添加图片　　90\n添加标签以便整理　　90\n添加里程碑以便管理　　91\nColumn 专栏：了解贡献时的规则！　　92\nTasklist语法　　92\n通过提交信息操作Issue　　93\n在相关Issue中显示提交　　93\nClose Issue　　93\n将特定的Issue转换为Pull Request　　94\n5.7　Pull Request　　94\nColumn 专栏：获取diff格式与patch格式的文件　　96\nConversation　　96\nColumn 专栏：引用评论　　96\nCommits　　97\nColumn 专栏：在评论中应用表情　　98\nFiles Changed　　98\n5.8　Wiki　　99\nPages　　100\nHistory　　101\nColumn 专栏：在Wiki中显示侧边栏　　101\n5.9　Pulse　　102\nactive pull requests　　103\nactive issue　　103\ncommits　　104\nReleases published　　104\nUnresolved Conversations　　104\n5.10　Graphs　　105\nContributors　　105\nCommit Activity　　106\nCode Frequency　　106\nPunchcard　　108\n5.11　Network　　108\n5.12　Settings　　109\nOptions　　109\n①Settings　　109\n②Features　　110\n③GitHub Pages　　111\n④Danger Zone　　111\nCollaborators　　111\nWebhooks & Services　　112\nDeploy Keys　　112\n5.13　Notifications　　112\n5.14　其他功能　　114\nGitHub Pages　　114\nGitHub Jobs　　114\nGitHub Enterprise　　114\nGitHub API　　115\n5.15　小结　　115\nColumn 专栏：在Mac的通知中心查看GitHub的Notifications　　115\n第6章　尝试Pull Request　　117\n6.1　Pull Request的概要　　118\n什么是Pull Request　　118\nPull Request的流程　　118\n6.2　发送Pull Request前的准备　　119\n查看要修正的源代码　　120\nFork　　120\nclone　　120\nbranch　　121\n为何要在特性分支中进行作业　　121\n确认分支　　121\n创建特性分支　　121\n添加代码　　122\n提交修改　　122\n创建远程分支　　123\n6.3　发送Pull Request　　123\n6.4　让Pull Request更加有效的方法　　126\n在开发过程中发送Pull Request进行讨论　　126\n明确标出“正在开发过程中”　　127\n不进行Fork直接从分支发送Pull Request　　128\n6.5　仓库的维护　　128\n仓库的Fork与clone　　129\n给原仓库设置名称　　129\n获取最新数据　　130\n6.6　小结　　130\n第7章　接收Pull Request　　131\n7.1　采纳Pull Request的方法　　132\n7.2　采纳Pull Request前的准备　　133\n代码审查　　133\n查看图片的差别　　134\n2-up　　134\nSwipe　　135\nOnion Skin　　135\nDifference　　136\n在本地开发环境中反映Pull Request的内容　　136\n将接收方的本地仓库更新至最新状态　　136\n获取发送方的远程仓库　　137\n创建用于检查的分支　　138\n合并　　138\n删除分支　　139\nColumn 专栏：如何提升代码管理技术　　139\n7.3　采纳Pull Request　　139\n合并到主分支　　140\npush修改内容　　141\n7.4　小结　　142\nColumn 专栏：请协助我们共同创建互相学习的场所　　142\n第8章　与GitHub相互协作的工具及服务　　143\n8.1　hub命令　　144\n概要　　144\n安装　　144\n安装　　145\n确认运行情况　　145\n设置别名　　145\n实现shell上的功能补全　　146\n~/.config/hub　　146\n命令　　146\nhub clone　　146\nhub remote add　　147\nhub fetch　　147\nhub cherry-pick　　147\nhub fork　　148\nhub pull-request　　148\nhub checkout　　148\nhub create　　149\nhub push　　149\nhub browse　　150\nhub compare　　150\nColumn 专栏：让GitHub Enterprise支持hub命令　　151\n8.2　Travis CI　　151\n概要　　151\n实际尝试　　152\n编写配置文件　　152\n检测配置文件是否有问题　　152\n与GitHub集成　　153\n将Travis CI的结果添加至README.md　　155\n8.3　Coveralls　　156\n概要　　156\n安装　　157\n注册　　157\n添加对象仓库　　158\n编写配置文件　　158\n添加gem　　159\n查看报告　　160\n8.4　Gemnasium　　160\n8.5　Code Climate　　161\n8.6　Jenkins　　162\n概要　　162\n安装　　164\n创建bot账户　　165\nbot账户的权限设置　　165\n对象为个人账户时　　165\n对象为Organization账户时　　165\n检查设置　　167\n给Jenkins设置SSH密钥　　167\n初次使用Jenkins时　　167\n已经在使用Jenkins时　　168\nGitHub pull request builder plugin的安装　　169\nGit plugin的设置　　170\nGithub Pull Requests Builder的设置　　170\nGithub server api URL　　171\nAccess Token　　171\nAdmin list　　172\njob的创建与设置　　172\nGitHub project　　172\n源码管理　　172\n构建触发器　　173\n构建　　174\n通知结果　　174\n测试执行中的状态　　175\nFailed　　175\nAll is well　　175\ncommit status　　175\n通过评论进行控制　　176\n执行任务　　176\n添加至White list　　176\n重新执行任务　　176\n变更指定评论　　177\n8.7　小结　　177\nColumn 专栏：用Coderwall生成GitHub上的个人信息　　178\n第9章　使用GitHub的开发流程　　179\n9.1　团队使用GitHub时的注意事项　　180\n一切从简　　180\n项目管理工具与GitHub的区别　　180\n项目管理工具与GitHub相异的原因　　181\n不Fork仓库的方法　　182\n9.2　GitHub Flow——以部署为中心的开发模式　　183\n9.3　GitHub Flow的流程　　184\n随时部署，没有发布的概念　　184\n进行新的作业时要从master分支创建新分支　　185\n在新创建的分支中进行提交　　186\n定期push　　186\n使用Pull Request　　187\n务必让其他开发者进行审查　　187\n合并后立刻部署　　187\n9.4　实践GitHub Flow的前提条件　　188\n部署作业完全自动化　　188\n使用部署工具　　189\n通过Web界面进行部署的工具　　189\n导入开发时的注意事项　　190\n重视测试　　190\n让测试自动化　　190\n编写测试代码，通过全部测试　　190\n维护测试代码　　190\n9.5　模拟体验GitHub Flow　　191\nFizzbuzz的说明　　191\n添加新功能　　192\n创建新的分支　　192\n如果尚未clone仓库　　192\n如果之前clone过仓库　　193\n创建特性分支　　193\n实现新功能　　194\n创建Pull Request　　196\n接收反馈　　196\n修正缩进　　197\n添加测试　　199\n培育Pull Request　　202\nPull Request被合并　　202\n9.6　团队实践GitHub Flow时的几点建议　　203\n减小Pull Request的体积　　204\n准备可供试运行的环境　　204\n不要让Pull Request中有太多反馈　　205\n不要积攒Pull Request　　206\n9.7　GitHub Flow的小结　　206\n9.8　Git Flow——以发布为中心的开发模式　　207\n便于理解的标准流程　　207\n有时显得过于复杂　　209\n9.9　导入Git Flow前的准备　　209\n安装git-flow　　209\nMac下的安装　　209\nLinux下的安装　　210\n确认运行状况　　210\n仓库的初始设置　　210\n创建仓库　　210\n进行git flow的初始设置　　211\n在远程仓库中也创建develop分支　　212\n9.10　模拟体验Git Flow　　212\nmaster分支与develop分支的区别　　213\nmaster分支　　213\ndevelop分支　　213\n在feature中进行的工作　　213\n创建分支　　214\n在分支中进行作业　　215\n发送Pull Request　　216\n通过代码审查提高代码质量　　217\n更新本地的develop分支　　219\n在release分支中进行的工作　　220\nColumn 专栏：设置默认分支　　220\n创建分支　　221\n分支内的工作　　222\n进行发布与合并　　222\n查看版本标签　　224\n更新到远程仓库　　225\n在hotfix分支中进行的工作　　226\n创建分支　　226\n创建标签和进行发布　　228\n从hotfix分支合并至develop分支　　230\n9.11　Git Flow的小结　　232\nColumn 专栏：版本号的分配规则　　232\n第10章　将GitHub应用到企业　　233\n10.1　将世界标准的开发环境引入企业现场　　234\n企业引入GitHub的好处　　234\n使用Organization　　235\n确认Github的安全性　　235\n注意维护时间　　235\n查看故障信息　　236\n10.2　GitHub Enterprise　　237\n概述　　238\n引入的好处　　238\n引入的弊端　　239\n适合引入GitHub Enterprise的几种情况　　239\n源代码不可外传　　239\nColumn 专栏：将GitHub的仓库作为Subversion仓库使用　　240\n希望维护与故障时间可控　　240\n10.3　能实现Git托管的软件　　241\nColumn 专栏：Bitbucket　　241\n10.4　小结　　242\n附录A　支持GitHub的GUI客户端　　243\nA.1　GitHub for Mac，GitHub for Windows　　244\nA.2　SourceTree　　246\n附录B　通过Gist轻松实现代码共享　　247\nB.1　Gist的特点　　248\nB.2　创建Gist　　248\nUI讲解　　249\n1　Gist description　　249\n2　name this file　　　　249\n3���language　　250\n4　ACE Editor 　　250\n5　文件　　250\n6　Add another File　　251\n7　Create Secret Gist　　251\n8　Create Public Gist　　251\nB.3　查看Gist　　252\nGist 的菜单　　252\n①Gist Detail　　253\n②Revisions　　253\n③Download Gist　　253\n④Clone this gist　　253\n⑤Embed this gist　　253\n⑥Link to this gist 　　253\n文件的菜单 　　254\nB.4　Your Gists 　　254\nB.5　小结　　255","pages":"280","images":{"small":"https://img3.doubanio.com/view/subject/s/public/s28147406.jpg","large":"https://img3.doubanio.com/view/subject/l/public/s28147406.jpg","medium":"https://img3.doubanio.com/view/subject/m/public/s28147406.jpg"},"alt":"https://book.douban.com/subject/26462816/","id":"26462816","publisher":"人民邮电出版社","isbn10":"7115394091","isbn13":"9787115394095","title":"GitHub入门与实践","url":"https://api.douban.com/v2/book/26462816","alt_title":"GitHub実践入門","author_intro":"大塚弘记\n将敏捷软件开发导入开发现场的领军人物，以顾问身份就Web应用的开发及服务指导过多家企业和团队。曾为多家企业和团队导入GitHub，在建立一天之内多次部署的开发体制方面拥有丰富经验。","summary":"本书从Git的基本知识和操作方法入手，详细介绍了GitHub的各种功能，GitHub与其他工具或服务的协作，使用GitHub的开发流程以及如何将GitHub引入到企业中。在讲解GitHub的代表功能Pull Request时，本书专门搭建了供各位读者实践的仓库，邀请各位读者进行Pull Request并共同维护。","price":"39.00元"},"9787115404404":{"rating":{"max":10,"numRaters":445,"average":"8.8","min":0},"subtitle":"","author":["Robin Williams"],"pubdate":"2016-1","tags":[{"count":355,"name":"设计","title":"设计"},{"count":142,"name":"艺术/设计","title":"艺术/设计"},{"count":123,"name":"入门","title":"入门"},{"count":116,"name":"平面设计","title":"平面设计"},{"count":104,"name":"设计思维","title":"设计思维"},{"count":96,"name":"艺术","title":"艺术"},{"count":71,"name":"Design","title":"Design"},{"count":41,"name":"罗宾·威廉姆斯","title":"罗宾·威廉姆斯"}],"origin_title":"The Non-Designer's Design Book(4th Edition)","image":"https://img1.doubanio.com/view/subject/m/public/s28340357.jpg","binding":"平装","translator":["苏金国","李盼"],"catalog":"第一部分　设计原则\n第1章　引言　　3\n约书亚树　　3\n4大基本原则　　5\n第2章　亲密性　　7\n把问题说出来　　 22\n亲密性小结　　24\n根本目的　　24\n如何实现　　24\n要避免的问题　　24\n第3章　对齐　　25\n到处看看　　 44\n对齐小结　　46\n根本目的　　46\n如何实现　　46\n要避免的问题　　46\n第4章　重复　　47\n重复小结　　60\n根本目的　　60\n如何实现　　60\n要避免的问题　　60\n第5章　对比　　61\n对比小结　　76\n根本目的　　76\n如何实现　　76\n要避免的问题　　76\n第6章　4大基本原则复习　　77\n亲密性　　78\n对齐　　79\n重复　　80\n对比　　81\n小测验#1：设计原则　　82\n小测验#2：重新设计广告　　83\n小结　　86\n第7章　颜色运用　　87\n不同凡响的色轮　　88\n颜色关系　　89\n互补　　90\n三色组　　91\n分裂互补三色组　　92\n类似色　　93\n暗色和亮色　　94\n建立你自己的暗色和亮色　　95\n单色　　96\n暗色和亮色的组合　　97\n注意色质　　98\n暖色与冷色　　99\n如何取舍　　100\nCMYK与RGB，印刷与Web　　102\n印刷与Web 颜色模型　　104\n小测验#3：颜色　　104\n第8章　更多提示与技巧　　105\n创建包装或品牌　　106\n企业名片　　109\n关于设计企业名片的提示　　112\n信笺和信封　　113\n关于设计信笺和信封的提示　　116\n传单　　117\n关于设计传单的提示　　120\n新闻简报　　121\n关于设计新闻简报的提示　　124\n宣传册　　125\n关于设计宣传册的提示　　128\n明信片　　129\n关于设计明信片的提示　　132\n报纸广告　　133\n关于设计报纸广告的提示　　136\n简历　　137\n关于设计简历的提示　　140\n第二部分　字体设计\n第9章　字体的基本规则　　143\n标点后面一个空格　　144\n引号　　145\n撇号　　146\n小测验#4：撇号　　147\n连接号　　148\n特殊符号　　150\n重音符号　　152\n大写字母　　153\n下划线　　154\n字距调整　　155\n寡妇和孤儿　　156\n其他　　157\n第10章　字体（与人生）　　159\n协调　　160\n冲突　　162\n对比　　164\n小结　　166\n第11章　字体类别　　167\nOldstyle（旧式体）　　168\nModern（现代体）　　169\nSlab serif（粗衬线体）　　170\nSans serif（无衬线体）　　171\nScript（手写体）　　173\nDecorative（花体）　　174\n有意识地去做　　175\n小测验#5：字体类别　　175\n小测验#6：粗/细过渡　　176\n小测验#7：截线　　177\n小结　　178\n第12章　字体对比　　179\n大小　　180\n粗细　　184\n结构　　188\n形状　　192\n方向　　196\n颜色　　200\n结合多种对比　　206\n小结　　207\n小测验#8：对比还是冲突　　208\n小测验#9：可做与不可做　　209\n结合多种对比的练习　　210\n第三部分　其他\n第13章　你掌握了吗　　213\n过程　　214\n练习　　215\n好的——重新设计!　　216\n第14章　测验答案和建议　　217\n测试答案　　217\n设计师之眼建议　　220\n第15章　本书所用字体　　225\n附录A：迷你术语表和资源　　231\n附录B：我永远是一名教师　　232\n附录C：生活就要设计　　237\n索引　　238","ebook_url":"https://read.douban.com/ebook/18692011/","pages":"252","images":{"small":"https://img1.doubanio.com/view/subject/s/public/s28340357.jpg","large":"https://img1.doubanio.com/view/subject/l/public/s28340357.jpg","medium":"https://img1.doubanio.com/view/subject/m/public/s28340357.jpg"},"alt":"https://book.douban.com/subject/26664522/","id":"26664522","publisher":"人民邮电出版社","isbn10":"7115404402","isbn13":"9787115404404","title":"写给大家看的设计书（第4版）","url":"https://api.douban.com/v2/book/26664522","alt_title":"The Non-Designer's Design Book(4th Edition)","author_intro":"Robin　Williams\n世界著名设计师、技术专家和畅销书作家。通过写书和授课，她已经影响了整整一代数字设计师。同时，作为Adobe和Mac技术社区内的偶像级专家，她拥有大批拥戴者。\n她是Publish　Magazine、Adobe　Magazine等杂志的专栏作家，是MacWorld　Expo等业界重要活动和组织的顾问委员会成员，还创办了Santa　Fe电影艺术学院。除本书外，她还著有几十部畅销图书和获奖著作，包括《写给大家看的Web设计书》等，有的书已经被翻译为十几种文字，产生了世界性的影响。\n图灵社区对她做过访谈，感兴趣的读者可以看看被豆瓣网友评为J.K.罗琳似的艰苦奋斗代表是如何自我定位的：ituring.cn/article/41065。","summary":"畅销设计入门书最新版，让每个人都能成为设计师\n在这个创意无处不在的时代，越来越多的人成为设计师。简历、论文、PPT、个人主页、博客、活动海报、给客人的邮件、名片……，处处都在考验你的设计能力。\n美术功课不好？没有艺术细胞？毫无设计经验？\n没关系！在设计大师RobinWilliams看来，设计其实很简单。在这部畅销全球多年、影响了一代设计师的经典著作中，RobinWilliams将优秀设计的秘诀归纳为对比、重复、对齐和亲密性四条基本原则，并用简洁通俗、幽默生动的文笔，同时配以大量经过修改进行前后对比的实例图解和设计练习（并提供解答），直观清晰地传授给读者。通过本书，普通读者很快就能够自信地设计出专业级别的作品，而专业设计师也将从中获得灵感和解决问题的途径。\nRobin　Williams　　世界著名设计师、技术专家和畅销书作家。通过写书和授课，她已经影响了整整一代数字设计师。同时，作为Adobe和Mac技术社区内的偶像级专家，她拥有大批拥戴者。她是Publish　Magazine、Adobe　Magazine等杂志的专栏作家，是MacWorld　Expo等业界重要活动和组织的顾问委员会成员，还创办了Santa　Fe电影艺术学院。除本书外，她还著有几十部畅销图书和获奖著作，包括《写给大家看的Web设计书》等，有的书已经被翻译为十几种文字，产生了世界性的影响。图灵社区对她做过访谈，收录在本书内，感兴趣的读者看看被豆瓣网友评为“J.K.罗琳似的艰苦奋斗代表”的Robin是如何自我定位的。访谈电子版地址：ituring.cn/article/41065。","ebook_price":"18.00","price":"59.00元"},"9787108011114":{"rating":{"max":10,"numRaters":7005,"average":"8.9","min":0},"subtitle":"科学顽童的故事","author":["费曼"],"pubdate":"1997-12","tags":[{"count":4296,"name":"传记","title":"传记"},{"count":3154,"name":"费曼","title":"费曼"},{"count":1773,"name":"科普","title":"科普"},{"count":1440,"name":"物理","title":"物理"},{"count":1371,"name":"别闹了，费曼先生","title":"别闹了，费曼先生"},{"count":959,"name":"人物","title":"人物"},{"count":914,"name":"科学家","title":"科学家"},{"count":888,"name":"自传","title":"自传"}],"origin_title":"“Surely You’re Joking,Mr. Feynman!” - Adventures of a Curious Character","image":"https://img3.doubanio.com/view/subject/m/public/s1027286.jpg","binding":"平装","translator":["吴程远"],"catalog":"目录\n序\n天才中的小飞侠\n作者序――\n费曼自述\n作者序二\n带来无限灵感\n第一部 小顽童的成长\n他单靠想便把收音机修好\n我切，我切，我切切切！\n谁偷了我的门？\n你在说什么鬼话？\n好险，又过关了！\n伟大的化学部主任\n第二部 误闯普林斯顿\n“别闹了 费曼先生！”\n我啦！我啦！\n有没有猫体构造图？\n当科学大师碰上菜鸟\n真正男子汉\n跟数学家抬杠\n看穿你的心\n草履虫 蜻蜓・蚁\n第三部 从军记\n我要报效国家\n猎犬能，我也能\n原子弹外传\n开锁英雄惜英雄\n山姆大叔不要你\n第四部 堂堂大教授\n眼中无“物’，心中有“理’\n有什么问题吗？\n还我一块钱！\n你就这样问她们？\n运气，其实不简单\n美国佬在巴西\n语不惊人誓不休\n费曼大闹赌城\n对不起 薪水太高了\n第五部 笑闹中的真智慧\n桃太郎，我投降！\n不要太相信专家\n我就是不要签\n会议在哪里？\n如果科学就是艺术\n假聪明，真笨蛋\n你们就这样选书？\n诺贝尔奖害人不浅\n无心插柳变专家\n教授鼓手上舞台\n真真假假，假假真真\n草包族科学\n","pages":"449","images":{"small":"https://img3.doubanio.com/view/subject/s/public/s1027286.jpg","large":"https://img3.doubanio.com/view/subject/l/public/s1027286.jpg","medium":"https://img3.doubanio.com/view/subject/m/public/s1027286.jpg"},"alt":"https://book.douban.com/subject/1037602/","id":"1037602","publisher":"生活·读书·新知三联书店","isbn10":"7108011115","isbn13":"9787108011114","title":"别闹了，费曼先生","url":"https://api.douban.com/v2/book/1037602","alt_title":"“Surely You’re Joking,Mr. Feynman!” - Adventures of a Curious Character","author_intro":"理查德・曼（Richard P.Feyrman）1918年出生，1939年于麻省理工学院毕业后，进入普林斯顿大学研究院，又加入罗拉拉摩斯实验室，对原子弹的发展贡献卓著。1956年与薛温格和朝永振一郎共获诺贝尔物理奖。1988年2月困患癌症辞世。费曼的思想如天马行空，喜自辟蹊径，且从不固执，求知欲极强。他很爱恶作剧，但往往只为点出世间许多荒谬之处。确如《洛杉矶时报》所说的，“任何读这本书而不大笑出声的人，心理一定有毛病。”","summary":"费曼得过诺贝尔奖，是现代最伟大的理论物理学家之一。但他同时也可能是历史上唯一被按摩院请去画裸体画、偷偷打开放着原子弹机密文件的保险箱，在巴西桑巴乐团担任鼓手的科学家。他曾跟爱因斯坦和波尔等大师讨论物理问题，也曾在赌城跟职业赌徒研究输赢机率。","series":{"id":"1682","title":"科学人文"},"price":"22.00"},"9787115482495":{"rating":{"max":10,"numRaters":281,"average":"8.0","min":0},"subtitle":"","author":["阮一峰"],"pubdate":"2018-6-1","tags":[{"count":85,"name":"阮一峰","title":"阮一峰"},{"count":62,"name":"未来","title":"未来"},{"count":53,"name":"计算机","title":"计算机"},{"count":48,"name":"社会","title":"社会"},{"count":46,"name":"科技","title":"科技"},{"count":41,"name":"思维","title":"思维"},{"count":33,"name":"随笔","title":"随笔"},{"count":28,"name":"思考","title":"思考"}],"origin_title":"","image":"https://img3.doubanio.com/view/subject/m/public/s29804420.jpg","binding":"平装","translator":[],"catalog":"▌现实篇\n世界会走向哪里？\n白领岗位的消亡\n为什么世界上没有安全的工作？\n那些无用的人\n穷忙的人生\n为什么你可以不读大学\n▌职业篇\n为什么雇用制度对工人不利？\n母鸡与前端工程师\n你的命运不是一头骡子\n从日本70 岁退休谈起……\n45 岁以后的人生\n你的 B 计划在哪里？\n▌方法篇\n为什么创业？\n如何确定创业方向？\n不要在功能上竞争\n大坑和小铲子\n富爸爸，穷爸爸\nDan 计划：重新定义人生的10 000 个小时\n软件工程师的职业建议\n为什么起床后不能收邮件？\n▌案例篇\n个性也是一种竞争力\n要聊天，先付费\n即将来临的卖文时代\n微媒体时代\n未来的娱乐业\n技术教育的兴起\n▌未来篇\n高级人类的崛起\n换头术\n你的鞋都比你聪明\n技术的边界\n熵：宇宙的终极规则\n技术决定历史\n卡辛斯基的警告","ebook_url":"https://read.douban.com/ebook/54850954/","pages":"160","images":{"small":"https://img3.doubanio.com/view/subject/s/public/s29804420.jpg","large":"https://img3.doubanio.com/view/subject/l/public/s29804420.jpg","medium":"https://img3.doubanio.com/view/subject/m/public/s29804420.jpg"},"alt":"https://book.douban.com/subject/30259509/","id":"30259509","publisher":"人民邮电出版社","isbn10":"7115482497","isbn13":"9787115482495","title":"未来世界的幸存者","url":"https://api.douban.com/v2/book/30259509","alt_title":"","author_intro":"阮一峰IT 技术作家，长期写作个人技术博客。当过高校教师，也当过阿里巴巴集团软件工程师。\n于2003年开始在网络上写日志，文章包含的内容非常广博，涉及读书、版权制度、经济学、英语、历史、IT技术、医学、电影、音乐和美术、政治学、科学、创业、互联网等23个大的分类。\n曾出 版译著《黑客与画家》《软件随想录》，技术专著《ES6 标准入门》。\n著作：《如何变得有思想》 、《前方的路》。","summary":"本书为阮一峰博客文集，主要收录的是作者对技术变革的影响的一些思考，希望能够藉此书让读者意识到世界正在剧烈变化，洪水就在不远处，从而早早准备出路。本书适合所有乐于思考的读者。","ebook_price":"19.99","series":{"id":"43672","title":"阮一峰文集"},"price":"39.00 元"},"9787121139512":{"rating":{"max":10,"numRaters":20596,"average":"9.1","min":0},"subtitle":"","author":["吴军"],"pubdate":"2011-8","tags":[{"count":12728,"name":"互联网","title":"互联网"},{"count":9288,"name":"IT","title":"IT"},{"count":6676,"name":"商业","title":"商业"},{"count":4809,"name":"计算机","title":"计算机"},{"count":4752,"name":"浪潮之巅","title":"浪潮之巅"},{"count":3811,"name":"历史","title":"历史"},{"count":1918,"name":"管理","title":"管理"},{"count":1615,"name":"投资","title":"投资"}],"origin_title":"","image":"https://img3.doubanio.com/view/subject/m/public/s6807265.jpg","binding":"平装","translator":[],"catalog":"i\t序言（李开复）\niii\t前言　有幸见证历史\n1\t第 1 章　帝国的余辉—AT&T 公司\nAT&T 100年 来 发 展 得 非 常 健 康。 虽 然 它 一 直 受 反 垄断法的约束，但是美国政府司法部并没有真正要过它的命，每一次反垄断其实是帮助AT&T修枝剪叶，然后让它发展得更好。\n1　百年帝国\n2　几度繁荣\n3　利令智昏\n4　外来冲击\n结束语\n15\t第 2 章　蓝色巨人—IBM 公司\n郭士纳在到IBM以前也是做(芯)片的，但是，是土豆芯片\n1　赶上机械革命的最后一次浪潮\n2　领导电子技术革命的浪潮\n3　错过全球信息化的大潮\n4　他也是做（芯）片的\n5　保守的创新者\n6   内部的优胜劣汰\n7　后金融危机时代\n结束语\n38\t第 3 章　“水果”公司的复兴—乔布斯和苹果公司\n在每一次技术革命中，新技术必须比老的技术有数量 级的进步才能站住脚。\n1　传奇小子\n2　迷失方向\n3　再创辉煌\n4　大难不死\n5　i 十年\n结束语\n54\t第 4 章　计算机工业的生态链\n一 个IT公 司 如 果 今 天 和18个 月 前 卖 掉 同 样 多 的、 同\n样的产品，它的营业额就要降一半。\n1　摩尔定律\n2　安迪 – 比尔定律\n3　反摩尔定律\n结束语\n66\t第 5 章　奔腾的芯 — 英特尔公司\n英特尔的CEO格罗夫虽然是学者出身，但他同时也是微机时代最优秀的领导者和管理者，数次被评为世界上最好的CEO。\n1　时势造英雄\n2　英特尔、摩托罗拉之战\n3　指令集之争\n4　英特尔和 AMD 的关系\n5　举步艰难\n结束语\n82\t第 6 章　IT 领域的罗马帝国—微软公司\n当乔布斯给盖茨看了新设计的麦金托什个人电脑，以 及漂亮的基于图形界面的操作系统时，盖茨惊呆了。 那一年，乔布斯和盖茨都是 26岁。\n1　双雄会\n2　亡羊补牢\n3　人民战争\n4　帝国的诞生\n5　当世拿破仑\n6　尾大不掉\n7　条顿堡之战\n8　客厅争夺战\n结束语\n110\t第 7 章　互联网的金门大桥—思科公司\n据说斯坦福两个系的计算中心主管莱昂纳多•波萨卡 和桑迪•勒纳要在计算机上写情书，由于各自管理的 网络不同，设备又是乱七八糟，什么厂家的、什么协 议的都有，互不兼容，情书传递起来很不方便，于是 两人干脆发明了一种能支持各种网络服务器、各种网 络协议的路由器。于是思科公司赖以生存的“多协议 路由器”便诞生了。\n1　好风凭借力\n2　持续发展的绝招\n3　竞争者\n4　诺威格定律的宿命\n结束语\n125\t第 8 章　英名不朽—杨致远、菲洛和雅虎公司\n一百年后，如果人们只记得两个对互联网贡献最大的 人，那么这两个人很可能就是杨致远和菲洛。\n1　当世福特\n2　流量、流量、流量\n3　成也萧何，败也萧何\n4　既生瑜，何生亮\n5　红巨星\n6　自废武功\n结束语\n147\t第 9 章　硅谷的见证人—惠普公司\n作为硅谷最早的公司，惠普见证了硅谷发展的全过程， 从无到有，从硬件到软件，惠普的历史从某种程度上 讲就是硅谷历史的缩影。\n1　昔日硅谷之星\n2　有争议的生死抉择\n3　最有争议的 CEO\n4　亚洲制造的冲击\n5　峰回路转\n结束语\n163\t第 10 章　没落的贵族—摩托罗拉公司\n如果我们认为公司之中也有所谓的贵族，摩托罗拉无 疑可以算一个。曾几何时，摩托罗拉就是无线通信的 代名词，同时它还是技术和品质的结晶。\n1　二战的品牌\n2　黄金时代\n3　基因决定定律\n4　铱星计划\n5　全线溃败\n6　回天乏力\n结束语\n182\t第 11 章　硅谷的另一面\n美国的硅谷只占国土面积万分之五，却创造了无数的商 业神话。在这里，大约每10天便有一家公司上市。美 国前100强的公司中，硅谷占了四成。\n1　成王败寇\n2　嗜血的地方\n3　机会均等\n4　硅含量不断降低\n5　亘古而常青 结束语\n204\t第 12 章　短暂的春秋—与机会失之交臂的公司\n在人类命运降临的伟大瞬间，市民的一切美德 — 小 心、顺从、勤勉、谨慎，都无济于事，它始终只要求 天才人物，并且将他造就成不朽的形象。命运鄙视地 把畏首畏尾的人拒之门外。命运 — 这世上的另一位 神，只愿意用热烈的双臂把勇敢者高高举起，送上英 雄们的天堂。\n1　太阳公司\n2　Novell 公司\n3　网景公司\n4　RealNetworks\n结束语\n236\t第 13 章　幕后的英雄—风险投资\n对于想找投资的新创业公司，红杉资本有一些基本要 求 — 公司的业务要能几句话就讲得清楚。红杉资本 的投资人会给你一张名片，看你能不能在名片背面的 一点点地方把你想做的事情写清楚。\n1　风投的起源\n2　风投的结构\n3　风投的过程\n4　投资的决策和公司的估价\n5　风投的角色\n6　著名的风投公司\n结束语\n265\t第 14 章　信息产业的规律性\n人类的文明和技术是不断进步的，旧的不去，新的不 来，只有清除掉阻碍我们进步的那些庞大的恐龙，才 能为人类提供新的发展空间。从这个角度讲，一个昔 日跨国公司的衰亡，也许是它为我们这个社会做的最 后一次贡献。\n1   70–20–10 律\n2　诺威格定律\n3　基因决定定律\n结束语\n286\t第 15 章　硅谷的摇篮—斯坦福大学\n二战后，帮助斯坦福大学解决财政危机的是它的一位 教授弗里德里克•特曼，他后来被称为“硅谷之父”。 他仔细研究了斯坦福夫妇的遗嘱，发现里面没有限制 大学出租土地，于是他兴奋地声称找到了解决问题的 秘密武器 — 建立斯坦福科技园。\n1　充满传奇的大学\n2　硅谷的支柱\n3　纽曼加洪堡的教育模式\n4　创业的孵化器\n结束语\n313\t第 16 章　科技公司的吹鼓手—投资银行\n华尔街的贪婪既会捧起，也会扼杀一个科技新星。\n1　华尔街和美国的金融体系\n2　著名的投资公司\n3　科技公司的上市过程\n4　成也萧何，败也萧何\n5　华尔街与微软、雅虎和 Google 的三国演义\n结束语\n341\t第 17 章　挑战者—Google 公司\nGoogle是个奇怪的地方。也许是因为Google的年轻人太多，他们不懂得传统也不拘泥传统，只要认准了对公司对社会有用，就大胆去干了。\n1　历史上最轰动的 IPO\n2　早期岁月\n3　商业模式\n4　个人英雄主义和群众路线\n5　绝代双骄\n6　感谢上帝，今天是星期五（TGIF）\n7　不作恶\n8　不败的神话\n9　秘密军团\n10　云计算和数据中心\n11　Google 的新气象\n12　3G 时代\n13　进攻，永远是最好的防守\n结束语\n396\t第 18 章　成功的转基因—诺基亚、3M、GE 公司\n由于科学技术是最革命、发展最快的生产力，一家科 技公司要想在几次技术革命大潮中都能够立于浪潮之 巅是一件极不容易的事。\n1　从木工厂到手机之王（诺基亚公司）\n2　道琼斯指数中的常青树（3M 公司）\n3　世界最大的联合体（GE 公司）\n结束语\n423\t第 19 章　印钞机—最佳的商业模式\n所有成功的大公司都有好的商业模式，很多大公司的 兴起，不是靠技术的革新而是靠商业模式的转变。\n1　Google 的广告系统\n2　eBay 和亚马逊的在线市场\n3　戴尔的虚拟工厂\n4　腾讯的虚拟物品和服务\n结束语\n442\t第 20 章　互联网 2.0\n互联网2.0最重要的是提供了一个开放的平台，让用户可以在平台上开发自己的应用程序，并且提供给其 他用户使用。\n1　互联网的前世今生\n2　互联网 2.0 的特征\n3　著名的互联网 2.0 公司\n4　是革命还是泡沫\n结束语\n467\t第 21 章　金融风暴的冲击\n虽然全世界在2008年的最后一个季度里陷入严重的 衰退，同时人们的恐惧心理加重了这场危机，虽然在 更 长 一 些 时 间 里 我 们 仍 将 处 于 衰 退， 但 是， 明 天 仍 然 会 好 起 来。 今 后 的44年 里 我 们 的 经 济、 我 们 的 社会 都 将 获 得 长 足 的 发 展， 就 如 同 过 去 的44年 一 样。\n— 沃伦•巴菲特\n1　金融危机的成因\n2　瑞雪兆丰年：优胜劣汰\n3　潜在的商机到处都是\n4　格局的变迁\n结束语\n497\t第 22 章 　云计算\n云计算保证用户可以随时随地访问和处理信息，并且 可以非常方便地与人共享信息。 它的好处是让全社会 的计算资源得到最有效的利用。\n1　云计算的起源\n2　云计算的本质\n3　云计算的核心技术和工程\n4　对 IT 产业链的颠覆\n结束语\n513\t第 23 章　下一个 Google\n虽然我们不知道下一个Google在哪里，但是可以肯\n定它不在搜索领域，这就如同几年前我们寻找的“下 一个微软”不会是一家软件公司，而最终是一家互联 网公司一样。\n1　千亿俱乐部\n2　岁岁年年人不同\n3　新领域\n4　关注亚太地区\n结束语\n537\t后记\n541\t索引","pages":"584","images":{"small":"https://img3.doubanio.com/view/subject/s/public/s6807265.jpg","large":"https://img3.doubanio.com/view/subject/l/public/s6807265.jpg","medium":"https://img3.doubanio.com/view/subject/m/public/s6807265.jpg"},"alt":"https://book.douban.com/subject/6709783/","id":"6709783","publisher":"电子工业出版社","isbn10":"7121139510","isbn13":"9787121139512","title":"浪潮之巅","url":"https://api.douban.com/v2/book/6709783","alt_title":"","author_intro":"吴军博士，毕业于清华大学计算机系（本科）、电子工程系（硕士）和美国约翰 · 霍普金斯大学计算机科学系（博士）。在清华大学和约翰 · 霍普金斯大学期间，吴军博士致力于语音识别、自然语言处理，特别是统计语言模型的研究。他曾获得1995年全国人机语音智能接口会议的最佳论文奖和2000年Eurospeech的最佳论文奖。\n吴军博士于2002年加入Google公司。在Google，他和Amit Singhal（Google院士，世界著名搜索专家）、Matt Cutts（Google反作弊官方发言人）等三位同事一起开创了网络搜索反作弊的研究领域，并因此获得Google工程奖。2003年，他和Google全球架构的总工程师朱会灿博士等共同成立了中日韩文搜索部门。吴军博士是当前Google中日韩文搜索算法的主要设计者。在Google其间，他还领导了许多研发项目，包括许多与中文相关的产品和自然语言处理的项目，并得到了当时公司首席执行官埃里克 · 施密特和创始人谢尔盖 · 布林的高度评价。此外，他还在谷歌黑板报上发表了《数学之美》系列博客。\n吴军博士在国内外发表过数十篇论文，并获得和申请了十余项美国和国际专利。他于2005年起，当选为约翰 · 霍普金斯大学计算机系董事会董事。2007起担任风险投资基金中国世纪基金的董事。\n2010年，吴军博士离开Google,加盟腾讯公司，担任负责搜索业务的副总裁。并担任国家重大专项“新一代搜索引擎和浏览器”项目的总负责人。","summary":"近一百多年来，总有一些公司很幸运地、有意识或无意识地站在技术革命的浪尖之上。在这十几年间，它们代表着科技的浪潮，直到下一波浪潮的来临。\n从一百年前算起，AT&T 公司、IBM 公司、苹果公司、英特尔公司、微软公司、思科公司、雅虎公司和Google公司都先后被幸运地推到了浪尖。虽然，它们来自不同的领域，中间有些已经衰落或正在衰落，但是它们都极度辉煌过。本书系统地介绍了这些公司成功的本质原因及科技工业一百多年的发展。\n在极度商业化的今天，科技的进步和商机是分不开的。因此，本书也系统地介绍了影响到科技浪潮的风险投资公司，诸如 KPCB 和红杉资本，以及百年来为科技捧场的投资银行，例如高盛公司，等等。\n在这些公司兴衰的背后，有着它必然的规律。本书不仅讲述科技工业的历史，更重在揭示它的规律性。","price":"55.00元"},"9787121123368":{"rating":{"max":10,"numRaters":868,"average":"8.8","min":0},"subtitle":"从小工到专家","author":["Andrew Hunt","David Thomas"],"pubdate":"2011-1","tags":[{"count":537,"name":"编程","title":"编程"},{"count":531,"name":"程序员","title":"程序员"},{"count":349,"name":"计算机","title":"计算机"},{"count":303,"name":"程序员的修炼之道","title":"程序员的修炼之道"},{"count":267,"name":"软件开发","title":"软件开发"},{"count":242,"name":"思维","title":"思维"},{"count":216,"name":"软件工程","title":"软件工程"},{"count":175,"name":"程序设计","title":"程序设计"}],"origin_title":"The Pragmatic Programmer: From Journeyman to Master","image":"https://img3.doubanio.com/view/subject/m/public/s4646956.jpg","binding":"平装","translator":["马维达"],"catalog":"前言\n序\n第1章 注重实效的哲学\n1 我的源码让猫给吃了\n2 软件的熵\n3 石头汤与煮青蛙\n4 足够好的软件\n5 你的知识资产\n6 交流\n第2章 注重实效的途径\n7 重复的危害\n8 正交性\n9 可撤消性\n10 曳光弹\n11 原型与便笺\n12 领域语言\n13 估算\n第3章 基本工具\n14 纯文本的威力\n15 shell游戏\n16 强力编辑\n17 源码控制\n18 调试\n19 文本操纵\n20 代码生成器\n第4章 注重实效的偏执\n21 按合约设计\n22 死程序不说谎\n23 断言式编程\n24 何时使用异常\n25 怎样配平资源\n第5章 弯曲，或折断\n26 解耦与得墨忒耳法则\n27 元程序设计\n28 时间耦合\n29 它只是视图\n30 黑板\n第6章 当你编码时\n31 靠巧合编程\n32 算法速率\n33 重构\n34 易于测试的代码\n35 邪恶的向导\n第7章 在项目开始之前\n36 需求之坑\n37 解开不可能解开的谜题\n38 等你准备好\n39 规范陷阱\n40 圆圈与箭头\n第8章 注重实效的项目\n41 注重实效的团队\n42 无处不在的自动化\n43 无情的测试\n44 全都是写\n45 极大的期望\n46 傲慢与偏见\n附录A 资源\n专业协会\n建设藏书库\nInternet资源\n参考文献\n附录B 练习解答\n索引\n注重实效的程序员之快速参考指南","pages":"272","images":{"small":"https://img3.doubanio.com/view/subject/s/public/s4646956.jpg","large":"https://img3.doubanio.com/view/subject/l/public/s4646956.jpg","medium":"https://img3.doubanio.com/view/subject/m/public/s4646956.jpg"},"alt":"https://book.douban.com/subject/5387402/","id":"5387402","publisher":"电子工业出版社","isbn10":"7121123363","isbn13":"9787121123368","title":"程序员修炼之道","url":"https://api.douban.com/v2/book/5387402","alt_title":"The Pragmatic Programmer: From Journeyman to Master","author_intro":"Andrew Hunt是世界知名的软件技术专家。他从事软件开发和咨询多年，涉及电信、银行、金融服务、公共服务、医学成像等各种领域。以本获得世界级声誉后，他与David Thomas合作开办了一家专业的软件咨询和出版机构The Pragrammers,并撰写或组织出版了Programming Ruby和Agile Web Development With Rails 等名著，直接推动了RUBY和ROR的兴起，Andrew Hunt与合作人的PRACTICES OF AN AGILE David一书（中文版即将由人民邮电出版社出版），延续了本书的风格，同样也已成为经典。\n    Dave Thomas 喜欢驾驶单引擎飞机飞行，并通过这样的方式为他的习惯付账：为各种难题寻找优雅的解决方案，提供诸多领域里的咨询服务——航空、银行、金融服务、服务、电信、交通运输及Internet。\n    马维达，《C++网络编程（卷2）》与，《ACE自适配通信环境技术文档》的译者","summary":"《程序员修炼之道:从小工到专家》内容简介：《程序员修炼之道》由一系列独立的部分组成，涵盖的主题从个人责任、职业发展，知道用于使代码保持灵活、并且易于改编和复用的各种架构技术，利用许多富有娱乐性的奇闻轶事、有思想性的例子及有趣的类比，全面阐释了软件开发的许多不同方面的最佳实践和重大陷阱。无论你是初学者，是有经验的程序员，还是软件项目经理，《程序员修炼之道:从小工到专家》都适合你阅读。","series":{"id":"6628","title":"传世经典书丛"},"price":"55.00元"},"9787115249494":{"rating":{"max":10,"numRaters":15814,"average":"8.8","min":0},"subtitle":"硅谷创业之父Paul Graham文集","author":["[美] Paul Graham"],"pubdate":"2011-4","tags":[{"count":7847,"name":"计算机","title":"计算机"},{"count":6265,"name":"互联网","title":"互联网"},{"count":5991,"name":"黑客","title":"黑客"},{"count":4666,"name":"创业","title":"创业"},{"count":2922,"name":"编程","title":"编程"},{"count":1317,"name":"软件开发","title":"软件开发"},{"count":1276,"name":"阮一峰","title":"阮一峰"},{"count":1008,"name":"美国","title":"美国"}],"origin_title":"Hackers and Painters: Big Ideas from the Computer Age","image":"https://img3.doubanio.com/view/subject/m/public/s4669554.jpg","binding":"平装","translator":["阮一峰"],"catalog":"1  为什么书呆子不受欢迎\t1\n他们的心思在别的地方。\n2  黑客与画家\t18\n黑客也是创造者，与画家、建筑师、作家一样。\n3  不能说的话\t34\n如果你的想法是社会无法容忍的，你怎么办？\n4  良好的坏习惯\t52\n与其他美国人一样，黑客的成功秘诀就是打破常规。\n5  另一条路\t59\n互联网软件是微机诞生后的最大机会。\n6  如何创造财富\t90\n致富的最好方法就是为社会创造财富。创造财富的最好方法就是创业。\n7  关注贫富分化\t111\n“收入分配不平等”的危害，会不会没有我们想的那样严重？\n8  防止垃圾邮件的一种方法\t124\n不久前，许多专家还认为无法有效地过滤垃圾邮件。本文改变了他们的想法。\n9  设计者的品味\t133\n如何做出优秀的东西？\n10  编程语言解析\t148\n什么是编程语言？为什么它们现在很热门？\n11  一百年后的编程语言\t156\n一百年后，人类怎样编程？为什么不从现在开始就这样编程呢？\n12  拒绝平庸\t169\n别忘了你的对手与你一样，能用任何想用的语言编写互联网软件。\n13  书呆子的复仇\t180\n在高科技行业，只有失败者采用“业界最佳实践”。\n14  梦寐以求的编程语言\t198\n一种好的编程语言，是让黑客可以随心所欲使用的语言。\n15  设计与研究\t213\n研究必须是“新”的，而设计必须是“好”的。\n志谢\t219\n术语解释\t221\n图片授权说明\t236","ebook_url":"https://read.douban.com/ebook/387525/","pages":"264","images":{"small":"https://img3.doubanio.com/view/subject/s/public/s4669554.jpg","large":"https://img3.doubanio.com/view/subject/l/public/s4669554.jpg","medium":"https://img3.doubanio.com/view/subject/m/public/s4669554.jpg"},"alt":"https://book.douban.com/subject/6021440/","id":"6021440","publisher":"人民邮电出版社","isbn10":"7115249490","isbn13":"9787115249494","title":"黑客与画家","url":"https://api.douban.com/v2/book/6021440","alt_title":"Hackers and Painters: Big Ideas from the Computer Age","author_intro":"保罗•格雷厄姆，《黑客与画家》一书的作者，硅谷创业之父。1964年，出生于匹兹堡郊区的一个中产阶级家庭。父亲是设计核反应堆的物理学家，母亲在家照看他和他的妹妹。青少年时代，格雷厄姆就开始编程。但是，他还喜欢许多与计算机无关的东西，这在编程高手之中是很少见的。\n保罗•格雷厄姆在康奈尔大学读完本科，然后在哈佛大学获得计算机科学博士学位。1995年，他创办了Viaweb，帮助个人用户在网上开店，这是世界上第一个互联网应用程序。1998年夏天，Yahoo!公司收购了Viaweb，收购价约为5000万美元。\n此后，他架起了个人网站paulgraham.com，在上面撰写了许许多多关于软件和创业的文章，以深刻的见解和清晰的表达而著称，迅速引起了轰动。2005年，他身体力行，创建了风险投资公司Y Combinator，将自己的理论转化为实践，目前已经资助了80多家创业公司。现在，他是公认的互联网创业权威。","summary":"本书是硅谷创业之父Paul Graham 的文集，主要介绍黑客即优秀程序员的爱好和动机，讨论黑客成长、黑客对世界的贡献以及编程语言和黑客工作方法等所有对计算机时代感兴趣的人的一些话题。书中的内容不但有助于了解计算机编程的本质、互联网行业的规则，还会帮助读者了解我们这个时代，迫使读者独立思考。\n本书适合所有程序员和互联网创业者，也适合一切对计算机行业感兴趣的读者。","ebook_price":"12.00","price":"49.00元"}}